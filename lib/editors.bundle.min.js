class Text {
    lineAt(e) {
        if (e < 0 || e > this.length) throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
        return this.lineInner(e, !1, 1, 0)
    }
    line(e) {
        if (e < 1 || e > this.lines) throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
        return this.lineInner(e, !0, 1, 0)
    }
    replace(e, t, n) {
        [e, t] = clip(this, e, t);
        let o = [];
        return this.decompose(0, e, o, 2), n.length && n.decompose(0, n.length, o, 3), this.decompose(t, this.length, o, 1), TextNode.from(o, this.length - (t - e) + n.length)
    }
    append(e) {
        return this.replace(this.length, this.length, e)
    }
    slice(e, t = this.length) {
        [e, t] = clip(this, e, t);
        let n = [];
        return this.decompose(e, t, n, 0), TextNode.from(n, t - e)
    }
    eq(e) {
        if (e == this) return !0;
        if (e.length != this.length || e.lines != this.lines) return !1;
        let t = this.scanIdentical(e, 1),
            n = this.length - this.scanIdentical(e, -1),
            o = new RawTextCursor(this),
            h = new RawTextCursor(e);
        for (let e = t, p = t;;) {
            if (o.next(e), h.next(e), e = 0, o.lineBreak != h.lineBreak || o.done != h.done || o.value != h.value) return !1;
            if (p += o.value.length, o.done || p >= n) return !0
        }
    }
    iter(e = 1) {
        return new RawTextCursor(this, e)
    }
    iterRange(e, t = this.length) {
        return new PartialTextCursor(this, e, t)
    }
    iterLines(e, t) {
        let n;
        if (null == e) n = this.iter();
        else {
            null == t && (t = this.lines + 1);
            let o = this.line(e).from;
            n = this.iterRange(o, Math.max(o, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to))
        }
        return new LineCursor(n)
    }
    toString() {
        return this.sliceString(0)
    }
    toJSON() {
        let e = [];
        return this.flatten(e), e
    }
    constructor() {}
    static of (e) {
        if (0 == e.length) throw new RangeError("A document must have at least one line");
        return 1 != e.length || e[0] ? e.length <= 32 ? new TextLeaf(e) : TextNode.from(TextLeaf.split(e, [])) : Text.empty
    }
}
class TextLeaf extends Text {
    constructor(e, t = function(e) {
        let t = -1;
        for (let n of e) t += n.length + 1;
        return t
    }(e)) {
        super(), this.text = e, this.length = t
    }
    get lines() {
        return this.text.length
    }
    get children() {
        return null
    }
    lineInner(t, n, o, h) {
        for (let p = 0;; p++) {
            let f = this.text[p],
                g = h + f.length;
            if ((n ? o : g) >= t) return new e(h, g, o, f);
            h = g + 1, o++
        }
    }
    decompose(e, t, n, o) {
        let h = e <= 0 && t >= this.length ? this : new TextLeaf(sliceText(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
        if (1 & o) {
            let e = n.pop(),
                t = appendText(h.text, e.text.slice(), 0, h.length);
            if (t.length <= 32) n.push(new TextLeaf(t, e.length + h.length));
            else {
                let e = t.length >> 1;
                n.push(new TextLeaf(t.slice(0, e)), new TextLeaf(t.slice(e)))
            }
        } else n.push(h)
    }
    replace(e, t, n) {
        if (!(n instanceof TextLeaf)) return super.replace(e, t, n);
        [e, t] = clip(this, e, t);
        let o = appendText(this.text, appendText(n.text, sliceText(this.text, 0, e)), t),
            h = this.length + n.length - (t - e);
        return o.length <= 32 ? new TextLeaf(o, h) : TextNode.from(TextLeaf.split(o, []), h)
    }
    sliceString(e, t = this.length, n = "\n") {
        [e, t] = clip(this, e, t);
        let o = "";
        for (let h = 0, p = 0; h <= t && p < this.text.length; p++) {
            let f = this.text[p],
                g = h + f.length;
            h > e && p && (o += n), e < g && t > h && (o += f.slice(Math.max(0, e - h), t - h)), h = g + 1
        }
        return o
    }
    flatten(e) {
        for (let t of this.text) e.push(t)
    }
    scanIdentical() {
        return 0
    }
    static split(e, t) {
        let n = [],
            o = -1;
        for (let h of e) n.push(h), o += h.length + 1, 32 == n.length && (t.push(new TextLeaf(n, o)), n = [], o = -1);
        return o > -1 && t.push(new TextLeaf(n, o)), t
    }
}
class TextNode extends Text {
    constructor(e, t) {
        super(), this.children = e, this.length = t, this.lines = 0;
        for (let t of e) this.lines += t.lines
    }
    lineInner(e, t, n, o) {
        for (let h = 0;; h++) {
            let p = this.children[h],
                f = o + p.length,
                g = n + p.lines - 1;
            if ((t ? g : f) >= e) return p.lineInner(e, t, n, o);
            o = f + 1, n = g + 1
        }
    }
    decompose(e, t, n, o) {
        for (let h = 0, p = 0; p <= t && h < this.children.length; h++) {
            let f = this.children[h],
                g = p + f.length;
            if (e <= g && t >= p) {
                let h = o & ((p <= e ? 1 : 0) | (g >= t ? 2 : 0));
                p >= e && g <= t && !h ? n.push(f) : f.decompose(e - p, t - p, n, h)
            }
            p = g + 1
        }
    }
    replace(e, t, n) {
        if ([e, t] = clip(this, e, t), n.lines < this.lines)
            for (let o = 0, h = 0; o < this.children.length; o++) {
                let p = this.children[o],
                    f = h + p.length;
                if (e >= h && t <= f) {
                    let g = p.replace(e - h, t - h, n),
                        y = this.lines - p.lines + g.lines;
                    if (g.lines < y >> 4 && g.lines > y >> 6) {
                        let h = this.children.slice();
                        return h[o] = g, new TextNode(h, this.length - (t - e) + n.length)
                    }
                    return super.replace(h, f, g)
                }
                h = f + 1
            }
        return super.replace(e, t, n)
    }
    sliceString(e, t = this.length, n = "\n") {
        [e, t] = clip(this, e, t);
        let o = "";
        for (let h = 0, p = 0; h < this.children.length && p <= t; h++) {
            let f = this.children[h],
                g = p + f.length;
            p > e && h && (o += n), e < g && t > p && (o += f.sliceString(e - p, t - p, n)), p = g + 1
        }
        return o
    }
    flatten(e) {
        for (let t of this.children) t.flatten(e)
    }
    scanIdentical(e, t) {
        if (!(e instanceof TextNode)) return 0;
        let n = 0,
            [o, h, p, f] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
        for (;; o += t, h += t) {
            if (o == p || h == f) return n;
            let g = this.children[o],
                y = e.children[h];
            if (g != y) return n + g.scanIdentical(y, t);
            n += g.length + 1
        }
    }
    static from(e, t = e.reduce(((e, t) => e + t.length + 1), -1)) {
        let n = 0;
        for (let t of e) n += t.lines;
        if (n < 32) {
            let n = [];
            for (let t of e) t.flatten(n);
            return new TextLeaf(n, t)
        }
        let o = Math.max(32, n >> 5),
            h = o << 1,
            p = o >> 1,
            f = [],
            g = 0,
            y = -1,
            w = [];

        function add(e) {
            let t;
            if (e.lines > h && e instanceof TextNode)
                for (let t of e.children) add(t);
            else e.lines > p && (g > p || !g) ? (flush(), f.push(e)) : e instanceof TextLeaf && g && (t = w[w.length - 1]) instanceof TextLeaf && e.lines + t.lines <= 32 ? (g += e.lines, y += e.length + 1, w[w.length - 1] = new TextLeaf(t.text.concat(e.text), t.length + 1 + e.length)) : (g + e.lines > o && flush(), g += e.lines, y += e.length + 1, w.push(e))
        }

        function flush() {
            0 != g && (f.push(1 == w.length ? w[0] : TextNode.from(w, y)), y = -1, g = w.length = 0)
        }
        for (let t of e) add(t);
        return flush(), 1 == f.length ? f[0] : new TextNode(f, t)
    }
}

function appendText(e, t, n = 0, o = 1e9) {
    for (let h = 0, p = 0, f = !0; p < e.length && h <= o; p++) {
        let g = e[p],
            y = h + g.length;
        y >= n && (y > o && (g = g.slice(0, o - h)), h < n && (g = g.slice(n - h)), f ? (t[t.length - 1] += g, f = !1) : t.push(g)), h = y + 1
    }
    return t
}

function sliceText(e, t, n) {
    return appendText(e, [""], t, n)
}
Text.empty = new TextLeaf([""], 0);
class RawTextCursor {
    constructor(e, t = 1) {
        this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof TextLeaf ? e.text.length : e.children.length) << 1]
    }
    nextInner(e, t) {
        for (this.done = this.lineBreak = !1;;) {
            let n = this.nodes.length - 1,
                o = this.nodes[n],
                h = this.offsets[n],
                p = h >> 1,
                f = o instanceof TextLeaf ? o.text.length : o.children.length;
            if (p == (t > 0 ? f : 0)) {
                if (0 == n) return this.done = !0, this.value = "", this;
                t > 0 && this.offsets[n - 1]++, this.nodes.pop(), this.offsets.pop()
            } else if ((1 & h) == (t > 0 ? 0 : 1)) {
                if (this.offsets[n] += t, 0 == e) return this.lineBreak = !0, this.value = "\n", this;
                e--
            } else if (o instanceof TextLeaf) {
                let h = o.text[p + (t < 0 ? -1 : 0)];
                if (this.offsets[n] += t, h.length > Math.max(0, e)) return this.value = 0 == e ? h : t > 0 ? h.slice(e) : h.slice(0, h.length - e), this;
                e -= h.length
            } else {
                let h = o.children[p + (t < 0 ? -1 : 0)];
                e > h.length ? (e -= h.length, this.offsets[n] += t) : (t < 0 && this.offsets[n]--, this.nodes.push(h), this.offsets.push(t > 0 ? 1 : (h instanceof TextLeaf ? h.text.length : h.children.length) << 1))
            }
        }
    }
    next(e = 0) {
        return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir)
    }
}
class PartialTextCursor {
    constructor(e, t, n) {
        this.value = "", this.done = !1, this.cursor = new RawTextCursor(e, t > n ? -1 : 1), this.pos = t > n ? e.length : 0, this.from = Math.min(t, n), this.to = Math.max(t, n)
    }
    nextInner(e, t) {
        if (t < 0 ? this.pos <= this.from : this.pos >= this.to) return this.value = "", this.done = !0, this;
        e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
        let n = t < 0 ? this.pos - this.from : this.to - this.pos;
        e > n && (e = n), n -= e;
        let {
            value: o
        } = this.cursor.next(e);
        return this.pos += (o.length + e) * t, this.value = o.length <= n ? o : t < 0 ? o.slice(o.length - n) : o.slice(0, n), this.done = !this.value, this
    }
    next(e = 0) {
        return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir)
    }
    get lineBreak() {
        return this.cursor.lineBreak && "" != this.value
    }
}
class LineCursor {
    constructor(e) {
        this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1
    }
    next(e = 0) {
        let {
            done: t,
            lineBreak: n,
            value: o
        } = this.inner.next(e);
        return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : n ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = o, this.afterBreak = !1), this
    }
    get lineBreak() {
        return !1
    }
}
"undefined" != typeof Symbol && (Text.prototype[Symbol.iterator] = function() {
    return this.iter()
}, RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this
});
let e = class {
    constructor(e, t, n, o) {
        this.from = e, this.to = t, this.number = n, this.text = o
    }
    get length() {
        return this.to - this.from
    }
};

function clip(e, t, n) {
    return [t = Math.max(0, Math.min(e.length, t)), Math.max(t, Math.min(e.length, n))]
}
let t = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e => e ? parseInt(e, 36) : 1));
for (let eh = 1; eh < t.length; eh++) t[eh] += t[eh - 1];

function isExtendingChar(e) {
    for (let n = 1; n < t.length; n += 2)
        if (t[n] > e) return t[n - 1] <= e;
    return !1
}

function isRegionalIndicator(e) {
    return e >= 127462 && e <= 127487
}

function findClusterBreak(e, t, n = !0, o = !0) {
    return (n ? nextClusterBreak : prevClusterBreak)(e, t, o)
}

function nextClusterBreak(e, t, n) {
    if (t == e.length) return t;
    t && surrogateLow(e.charCodeAt(t)) && surrogateHigh(e.charCodeAt(t - 1)) && t--;
    let o = codePointAt(e, t);
    for (t += codePointSize(o); t < e.length;) {
        let h = codePointAt(e, t);
        if (8205 == o || 8205 == h || n && isExtendingChar(h)) t += codePointSize(h), o = h;
        else {
            if (!isRegionalIndicator(h)) break; {
                let n = 0,
                    o = t - 2;
                for (; o >= 0 && isRegionalIndicator(codePointAt(e, o));) n++, o -= 2;
                if (n % 2 == 0) break;
                t += 2
            }
        }
    }
    return t
}

function prevClusterBreak(e, t, n) {
    for (; t > 0;) {
        let o = nextClusterBreak(e, t - 2, n);
        if (o < t) return o;
        t--
    }
    return 0
}

function surrogateLow(e) {
    return e >= 56320 && e < 57344
}

function surrogateHigh(e) {
    return e >= 55296 && e < 56320
}

function codePointAt(e, t) {
    let n = e.charCodeAt(t);
    if (!surrogateHigh(n) || t + 1 == e.length) return n;
    let o = e.charCodeAt(t + 1);
    return surrogateLow(o) ? o - 56320 + (n - 55296 << 10) + 65536 : n
}

function fromCodePoint(e) {
    return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e)))
}

function codePointSize(e) {
    return e < 65536 ? 1 : 2
}
const n = /\r\n?|\n/;
var o = function(e) {
    return e[e.Simple = 0] = "Simple", e[e.TrackDel = 1] = "TrackDel", e[e.TrackBefore = 2] = "TrackBefore", e[e.TrackAfter = 3] = "TrackAfter", e
}(o || (o = {}));
class ChangeDesc {
    constructor(e) {
        this.sections = e
    }
    get length() {
        let e = 0;
        for (let t = 0; t < this.sections.length; t += 2) e += this.sections[t];
        return e
    }
    get newLength() {
        let e = 0;
        for (let t = 0; t < this.sections.length; t += 2) {
            let n = this.sections[t + 1];
            e += n < 0 ? this.sections[t] : n
        }
        return e
    }
    get empty() {
        return 0 == this.sections.length || 2 == this.sections.length && this.sections[1] < 0
    }
    iterGaps(e) {
        for (let t = 0, n = 0, o = 0; t < this.sections.length;) {
            let h = this.sections[t++],
                p = this.sections[t++];
            p < 0 ? (e(n, o, h), o += h) : o += p, n += h
        }
    }
    iterChangedRanges(e, t = !1) {
        iterChanges(this, e, t)
    }
    get invertedDesc() {
        let e = [];
        for (let t = 0; t < this.sections.length;) {
            let n = this.sections[t++],
                o = this.sections[t++];
            o < 0 ? e.push(n, o) : e.push(o, n)
        }
        return new ChangeDesc(e)
    }
    composeDesc(e) {
        return this.empty ? e : e.empty ? this : composeSets(this, e)
    }
    mapDesc(e, t = !1) {
        return e.empty ? this : mapSet(this, e, t)
    }
    mapPos(e, t = -1, n = o.Simple) {
        let h = 0,
            p = 0;
        for (let f = 0; f < this.sections.length;) {
            let g = this.sections[f++],
                y = this.sections[f++],
                w = h + g;
            if (y < 0) {
                if (w > e) return p + (e - h);
                p += g
            } else {
                if (n != o.Simple && w >= e && (n == o.TrackDel && h < e && w > e || n == o.TrackBefore && h < e || n == o.TrackAfter && w > e)) return null;
                if (w > e || w == e && t < 0 && !g) return e == h || t < 0 ? p : p + y;
                p += y
            }
            h = w
        }
        if (e > h) throw new RangeError(`Position ${e} is out of range for changeset of length ${h}`);
        return p
    }
    touchesRange(e, t = e) {
        for (let n = 0, o = 0; n < this.sections.length && o <= t;) {
            let h = o + this.sections[n++];
            if (this.sections[n++] >= 0 && o <= t && h >= e) return !(o < e && h > t) || "cover";
            o = h
        }
        return !1
    }
    toString() {
        let e = "";
        for (let t = 0; t < this.sections.length;) {
            let n = this.sections[t++],
                o = this.sections[t++];
            e += (e ? " " : "") + n + (o >= 0 ? ":" + o : "")
        }
        return e
    }
    toJSON() {
        return this.sections
    }
    static fromJSON(e) {
        if (!Array.isArray(e) || e.length % 2 || e.some((e => "number" != typeof e))) throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new ChangeDesc(e)
    }
    static create(e) {
        return new ChangeDesc(e)
    }
}
class ChangeSet extends ChangeDesc {
    constructor(e, t) {
        super(e), this.inserted = t
    }
    apply(e) {
        if (this.length != e.length) throw new RangeError("Applying change set to a document with the wrong length");
        return iterChanges(this, ((t, n, o, h, p) => e = e.replace(o, o + (n - t), p)), !1), e
    }
    mapDesc(e, t = !1) {
        return mapSet(this, e, t, !0)
    }
    invert(e) {
        let t = this.sections.slice(),
            n = [];
        for (let o = 0, h = 0; o < t.length; o += 2) {
            let p = t[o],
                f = t[o + 1];
            if (f >= 0) {
                t[o] = f, t[o + 1] = p;
                let g = o >> 1;
                for (; n.length < g;) n.push(Text.empty);
                n.push(p ? e.slice(h, h + p) : Text.empty)
            }
            h += p
        }
        return new ChangeSet(t, n)
    }
    compose(e) {
        return this.empty ? e : e.empty ? this : composeSets(this, e, !0)
    }
    map(e, t = !1) {
        return e.empty ? this : mapSet(this, e, t, !0)
    }
    iterChanges(e, t = !1) {
        iterChanges(this, e, t)
    }
    get desc() {
        return ChangeDesc.create(this.sections)
    }
    filter(e) {
        let t = [],
            n = [],
            o = [],
            h = new SectionIter(this);
        e: for (let p = 0, f = 0;;) {
            let g = p == e.length ? 1e9 : e[p++];
            for (; f < g || f == g && 0 == h.len;) {
                if (h.done) break e;
                let e = Math.min(h.len, g - f);
                addSection(o, e, -1);
                let p = -1 == h.ins ? -1 : 0 == h.off ? h.ins : 0;
                addSection(t, e, p), p > 0 && addInsert(n, t, h.text), h.forward(e), f += e
            }
            let y = e[p++];
            for (; f < y;) {
                if (h.done) break e;
                let e = Math.min(h.len, y - f);
                addSection(t, e, -1), addSection(o, e, -1 == h.ins ? -1 : 0 == h.off ? h.ins : 0), h.forward(e), f += e
            }
        }
        return {
            changes: new ChangeSet(t, n),
            filtered: ChangeDesc.create(o)
        }
    }
    toJSON() {
        let e = [];
        for (let t = 0; t < this.sections.length; t += 2) {
            let n = this.sections[t],
                o = this.sections[t + 1];
            o < 0 ? e.push(n) : 0 == o ? e.push([n]) : e.push([n].concat(this.inserted[t >> 1].toJSON()))
        }
        return e
    }
    static of (e, t, o) {
        let h = [],
            p = [],
            f = 0,
            g = null;

        function flush(e = !1) {
            if (!e && !h.length) return;
            f < t && addSection(h, t - f, -1);
            let n = new ChangeSet(h, p);
            g = g ? g.compose(n.map(g)) : n, h = [], p = [], f = 0
        }
        return function process(e) {
            if (Array.isArray(e))
                for (let t of e) process(t);
            else if (e instanceof ChangeSet) {
                if (e.length != t) throw new RangeError(`Mismatched change set length (got ${e.length}, expected ${t})`);
                flush(), g = g ? g.compose(e.map(g)) : e
            } else {
                let {
                    from: g,
                    to: y = g,
                    insert: w
                } = e;
                if (g > y || g < 0 || y > t) throw new RangeError(`Invalid change range ${g} to ${y} (in doc of length ${t})`);
                let b = w ? "string" == typeof w ? Text.of(w.split(o || n)) : w : Text.empty,
                    S = b.length;
                if (g == y && 0 == S) return;
                g < f && flush(), g > f && addSection(h, g - f, -1), addSection(h, y - g, S), addInsert(p, h, b), f = y
            }
        }(e), flush(!g), g
    }
    static empty(e) {
        return new ChangeSet(e ? [e, -1] : [], [])
    }
    static fromJSON(e) {
        if (!Array.isArray(e)) throw new RangeError("Invalid JSON representation of ChangeSet");
        let t = [],
            n = [];
        for (let o = 0; o < e.length; o++) {
            let h = e[o];
            if ("number" == typeof h) t.push(h, -1);
            else {
                if (!Array.isArray(h) || "number" != typeof h[0] || h.some(((e, t) => t && "string" != typeof e))) throw new RangeError("Invalid JSON representation of ChangeSet");
                if (1 == h.length) t.push(h[0], 0);
                else {
                    for (; n.length < o;) n.push(Text.empty);
                    n[o] = Text.of(h.slice(1)), t.push(h[0], n[o].length)
                }
            }
        }
        return new ChangeSet(t, n)
    }
    static createSet(e, t) {
        return new ChangeSet(e, t)
    }
}

function addSection(e, t, n, o = !1) {
    if (0 == t && n <= 0) return;
    let h = e.length - 2;
    h >= 0 && n <= 0 && n == e[h + 1] ? e[h] += t : 0 == t && 0 == e[h] ? e[h + 1] += n : o ? (e[h] += t, e[h + 1] += n) : e.push(t, n)
}

function addInsert(e, t, n) {
    if (0 == n.length) return;
    let o = t.length - 2 >> 1;
    if (o < e.length) e[e.length - 1] = e[e.length - 1].append(n);
    else {
        for (; e.length < o;) e.push(Text.empty);
        e.push(n)
    }
}

function iterChanges(e, t, n) {
    let o = e.inserted;
    for (let h = 0, p = 0, f = 0; f < e.sections.length;) {
        let g = e.sections[f++],
            y = e.sections[f++];
        if (y < 0) h += g, p += g;
        else {
            let w = h,
                b = p,
                S = Text.empty;
            for (; w += g, b += y, y && o && (S = S.append(o[f - 2 >> 1])), !(n || f == e.sections.length || e.sections[f + 1] < 0);) g = e.sections[f++], y = e.sections[f++];
            t(h, w, p, b, S), h = w, p = b
        }
    }
}

function mapSet(e, t, n, o = !1) {
    let h = [],
        p = o ? [] : null,
        f = new SectionIter(e),
        g = new SectionIter(t);
    for (let e = -1;;)
        if (-1 == f.ins && -1 == g.ins) {
            let e = Math.min(f.len, g.len);
            addSection(h, e, -1), f.forward(e), g.forward(e)
        } else if (g.ins >= 0 && (f.ins < 0 || e == f.i || 0 == f.off && (g.len < f.len || g.len == f.len && !n))) {
        let t = g.len;
        for (addSection(h, g.ins, -1); t;) {
            let n = Math.min(f.len, t);
            f.ins >= 0 && e < f.i && f.len <= n && (addSection(h, 0, f.ins), p && addInsert(p, h, f.text), e = f.i), f.forward(n), t -= n
        }
        g.next()
    } else {
        if (!(f.ins >= 0)) {
            if (f.done && g.done) return p ? ChangeSet.createSet(h, p) : ChangeDesc.create(h);
            throw new Error("Mismatched change set lengths")
        } {
            let t = 0,
                n = f.len;
            for (; n;)
                if (-1 == g.ins) {
                    let e = Math.min(n, g.len);
                    t += e, n -= e, g.forward(e)
                } else {
                    if (!(0 == g.ins && g.len < n)) break;
                    n -= g.len, g.next()
                }
            addSection(h, t, e < f.i ? f.ins : 0), p && e < f.i && addInsert(p, h, f.text), e = f.i, f.forward(f.len - n)
        }
    }
}

function composeSets(e, t, n = !1) {
    let o = [],
        h = n ? [] : null,
        p = new SectionIter(e),
        f = new SectionIter(t);
    for (let e = !1;;) {
        if (p.done && f.done) return h ? ChangeSet.createSet(o, h) : ChangeDesc.create(o);
        if (0 == p.ins) addSection(o, p.len, 0, e), p.next();
        else if (0 != f.len || f.done) {
            if (p.done || f.done) throw new Error("Mismatched change set lengths"); {
                let t = Math.min(p.len2, f.len),
                    n = o.length;
                if (-1 == p.ins) {
                    let n = -1 == f.ins ? -1 : f.off ? 0 : f.ins;
                    addSection(o, t, n, e), h && n && addInsert(h, o, f.text)
                } else -1 == f.ins ? (addSection(o, p.off ? 0 : p.len, t, e), h && addInsert(h, o, p.textBit(t))) : (addSection(o, p.off ? 0 : p.len, f.off ? 0 : f.ins, e), h && !f.off && addInsert(h, o, f.text));
                e = (p.ins > t || f.ins >= 0 && f.len > t) && (e || o.length > n), p.forward2(t), f.forward(t)
            }
        } else addSection(o, 0, f.ins, e), h && addInsert(h, o, f.text), f.next()
    }
}
class SectionIter {
    constructor(e) {
        this.set = e, this.i = 0, this.next()
    }
    next() {
        let {
            sections: e
        } = this.set;
        this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0
    }
    get done() {
        return -2 == this.ins
    }
    get len2() {
        return this.ins < 0 ? this.len : this.ins
    }
    get text() {
        let {
            inserted: e
        } = this.set, t = this.i - 2 >> 1;
        return t >= e.length ? Text.empty : e[t]
    }
    textBit(e) {
        let {
            inserted: t
        } = this.set, n = this.i - 2 >> 1;
        return n >= t.length && !e ? Text.empty : t[n].slice(this.off, null == e ? void 0 : this.off + e)
    }
    forward(e) {
        e == this.len ? this.next() : (this.len -= e, this.off += e)
    }
    forward2(e) {
        -1 == this.ins ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e)
    }
}
class SelectionRange {
    constructor(e, t, n) {
        this.from = e, this.to = t, this.flags = n
    }
    get anchor() {
        return 32 & this.flags ? this.to : this.from
    }
    get head() {
        return 32 & this.flags ? this.from : this.to
    }
    get empty() {
        return this.from == this.to
    }
    get assoc() {
        return 8 & this.flags ? -1 : 16 & this.flags ? 1 : 0
    }
    get bidiLevel() {
        let e = 7 & this.flags;
        return 7 == e ? null : e
    }
    get goalColumn() {
        let e = this.flags >> 6;
        return 16777215 == e ? void 0 : e
    }
    map(e, t = -1) {
        let n, o;
        return this.empty ? n = o = e.mapPos(this.from, t) : (n = e.mapPos(this.from, 1), o = e.mapPos(this.to, -1)), n == this.from && o == this.to ? this : new SelectionRange(n, o, this.flags)
    }
    extend(e, t = e) {
        if (e <= this.anchor && t >= this.anchor) return EditorSelection.range(e, t);
        let n = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
        return EditorSelection.range(this.anchor, n)
    }
    eq(e, t = !1) {
        return !(this.anchor != e.anchor || this.head != e.head || t && this.empty && this.assoc != e.assoc)
    }
    toJSON() {
        return {
            anchor: this.anchor,
            head: this.head
        }
    }
    static fromJSON(e) {
        if (!e || "number" != typeof e.anchor || "number" != typeof e.head) throw new RangeError("Invalid JSON representation for SelectionRange");
        return EditorSelection.range(e.anchor, e.head)
    }
    static create(e, t, n) {
        return new SelectionRange(e, t, n)
    }
}
class EditorSelection {
    constructor(e, t) {
        this.ranges = e, this.mainIndex = t
    }
    map(e, t = -1) {
        return e.empty ? this : EditorSelection.create(this.ranges.map((n => n.map(e, t))), this.mainIndex)
    }
    eq(e, t = !1) {
        if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex) return !1;
        for (let n = 0; n < this.ranges.length; n++)
            if (!this.ranges[n].eq(e.ranges[n], t)) return !1;
        return !0
    }
    get main() {
        return this.ranges[this.mainIndex]
    }
    asSingle() {
        return 1 == this.ranges.length ? this : new EditorSelection([this.main], 0)
    }
    addRange(e, t = !0) {
        return EditorSelection.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1)
    }
    replaceRange(e, t = this.mainIndex) {
        let n = this.ranges.slice();
        return n[t] = e, EditorSelection.create(n, this.mainIndex)
    }
    toJSON() {
        return {
            ranges: this.ranges.map((e => e.toJSON())),
            main: this.mainIndex
        }
    }
    static fromJSON(e) {
        if (!e || !Array.isArray(e.ranges) || "number" != typeof e.main || e.main >= e.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection");
        return new EditorSelection(e.ranges.map((e => SelectionRange.fromJSON(e))), e.main)
    }
    static single(e, t = e) {
        return new EditorSelection([EditorSelection.range(e, t)], 0)
    }
    static create(e, t = 0) {
        if (0 == e.length) throw new RangeError("A selection needs at least one range");
        for (let n = 0, o = 0; o < e.length; o++) {
            let h = e[o];
            if (h.empty ? h.from <= n : h.from < n) return EditorSelection.normalized(e.slice(), t);
            n = h.to
        }
        return new EditorSelection(e, t)
    }
    static cursor(e, t = 0, n, o) {
        return SelectionRange.create(e, e, (0 == t ? 0 : t < 0 ? 8 : 16) | (null == n ? 7 : Math.min(6, n)) | (null != o ? o : 16777215) << 6)
    }
    static range(e, t, n, o) {
        let h = (null != n ? n : 16777215) << 6 | (null == o ? 7 : Math.min(6, o));
        return t < e ? SelectionRange.create(t, e, 48 | h) : SelectionRange.create(e, t, (t > e ? 8 : 0) | h)
    }
    static normalized(e, t = 0) {
        let n = e[t];
        e.sort(((e, t) => e.from - t.from)), t = e.indexOf(n);
        for (let n = 1; n < e.length; n++) {
            let o = e[n],
                h = e[n - 1];
            if (o.empty ? o.from <= h.to : o.from < h.to) {
                let p = h.from,
                    f = Math.max(o.to, h.to);
                n <= t && t--, e.splice(--n, 2, o.anchor > o.head ? EditorSelection.range(f, p) : EditorSelection.range(p, f))
            }
        }
        return new EditorSelection(e, t)
    }
}

function checkSelection(e, t) {
    for (let n of e.ranges)
        if (n.to > t) throw new RangeError("Selection points outside of document")
}
let h = 0;
class Facet {
    constructor(e, t, n, o, p) {
        this.combine = e, this.compareInput = t, this.compare = n, this.isStatic = o, this.id = h++, this.default = e([]), this.extensions = "function" == typeof p ? p(this) : p
    }
    get reader() {
        return this
    }
    static define(e = {}) {
        return new Facet(e.combine || (e => e), e.compareInput || ((e, t) => e === t), e.compare || (e.combine ? (e, t) => e === t : sameArray$1), !!e.static, e.enables)
    } of (e) {
        return new FacetProvider([], this, 0, e)
    }
    compute(e, t) {
        if (this.isStatic) throw new Error("Can't compute a static facet");
        return new FacetProvider(e, this, 1, t)
    }
    computeN(e, t) {
        if (this.isStatic) throw new Error("Can't compute a static facet");
        return new FacetProvider(e, this, 2, t)
    }
    from(e, t) {
        return t || (t = e => e), this.compute([e], (n => t(n.field(e))))
    }
}

function sameArray$1(e, t) {
    return e == t || e.length == t.length && e.every(((e, n) => e === t[n]))
}
class FacetProvider {
    constructor(e, t, n, o) {
        this.dependencies = e, this.facet = t, this.type = n, this.value = o, this.id = h++
    }
    dynamicSlot(e) {
        var t;
        let n = this.value,
            o = this.facet.compareInput,
            h = this.id,
            p = e[h] >> 1,
            f = 2 == this.type,
            g = !1,
            y = !1,
            w = [];
        for (let n of this.dependencies) "doc" == n ? g = !0 : "selection" == n ? y = !0 : 1 & (null !== (t = e[n.id]) && void 0 !== t ? t : 1) || w.push(e[n.id]);
        return {
            create: e => (e.values[p] = n(e), 1),
            update(e, t) {
                if (g && t.docChanged || y && (t.docChanged || t.selection) || ensureAll(e, w)) {
                    let t = n(e);
                    if (f ? !compareArray(t, e.values[p], o) : !o(t, e.values[p])) return e.values[p] = t, 1
                }
                return 0
            },
            reconfigure: (e, t) => {
                let g, y = t.config.address[h];
                if (null != y) {
                    let h = getAddr(t, y);
                    if (this.dependencies.every((n => n instanceof Facet ? t.facet(n) === e.facet(n) : !(n instanceof StateField) || t.field(n, !1) == e.field(n, !1))) || (f ? compareArray(g = n(e), h, o) : o(g = n(e), h))) return e.values[p] = h, 0
                } else g = n(e);
                return e.values[p] = g, 1
            }
        }
    }
}

function compareArray(e, t, n) {
    if (e.length != t.length) return !1;
    for (let o = 0; o < e.length; o++)
        if (!n(e[o], t[o])) return !1;
    return !0
}

function ensureAll(e, t) {
    let n = !1;
    for (let o of t) 1 & ensureAddr(e, o) && (n = !0);
    return n
}

function dynamicFacetSlot(e, t, n) {
    let o = n.map((t => e[t.id])),
        h = n.map((e => e.type)),
        p = o.filter((e => !(1 & e))),
        f = e[t.id] >> 1;

    function get(e) {
        let n = [];
        for (let t = 0; t < o.length; t++) {
            let p = getAddr(e, o[t]);
            if (2 == h[t])
                for (let e of p) n.push(e);
            else n.push(p)
        }
        return t.combine(n)
    }
    return {
        create(e) {
            for (let t of o) ensureAddr(e, t);
            return e.values[f] = get(e), 1
        },
        update(e, n) {
            if (!ensureAll(e, p)) return 0;
            let o = get(e);
            return t.compare(o, e.values[f]) ? 0 : (e.values[f] = o, 1)
        },
        reconfigure(e, h) {
            let p = ensureAll(e, o),
                g = h.config.facets[t.id],
                y = h.facet(t);
            if (g && !p && sameArray$1(n, g)) return e.values[f] = y, 0;
            let w = get(e);
            return t.compare(w, y) ? (e.values[f] = y, 0) : (e.values[f] = w, 1)
        }
    }
}
const p = Facet.define({
    static: !0
});
class StateField {
    constructor(e, t, n, o, h) {
        this.id = e, this.createF = t, this.updateF = n, this.compareF = o, this.spec = h, this.provides = void 0
    }
    static define(e) {
        let t = new StateField(h++, e.create, e.update, e.compare || ((e, t) => e === t), e);
        return e.provide && (t.provides = e.provide(t)), t
    }
    create(e) {
        let t = e.facet(p).find((e => e.field == this));
        return ((null == t ? void 0 : t.create) || this.createF)(e)
    }
    slot(e) {
        let t = e[this.id] >> 1;
        return {
            create: e => (e.values[t] = this.create(e), 1),
            update: (e, n) => {
                let o = e.values[t],
                    h = this.updateF(o, n);
                return this.compareF(o, h) ? 0 : (e.values[t] = h, 1)
            },
            reconfigure: (e, n) => null != n.config.address[this.id] ? (e.values[t] = n.field(this), 0) : (e.values[t] = this.create(e), 1)
        }
    }
    init(e) {
        return [this, p.of({
            field: this,
            create: e
        })]
    }
    get extension() {
        return this
    }
}
const f = 4,
    g = 3,
    y = 2,
    w = 1;

function prec(e) {
    return t => new PrecExtension(t, e)
}
const b = {
    highest: prec(0),
    high: prec(w),
    default: prec(y),
    low: prec(g),
    lowest: prec(f)
};
class PrecExtension {
    constructor(e, t) {
        this.inner = e, this.prec = t
    }
}
class Compartment { of (e) {
        return new CompartmentInstance(this, e)
    }
    reconfigure(e) {
        return Compartment.reconfigure.of({
            compartment: this,
            extension: e
        })
    }
    get(e) {
        return e.config.compartments.get(this)
    }
}
class CompartmentInstance {
    constructor(e, t) {
        this.compartment = e, this.inner = t
    }
}
class Configuration {
    constructor(e, t, n, o, h, p) {
        for (this.base = e, this.compartments = t, this.dynamicSlots = n, this.address = o, this.staticValues = h, this.facets = p, this.statusTemplate = []; this.statusTemplate.length < n.length;) this.statusTemplate.push(0)
    }
    staticFacet(e) {
        let t = this.address[e.id];
        return null == t ? e.default : this.staticValues[t >> 1]
    }
    static resolve(e, t, n) {
        let o = [],
            h = Object.create(null),
            p = new Map;
        for (let n of function(e, t, n) {
                let o = [
                        [],
                        [],
                        [],
                        [],
                        []
                    ],
                    h = new Map;

                function inner(e, p) {
                    let f = h.get(e);
                    if (null != f) {
                        if (f <= p) return;
                        let t = o[f].indexOf(e);
                        t > -1 && o[f].splice(t, 1), e instanceof CompartmentInstance && n.delete(e.compartment)
                    }
                    if (h.set(e, p), Array.isArray(e))
                        for (let t of e) inner(t, p);
                    else if (e instanceof CompartmentInstance) {
                        if (n.has(e.compartment)) throw new RangeError("Duplicate use of compartment in extensions");
                        let o = t.get(e.compartment) || e.inner;
                        n.set(e.compartment, o), inner(o, p)
                    } else if (e instanceof PrecExtension) inner(e.inner, e.prec);
                    else if (e instanceof StateField) o[p].push(e), e.provides && inner(e.provides, p);
                    else if (e instanceof FacetProvider) o[p].push(e), e.facet.extensions && inner(e.facet.extensions, y);
                    else {
                        let t = e.extension;
                        if (!t) throw new Error(`Unrecognized extension value in extension set (${e}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
                        inner(t, p)
                    }
                }
                return inner(e, y), o.reduce(((e, t) => e.concat(t)))
            }(e, t, p)) n instanceof StateField ? o.push(n) : (h[n.facet.id] || (h[n.facet.id] = [])).push(n);
        let f = Object.create(null),
            g = [],
            w = [];
        for (let e of o) f[e.id] = w.length << 1, w.push((t => e.slot(t)));
        let b = null == n ? void 0 : n.config.facets;
        for (let e in h) {
            let t = h[e],
                o = t[0].facet,
                p = b && b[e] || [];
            if (t.every((e => 0 == e.type)))
                if (f[o.id] = g.length << 1 | 1, sameArray$1(p, t)) g.push(n.facet(o));
                else {
                    let e = o.combine(t.map((e => e.value)));
                    g.push(n && o.compare(e, n.facet(o)) ? n.facet(o) : e)
                }
            else {
                for (let e of t) 0 == e.type ? (f[e.id] = g.length << 1 | 1, g.push(e.value)) : (f[e.id] = w.length << 1, w.push((t => e.dynamicSlot(t))));
                f[o.id] = w.length << 1, w.push((e => dynamicFacetSlot(e, o, t)))
            }
        }
        let S = w.map((e => e(f)));
        return new Configuration(e, p, S, f, g, h)
    }
}

function ensureAddr(e, t) {
    if (1 & t) return 2;
    let n = t >> 1,
        o = e.status[n];
    if (4 == o) throw new Error("Cyclic dependency between fields and/or facets");
    if (2 & o) return o;
    e.status[n] = 4;
    let h = e.computeSlot(e, e.config.dynamicSlots[n]);
    return e.status[n] = 2 | h
}

function getAddr(e, t) {
    return 1 & t ? e.config.staticValues[t >> 1] : e.values[t >> 1]
}
const S = Facet.define(),
    k = Facet.define({
        combine: e => e.some((e => e)),
        static: !0
    }),
    v = Facet.define({
        combine: e => e.length ? e[0] : void 0,
        static: !0
    }),
    P = Facet.define(),
    C = Facet.define(),
    Q = Facet.define(),
    $ = Facet.define({
        combine: e => !!e.length && e[0]
    });
class Annotation {
    constructor(e, t) {
        this.type = e, this.value = t
    }
    static define() {
        return new AnnotationType
    }
}
class AnnotationType { of (e) {
        return new Annotation(this, e)
    }
}
class StateEffectType {
    constructor(e) {
        this.map = e
    } of (e) {
        return new StateEffect(this, e)
    }
}
class StateEffect {
    constructor(e, t) {
        this.type = e, this.value = t
    }
    map(e) {
        let t = this.type.map(this.value, e);
        return void 0 === t ? void 0 : t == this.value ? this : new StateEffect(this.type, t)
    }
    is(e) {
        return this.type == e
    }
    static define(e = {}) {
        return new StateEffectType(e.map || (e => e))
    }
    static mapEffects(e, t) {
        if (!e.length) return e;
        let n = [];
        for (let o of e) {
            let e = o.map(t);
            e && n.push(e)
        }
        return n
    }
}
StateEffect.reconfigure = StateEffect.define(), StateEffect.appendConfig = StateEffect.define();
let A = class Transaction {
    constructor(e, t, n, o, h, p) {
        this.startState = e, this.changes = t, this.selection = n, this.effects = o, this.annotations = h, this.scrollIntoView = p, this._doc = null, this._state = null, n && checkSelection(n, t.newLength), h.some((e => e.type == Transaction.time)) || (this.annotations = h.concat(Transaction.time.of(Date.now())))
    }
    static create(e, t, n, o, h, p) {
        return new Transaction(e, t, n, o, h, p)
    }
    get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc))
    }
    get newSelection() {
        return this.selection || this.startState.selection.map(this.changes)
    }
    get state() {
        return this._state || this.startState.applyTransaction(this), this._state
    }
    annotation(e) {
        for (let t of this.annotations)
            if (t.type == e) return t.value
    }
    get docChanged() {
        return !this.changes.empty
    }
    get reconfigured() {
        return this.startState.config != this.state.config
    }
    isUserEvent(e) {
        let t = this.annotation(Transaction.userEvent);
        return !(!t || !(t == e || t.length > e.length && t.slice(0, e.length) == e && "." == t[e.length]))
    }
};

function joinRanges(e, t) {
    let n = [];
    for (let o = 0, h = 0;;) {
        let p, f;
        if (o < e.length && (h == t.length || t[h] >= e[o])) p = e[o++], f = e[o++];
        else {
            if (!(h < t.length)) return n;
            p = t[h++], f = t[h++]
        }!n.length || n[n.length - 1] < p ? n.push(p, f) : n[n.length - 1] < f && (n[n.length - 1] = f)
    }
}

function mergeTransaction(e, t, n) {
    var o;
    let h, p, f;
    return n ? (h = t.changes, p = ChangeSet.empty(t.changes.length), f = e.changes.compose(t.changes)) : (h = t.changes.map(e.changes), p = e.changes.mapDesc(t.changes, !0), f = e.changes.compose(h)), {
        changes: f,
        selection: t.selection ? t.selection.map(p) : null === (o = e.selection) || void 0 === o ? void 0 : o.map(h),
        effects: StateEffect.mapEffects(e.effects, h).concat(StateEffect.mapEffects(t.effects, p)),
        annotations: e.annotations.length ? e.annotations.concat(t.annotations) : t.annotations,
        scrollIntoView: e.scrollIntoView || t.scrollIntoView
    }
}

function resolveTransactionInner(e, t, n) {
    let o = t.selection,
        h = asArray$1(t.annotations);
    return t.userEvent && (h = h.concat(A.userEvent.of(t.userEvent))), {
        changes: t.changes instanceof ChangeSet ? t.changes : ChangeSet.of(t.changes || [], n, e.facet(v)),
        selection: o && (o instanceof EditorSelection ? o : EditorSelection.single(o.anchor, o.head)),
        effects: asArray$1(t.effects),
        annotations: h,
        scrollIntoView: !!t.scrollIntoView
    }
}

function resolveTransaction(e, t, n) {
    let o = resolveTransactionInner(e, t.length ? t[0] : {}, e.doc.length);
    t.length && !1 === t[0].filter && (n = !1);
    for (let h = 1; h < t.length; h++) {
        !1 === t[h].filter && (n = !1);
        let p = !!t[h].sequential;
        o = mergeTransaction(o, resolveTransactionInner(e, t[h], p ? o.changes.newLength : e.doc.length), p)
    }
    let h = A.create(e, o.changes, o.selection, o.effects, o.annotations, o.scrollIntoView);
    return function(e) {
        let t = e.startState,
            n = t.facet(Q),
            o = e;
        for (let h = n.length - 1; h >= 0; h--) {
            let p = n[h](e);
            p && Object.keys(p).length && (o = mergeTransaction(o, resolveTransactionInner(t, p, e.changes.newLength), !0))
        }
        return o == e ? e : A.create(t, e.changes, e.selection, o.effects, o.annotations, o.scrollIntoView)
    }(n ? function(e) {
        let t = e.startState,
            n = !0;
        for (let o of t.facet(P)) {
            let t = o(e);
            if (!1 === t) {
                n = !1;
                break
            }
            Array.isArray(t) && (n = !0 === n ? t : joinRanges(n, t))
        }
        if (!0 !== n) {
            let o, h;
            if (!1 === n) h = e.changes.invertedDesc, o = ChangeSet.empty(t.doc.length);
            else {
                let t = e.changes.filter(n);
                o = t.changes, h = t.filtered.mapDesc(t.changes).invertedDesc
            }
            e = A.create(t, o, e.selection && e.selection.map(h), StateEffect.mapEffects(e.effects, h), e.annotations, e.scrollIntoView)
        }
        let o = t.facet(C);
        for (let n = o.length - 1; n >= 0; n--) {
            let h = o[n](e);
            e = h instanceof A ? h : Array.isArray(h) && 1 == h.length && h[0] instanceof A ? h[0] : resolveTransaction(t, asArray$1(h), !1)
        }
        return e
    }(h) : h)
}
A.time = Annotation.define(), A.userEvent = Annotation.define(), A.addToHistory = Annotation.define(), A.remote = Annotation.define();
const M = [];

function asArray$1(e) {
    return null == e ? M : Array.isArray(e) ? e : [e]
}
var R = function(e) {
    return e[e.Word = 0] = "Word", e[e.Space = 1] = "Space", e[e.Other = 2] = "Other", e
}(R || (R = {}));
const D = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let L;
try {
    L = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u")
} catch (th) {}

function makeCategorizer(e) {
    return t => {
        if (!/\S/.test(t)) return R.Space;
        if (function(e) {
                if (L) return L.test(e);
                for (let t = 0; t < e.length; t++) {
                    let n = e[t];
                    if (/\w/.test(n) || n > "Â€" && (n.toUpperCase() != n.toLowerCase() || D.test(n))) return !0
                }
                return !1
            }(t)) return R.Word;
        for (let n = 0; n < e.length; n++)
            if (t.indexOf(e[n]) > -1) return R.Word;
        return R.Other
    }
}
class EditorState {
    constructor(e, t, n, o, h, p) {
        this.config = e, this.doc = t, this.selection = n, this.values = o, this.status = e.statusTemplate.slice(), this.computeSlot = h, p && (p._state = this);
        for (let e = 0; e < this.config.dynamicSlots.length; e++) ensureAddr(this, e << 1);
        this.computeSlot = null
    }
    field(e, t = !0) {
        let n = this.config.address[e.id];
        if (null != n) return ensureAddr(this, n), getAddr(this, n);
        if (t) throw new RangeError("Field is not present in this state")
    }
    update(...e) {
        return resolveTransaction(this, e, !0)
    }
    applyTransaction(e) {
        let t, n = this.config,
            {
                base: o,
                compartments: h
            } = n;
        for (let t of e.effects) t.is(Compartment.reconfigure) ? (n && (h = new Map, n.compartments.forEach(((e, t) => h.set(t, e))), n = null), h.set(t.value.compartment, t.value.extension)) : t.is(StateEffect.reconfigure) ? (n = null, o = t.value) : t.is(StateEffect.appendConfig) && (n = null, o = asArray$1(o).concat(t.value));
        if (n) t = e.startState.values.slice();
        else {
            n = Configuration.resolve(o, h, this), t = new EditorState(n, this.doc, this.selection, n.dynamicSlots.map((() => null)), ((e, t) => t.reconfigure(e, this)), null).values
        }
        let p = e.startState.facet(k) ? e.newSelection : e.newSelection.asSingle();
        new EditorState(n, e.newDoc, p, t, ((t, n) => n.update(t, e)), e)
    }
    replaceSelection(e) {
        return "string" == typeof e && (e = this.toText(e)), this.changeByRange((t => ({
            changes: {
                from: t.from,
                to: t.to,
                insert: e
            },
            range: EditorSelection.cursor(t.from + e.length)
        })))
    }
    changeByRange(e) {
        let t = this.selection,
            n = e(t.ranges[0]),
            o = this.changes(n.changes),
            h = [n.range],
            p = asArray$1(n.effects);
        for (let n = 1; n < t.ranges.length; n++) {
            let f = e(t.ranges[n]),
                g = this.changes(f.changes),
                y = g.map(o);
            for (let e = 0; e < n; e++) h[e] = h[e].map(y);
            let w = o.mapDesc(g, !0);
            h.push(f.range.map(w)), o = o.compose(y), p = StateEffect.mapEffects(p, y).concat(StateEffect.mapEffects(asArray$1(f.effects), w))
        }
        return {
            changes: o,
            selection: EditorSelection.create(h, t.mainIndex),
            effects: p
        }
    }
    changes(e = []) {
        return e instanceof ChangeSet ? e : ChangeSet.of(e, this.doc.length, this.facet(EditorState.lineSeparator))
    }
    toText(e) {
        return Text.of(e.split(this.facet(EditorState.lineSeparator) || n))
    }
    sliceDoc(e = 0, t = this.doc.length) {
        return this.doc.sliceString(e, t, this.lineBreak)
    }
    facet(e) {
        let t = this.config.address[e.id];
        return null == t ? e.default : (ensureAddr(this, t), getAddr(this, t))
    }
    toJSON(e) {
        let t = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
        };
        if (e)
            for (let n in e) {
                let o = e[n];
                o instanceof StateField && null != this.config.address[o.id] && (t[n] = o.spec.toJSON(this.field(e[n]), this))
            }
        return t
    }
    static fromJSON(e, t = {}, n) {
        if (!e || "string" != typeof e.doc) throw new RangeError("Invalid JSON representation for EditorState");
        let o = [];
        if (n)
            for (let t in n)
                if (Object.prototype.hasOwnProperty.call(e, t)) {
                    let h = n[t],
                        p = e[t];
                    o.push(h.init((e => h.spec.fromJSON(p, e))))
                }
        return EditorState.create({
            doc: e.doc,
            selection: EditorSelection.fromJSON(e.selection),
            extensions: t.extensions ? o.concat([t.extensions]) : o
        })
    }
    static create(e = {}) {
        let t = Configuration.resolve(e.extensions || [], new Map),
            o = e.doc instanceof Text ? e.doc : Text.of((e.doc || "").split(t.staticFacet(EditorState.lineSeparator) || n)),
            h = e.selection ? e.selection instanceof EditorSelection ? e.selection : EditorSelection.single(e.selection.anchor, e.selection.head) : EditorSelection.single(0);
        return checkSelection(h, o.length), t.staticFacet(k) || (h = h.asSingle()), new EditorState(t, o, h, t.dynamicSlots.map((() => null)), ((e, t) => t.create(e)), null)
    }
    get tabSize() {
        return this.facet(EditorState.tabSize)
    }
    get lineBreak() {
        return this.facet(EditorState.lineSeparator) || "\n"
    }
    get readOnly() {
        return this.facet($)
    }
    phrase(e, ...t) {
        for (let t of this.facet(EditorState.phrases))
            if (Object.prototype.hasOwnProperty.call(t, e)) {
                e = t[e];
                break
            }
        return t.length && (e = e.replace(/\$(\$|\d*)/g, ((e, n) => {
            if ("$" == n) return "$";
            let o = +(n || 1);
            return !o || o > t.length ? e : t[o - 1]
        }))), e
    }
    languageDataAt(e, t, n = -1) {
        let o = [];
        for (let h of this.facet(S))
            for (let p of h(this, t, n)) Object.prototype.hasOwnProperty.call(p, e) && o.push(p[e]);
        return o
    }
    charCategorizer(e) {
        return makeCategorizer(this.languageDataAt("wordChars", e).join(""))
    }
    wordAt(e) {
        let {
            text: t,
            from: n,
            length: o
        } = this.doc.lineAt(e), h = this.charCategorizer(e), p = e - n, f = e - n;
        for (; p > 0;) {
            let e = findClusterBreak(t, p, !1);
            if (h(t.slice(e, p)) != R.Word) break;
            p = e
        }
        for (; f < o;) {
            let e = findClusterBreak(t, f);
            if (h(t.slice(f, e)) != R.Word) break;
            f = e
        }
        return p == f ? null : EditorSelection.range(p + n, f + n)
    }
}

function combineConfig(e, t, n = {}) {
    let o = {};
    for (let t of e)
        for (let e of Object.keys(t)) {
            let h = t[e],
                p = o[e];
            if (void 0 === p) o[e] = h;
            else if (p === h || void 0 === h);
            else {
                if (!Object.hasOwnProperty.call(n, e)) throw new Error("Config merge conflict for field " + e);
                o[e] = n[e](p, h)
            }
        }
    for (let e in t) void 0 === o[e] && (o[e] = t[e]);
    return o
}
EditorState.allowMultipleSelections = k, EditorState.tabSize = Facet.define({
    combine: e => e.length ? e[0] : 4
}), EditorState.lineSeparator = v, EditorState.readOnly = $, EditorState.phrases = Facet.define({
    compare(e, t) {
        let n = Object.keys(e),
            o = Object.keys(t);
        return n.length == o.length && n.every((n => e[n] == t[n]))
    }
}), EditorState.languageData = S, EditorState.changeFilter = P, EditorState.transactionFilter = C, EditorState.transactionExtender = Q, Compartment.reconfigure = StateEffect.define();
class RangeValue {
    eq(e) {
        return this == e
    }
    range(e, t = e) {
        return V.create(e, t, this)
    }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0, RangeValue.prototype.point = !1, RangeValue.prototype.mapMode = o.TrackDel;
let V = class Range {
    constructor(e, t, n) {
        this.from = e, this.to = t, this.value = n
    }
    static create(e, t, n) {
        return new Range(e, t, n)
    }
};

function cmpRange(e, t) {
    return e.from - t.from || e.value.startSide - t.value.startSide
}
class Chunk {
    constructor(e, t, n, o) {
        this.from = e, this.to = t, this.value = n, this.maxPoint = o
    }
    get length() {
        return this.to[this.to.length - 1]
    }
    findIndex(e, t, n, o = 0) {
        let h = n ? this.to : this.from;
        for (let p = o, f = h.length;;) {
            if (p == f) return p;
            let o = p + f >> 1,
                g = h[o] - e || (n ? this.value[o].endSide : this.value[o].startSide) - t;
            if (o == p) return g >= 0 ? p : f;
            g >= 0 ? f = o : p = o + 1
        }
    }
    between(e, t, n, o) {
        for (let h = this.findIndex(t, -1e9, !0), p = this.findIndex(n, 1e9, !1, h); h < p; h++)
            if (!1 === o(this.from[h] + e, this.to[h] + e, this.value[h])) return !1
    }
    map(e, t) {
        let n = [],
            o = [],
            h = [],
            p = -1,
            f = -1;
        for (let g = 0; g < this.value.length; g++) {
            let y, w, b = this.value[g],
                S = this.from[g] + e,
                k = this.to[g] + e;
            if (S == k) {
                let e = t.mapPos(S, b.startSide, b.mapMode);
                if (null == e) continue;
                if (y = w = e, b.startSide != b.endSide && (w = t.mapPos(S, b.endSide), w < y)) continue
            } else if (y = t.mapPos(S, b.startSide), w = t.mapPos(k, b.endSide), y > w || y == w && b.startSide > 0 && b.endSide <= 0) continue;
            (w - y || b.endSide - b.startSide) < 0 || (p < 0 && (p = y), b.point && (f = Math.max(f, w - y)), n.push(b), o.push(y - p), h.push(w - p))
        }
        return {
            mapped: n.length ? new Chunk(o, h, n, f) : null,
            pos: p
        }
    }
}
class RangeSet {
    constructor(e, t, n, o) {
        this.chunkPos = e, this.chunk = t, this.nextLayer = n, this.maxPoint = o
    }
    static create(e, t, n, o) {
        return new RangeSet(e, t, n, o)
    }
    get length() {
        let e = this.chunk.length - 1;
        return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length)
    }
    get size() {
        if (this.isEmpty) return 0;
        let e = this.nextLayer.size;
        for (let t of this.chunk) e += t.value.length;
        return e
    }
    chunkEnd(e) {
        return this.chunkPos[e] + this.chunk[e].length
    }
    update(e) {
        let {
            add: t = [],
            sort: n = !1,
            filterFrom: o = 0,
            filterTo: h = this.length
        } = e, p = e.filter;
        if (0 == t.length && !p) return this;
        if (n && (t = t.slice().sort(cmpRange)), this.isEmpty) return t.length ? RangeSet.of(t) : this;
        let f = new LayerCursor(this, null, -1).goto(0),
            g = 0,
            y = [],
            w = new RangeSetBuilder;
        for (; f.value || g < t.length;)
            if (g < t.length && (f.from - t[g].from || f.startSide - t[g].value.startSide) >= 0) {
                let e = t[g++];
                w.addInner(e.from, e.to, e.value) || y.push(e)
            } else 1 == f.rangeIndex && f.chunkIndex < this.chunk.length && (g == t.length || this.chunkEnd(f.chunkIndex) < t[g].from) && (!p || o > this.chunkEnd(f.chunkIndex) || h < this.chunkPos[f.chunkIndex]) && w.addChunk(this.chunkPos[f.chunkIndex], this.chunk[f.chunkIndex]) ? f.nextChunk() : ((!p || o > f.to || h < f.from || p(f.from, f.to, f.value)) && (w.addInner(f.from, f.to, f.value) || y.push(V.create(f.from, f.to, f.value))), f.next());
        return w.finishInner(this.nextLayer.isEmpty && !y.length ? RangeSet.empty : this.nextLayer.update({
            add: y,
            filter: p,
            filterFrom: o,
            filterTo: h
        }))
    }
    map(e) {
        if (e.empty || this.isEmpty) return this;
        let t = [],
            n = [],
            o = -1;
        for (let h = 0; h < this.chunk.length; h++) {
            let p = this.chunkPos[h],
                f = this.chunk[h],
                g = e.touchesRange(p, p + f.length);
            if (!1 === g) o = Math.max(o, f.maxPoint), t.push(f), n.push(e.mapPos(p));
            else if (!0 === g) {
                let {
                    mapped: h,
                    pos: g
                } = f.map(p, e);
                h && (o = Math.max(o, h.maxPoint), t.push(h), n.push(g))
            }
        }
        let h = this.nextLayer.map(e);
        return 0 == t.length ? h : new RangeSet(n, t, h || RangeSet.empty, o)
    }
    between(e, t, n) {
        if (!this.isEmpty) {
            for (let o = 0; o < this.chunk.length; o++) {
                let h = this.chunkPos[o],
                    p = this.chunk[o];
                if (t >= h && e <= h + p.length && !1 === p.between(h, e - h, t - h, n)) return
            }
            this.nextLayer.between(e, t, n)
        }
    }
    iter(e = 0) {
        return HeapCursor.from([this]).goto(e)
    }
    get isEmpty() {
        return this.nextLayer == this
    }
    static iter(e, t = 0) {
        return HeapCursor.from(e).goto(t)
    }
    static compare(e, t, n, o, h = -1) {
        let p = e.filter((e => e.maxPoint > 0 || !e.isEmpty && e.maxPoint >= h)),
            f = t.filter((e => e.maxPoint > 0 || !e.isEmpty && e.maxPoint >= h)),
            g = findSharedChunks(p, f, n),
            y = new SpanCursor(p, g, h),
            w = new SpanCursor(f, g, h);
        n.iterGaps(((e, t, n) => compare(y, e, w, t, n, o))), n.empty && 0 == n.length && compare(y, 0, w, 0, 0, o)
    }
    static eq(e, t, n = 0, o) {
        null == o && (o = 999999999);
        let h = e.filter((e => !e.isEmpty && t.indexOf(e) < 0)),
            p = t.filter((t => !t.isEmpty && e.indexOf(t) < 0));
        if (h.length != p.length) return !1;
        if (!h.length) return !0;
        let f = findSharedChunks(h, p),
            g = new SpanCursor(h, f, 0).goto(n),
            y = new SpanCursor(p, f, 0).goto(n);
        for (;;) {
            if (g.to != y.to || !sameValues(g.active, y.active) || g.point && (!y.point || !g.point.eq(y.point))) return !1;
            if (g.to > o) return !0;
            g.next(), y.next()
        }
    }
    static spans(e, t, n, o, h = -1) {
        let p = new SpanCursor(e, null, h).goto(t),
            f = t,
            g = p.openStart;
        for (;;) {
            let e = Math.min(p.to, n);
            if (p.point) {
                let n = p.activeForPoint(p.to),
                    h = p.pointFrom < t ? n.length + 1 : p.point.startSide < 0 ? n.length : Math.min(n.length, g);
                o.point(f, e, p.point, n, h, p.pointRank), g = Math.min(p.openEnd(e), n.length)
            } else e > f && (o.span(f, e, p.active, g), g = p.openEnd(e));
            if (p.to > n) return g + (p.point && p.to > n ? 1 : 0);
            f = p.to, p.next()
        }
    }
    static of (e, t = !1) {
        let n = new RangeSetBuilder;
        for (let o of e instanceof V ? [e] : t ? function(e) {
                if (e.length > 1)
                    for (let t = e[0], n = 1; n < e.length; n++) {
                        let o = e[n];
                        if (cmpRange(t, o) > 0) return e.slice().sort(cmpRange);
                        t = o
                    }
                return e
            }(e) : e) n.add(o.from, o.to, o.value);
        return n.finish()
    }
    static join(e) {
        if (!e.length) return RangeSet.empty;
        let t = e[e.length - 1];
        for (let n = e.length - 2; n >= 0; n--)
            for (let o = e[n]; o != RangeSet.empty; o = o.nextLayer) t = new RangeSet(o.chunkPos, o.chunk, t, Math.max(o.maxPoint, t.maxPoint));
        return t
    }
}
RangeSet.empty = new RangeSet([], [], null, -1), RangeSet.empty.nextLayer = RangeSet.empty;
class RangeSetBuilder {
    finishChunk(e) {
        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = [])
    }
    constructor() {
        this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null
    }
    add(e, t, n) {
        this.addInner(e, t, n) || (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(e, t, n)
    }
    addInner(e, t, n) {
        let o = e - this.lastTo || n.startSide - this.last.endSide;
        if (o <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        return !(o < 0) && (250 == this.from.length && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = n, this.lastFrom = e, this.lastTo = t, this.value.push(n), n.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0)
    }
    addChunk(e, t) {
        if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0) return !1;
        this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
        let n = t.value.length - 1;
        return this.last = t.value[n], this.lastFrom = t.from[n] + e, this.lastTo = t.to[n] + e, !0
    }
    finish() {
        return this.finishInner(RangeSet.empty)
    }
    finishInner(e) {
        if (this.from.length && this.finishChunk(!1), 0 == this.chunks.length) return e;
        let t = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
        return this.from = null, t
    }
}

function findSharedChunks(e, t, n) {
    let o = new Map;
    for (let t of e)
        for (let e = 0; e < t.chunk.length; e++) t.chunk[e].maxPoint <= 0 && o.set(t.chunk[e], t.chunkPos[e]);
    let h = new Set;
    for (let e of t)
        for (let t = 0; t < e.chunk.length; t++) {
            let p = o.get(e.chunk[t]);
            null == p || (n ? n.mapPos(p) : p) != e.chunkPos[t] || (null == n ? void 0 : n.touchesRange(p, p + e.chunk[t].length)) || h.add(e.chunk[t])
        }
    return h
}
class LayerCursor {
    constructor(e, t, n, o = 0) {
        this.layer = e, this.skip = t, this.minPoint = n, this.rank = o
    }
    get startSide() {
        return this.value ? this.value.startSide : 0
    }
    get endSide() {
        return this.value ? this.value.endSide : 0
    }
    goto(e, t = -1e9) {
        return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this
    }
    gotoInner(e, t, n) {
        for (; this.chunkIndex < this.layer.chunk.length;) {
            let t = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(t) || this.layer.chunkEnd(this.chunkIndex) < e || t.maxPoint < this.minPoint)) break;
            this.chunkIndex++, n = !1
        }
        if (this.chunkIndex < this.layer.chunk.length) {
            let o = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
            (!n || this.rangeIndex < o) && this.setRangeIndex(o)
        }
        this.next()
    }
    forward(e, t) {
        (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0)
    }
    next() {
        for (;;) {
            if (this.chunkIndex == this.layer.chunk.length) {
                this.from = this.to = 1e9, this.value = null;
                break
            } {
                let e = this.layer.chunkPos[this.chunkIndex],
                    t = this.layer.chunk[this.chunkIndex],
                    n = e + t.from[this.rangeIndex];
                if (this.from = n, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break
            }
        }
    }
    setRangeIndex(e) {
        if (e == this.layer.chunk[this.chunkIndex].value.length) {
            if (this.chunkIndex++, this.skip)
                for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]);) this.chunkIndex++;
            this.rangeIndex = 0
        } else this.rangeIndex = e
    }
    nextChunk() {
        this.chunkIndex++, this.rangeIndex = 0, this.next()
    }
    compare(e) {
        return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide
    }
}
class HeapCursor {
    constructor(e) {
        this.heap = e
    }
    static from(e, t = null, n = -1) {
        let o = [];
        for (let h = 0; h < e.length; h++)
            for (let p = e[h]; !p.isEmpty; p = p.nextLayer) p.maxPoint >= n && o.push(new LayerCursor(p, t, n, h));
        return 1 == o.length ? o[0] : new HeapCursor(o)
    }
    get startSide() {
        return this.value ? this.value.startSide : 0
    }
    goto(e, t = -1e9) {
        for (let n of this.heap) n.goto(e, t);
        for (let e = this.heap.length >> 1; e >= 0; e--) heapBubble(this.heap, e);
        return this.next(), this
    }
    forward(e, t) {
        for (let n of this.heap) n.forward(e, t);
        for (let e = this.heap.length >> 1; e >= 0; e--) heapBubble(this.heap, e);
        (this.to - e || this.value.endSide - t) < 0 && this.next()
    }
    next() {
        if (0 == this.heap.length) this.from = this.to = 1e9, this.value = null, this.rank = -1;
        else {
            let e = this.heap[0];
            this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), heapBubble(this.heap, 0)
        }
    }
}

function heapBubble(e, t) {
    for (let n = e[t];;) {
        let o = 1 + (t << 1);
        if (o >= e.length) break;
        let h = e[o];
        if (o + 1 < e.length && h.compare(e[o + 1]) >= 0 && (h = e[o + 1], o++), n.compare(h) < 0) break;
        e[o] = n, e[t] = h, t = o
    }
}
class SpanCursor {
    constructor(e, t, n) {
        this.minPoint = n, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = HeapCursor.from(e, t, n)
    }
    goto(e, t = -1e9) {
        return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this
    }
    forward(e, t) {
        for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0;) this.removeActive(this.minActive);
        this.cursor.forward(e, t)
    }
    removeActive(e) {
        remove(this.active, e), remove(this.activeTo, e), remove(this.activeRank, e), this.minActive = findMinIndex(this.active, this.activeTo)
    }
    addActive(e) {
        let t = 0,
            {
                value: n,
                to: o,
                rank: h
            } = this.cursor;
        for (; t < this.activeRank.length && (h - this.activeRank[t] || o - this.activeTo[t]) > 0;) t++;
        insert(this.active, t, n), insert(this.activeTo, t, o), insert(this.activeRank, t, h), e && insert(e, t, this.cursor.from), this.minActive = findMinIndex(this.active, this.activeTo)
    }
    next() {
        let e = this.to,
            t = this.point;
        this.point = null;
        let n = this.openStart < 0 ? [] : null;
        for (;;) {
            let o = this.minActive;
            if (o > -1 && (this.activeTo[o] - this.cursor.from || this.active[o].endSide - this.cursor.startSide) < 0) {
                if (this.activeTo[o] > e) {
                    this.to = this.activeTo[o], this.endSide = this.active[o].endSide;
                    break
                }
                this.removeActive(o), n && remove(n, o)
            } else {
                if (!this.cursor.value) {
                    this.to = this.endSide = 1e9;
                    break
                }
                if (this.cursor.from > e) {
                    this.to = this.cursor.from, this.endSide = this.cursor.startSide;
                    break
                } {
                    let e = this.cursor.value;
                    if (e.point) {
                        if (!(t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)) {
                            this.point = e, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = e.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
                            break
                        }
                        this.cursor.next()
                    } else this.addActive(n), this.cursor.next()
                }
            }
        }
        if (n) {
            this.openStart = 0;
            for (let t = n.length - 1; t >= 0 && n[t] < e; t--) this.openStart++
        }
    }
    activeForPoint(e) {
        if (!this.active.length) return this.active;
        let t = [];
        for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)(this.activeTo[n] > e || this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide) && t.push(this.active[n]);
        return t.reverse()
    }
    openEnd(e) {
        let t = 0;
        for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--) t++;
        return t
    }
}

function compare(e, t, n, o, h, p) {
    e.goto(t), n.goto(o);
    let f = o + h,
        g = o,
        y = o - t;
    for (;;) {
        let t = e.to + y - n.to || e.endSide - n.endSide,
            o = t < 0 ? e.to + y : n.to,
            h = Math.min(o, f);
        if (e.point || n.point ? e.point && n.point && (e.point == n.point || e.point.eq(n.point)) && sameValues(e.activeForPoint(e.to), n.activeForPoint(n.to)) || p.comparePoint(g, h, e.point, n.point) : h > g && !sameValues(e.active, n.active) && p.compareRange(g, h, e.active, n.active), o > f) break;
        g = o, t <= 0 && e.next(), t >= 0 && n.next()
    }
}

function sameValues(e, t) {
    if (e.length != t.length) return !1;
    for (let n = 0; n < e.length; n++)
        if (e[n] != t[n] && !e[n].eq(t[n])) return !1;
    return !0
}

function remove(e, t) {
    for (let n = t, o = e.length - 1; n < o; n++) e[n] = e[n + 1];
    e.pop()
}

function insert(e, t, n) {
    for (let n = e.length - 1; n >= t; n--) e[n + 1] = e[n];
    e[t] = n
}

function findMinIndex(e, t) {
    let n = -1,
        o = 1e9;
    for (let h = 0; h < t.length; h++)(t[h] - o || e[h].endSide - e[n].endSide) < 0 && (n = h, o = t[h]);
    return n
}

function countColumn(e, t, n = e.length) {
    let o = 0;
    for (let h = 0; h < n;) 9 == e.charCodeAt(h) ? (o += t - o % t, h++) : (o++, h = findClusterBreak(e, h));
    return o
}

function findColumn(e, t, n, o) {
    for (let o = 0, h = 0;;) {
        if (h >= t) return o;
        if (o == e.length) break;
        h += 9 == e.charCodeAt(o) ? n - h % n : 1, o = findClusterBreak(e, o)
    }
    return !0 === o ? -1 : e.length
}
var Z = Object.freeze({
    __proto__: null,
    Annotation: Annotation,
    AnnotationType: AnnotationType,
    ChangeDesc: ChangeDesc,
    ChangeSet: ChangeSet,
    get CharCategory() {
        return R
    },
    Compartment: Compartment,
    EditorSelection: EditorSelection,
    EditorState: EditorState,
    Facet: Facet,
    Line: e,
    get MapMode() {
        return o
    },
    Prec: b,
    Range: V,
    RangeSet: RangeSet,
    RangeSetBuilder: RangeSetBuilder,
    RangeValue: RangeValue,
    SelectionRange: SelectionRange,
    StateEffect: StateEffect,
    StateEffectType: StateEffectType,
    StateField: StateField,
    Text: Text,
    Transaction: A,
    codePointAt: codePointAt,
    codePointSize: codePointSize,
    combineConfig: combineConfig,
    countColumn: countColumn,
    findClusterBreak: findClusterBreak,
    findColumn: findColumn,
    fromCodePoint: fromCodePoint
});
const _ = "undefined" == typeof Symbol ? "__Í¼" : Symbol.for("Í¼"),
    B = "undefined" == typeof Symbol ? "__styleSet" + Math.floor(1e8 * Math.random()) : Symbol("styleSet"),
    I = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : {};
class StyleModule {
    constructor(e, t) {
        this.rules = [];
        let {
            finish: n
        } = t || {};

        function splitSelector(e) {
            return /^@/.test(e) ? [e] : e.split(/,\s*/)
        }

        function render(e, t, o, h) {
            let p = [],
                f = /^@(\w+)\b/.exec(e[0]),
                g = f && "keyframes" == f[1];
            if (f && null == t) return o.push(e[0] + ";");
            for (let n in t) {
                let h = t[n];
                if (/&/.test(n)) render(n.split(/,\s*/).map((t => e.map((e => t.replace(/&/, e))))).reduce(((e, t) => e.concat(t))), h, o);
                else if (h && "object" == typeof h) {
                    if (!f) throw new RangeError("The value of a property (" + n + ") should be a primitive value.");
                    render(splitSelector(n), h, p, g)
                } else null != h && p.push(n.replace(/_.*/, "").replace(/[A-Z]/g, (e => "-" + e.toLowerCase())) + ": " + h + ";")
            }(p.length || g) && o.push((!n || f || h ? e : e.map(n)).join(", ") + " {" + p.join(" ") + "}")
        }
        for (let t in e) render(splitSelector(t), e[t], this.rules)
    }
    getRules() {
        return this.rules.join("\n")
    }
    static newName() {
        let e = I[_] || 1;
        return I[_] = e + 1, "Í¼" + e.toString(36)
    }
    static mount(e, t, n) {
        let o = e[B],
            h = n && n.nonce;
        o ? h && o.setNonce(h) : o = new StyleSet(e, h), o.mount(Array.isArray(t) ? t : [t], e)
    }
}
let X = new Map;
class StyleSet {
    constructor(e, t) {
        let n = e.ownerDocument || e,
            o = n.defaultView;
        if (!e.head && e.adoptedStyleSheets && o.CSSStyleSheet) {
            let t = X.get(n);
            if (t) return e[B] = t;
            this.sheet = new o.CSSStyleSheet, X.set(n, this)
        } else this.styleTag = n.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
        this.modules = [], e[B] = this
    }
    mount(e, t) {
        let n = this.sheet,
            o = 0,
            h = 0;
        for (let t = 0; t < e.length; t++) {
            let p = e[t],
                f = this.modules.indexOf(p);
            if (f < h && f > -1 && (this.modules.splice(f, 1), h--, f = -1), -1 == f) {
                if (this.modules.splice(h++, 0, p), n)
                    for (let e = 0; e < p.rules.length; e++) n.insertRule(p.rules[e], o++)
            } else {
                for (; h < f;) o += this.modules[h++].rules.length;
                o += p.rules.length, h++
            }
        }
        if (n) t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
        else {
            let e = "";
            for (let t = 0; t < this.modules.length; t++) e += this.modules[t].getRules() + "\n";
            this.styleTag.textContent = e;
            let n = t.head || t;
            this.styleTag.parentNode != n && n.insertBefore(this.styleTag, n.firstChild)
        }
    }
    setNonce(e) {
        this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e)
    }
}
for (var q = {
        8: "Backspace",
        9: "Tab",
        10: "Enter",
        12: "NumLock",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        44: "PrintScreen",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Meta",
        92: "Meta",
        106: "*",
        107: "+",
        108: ",",
        109: "-",
        110: ".",
        111: "/",
        144: "NumLock",
        145: "ScrollLock",
        160: "Shift",
        161: "Shift",
        162: "Control",
        163: "Control",
        164: "Alt",
        165: "Alt",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
    }, z = {
        48: ")",
        49: "!",
        50: "@",
        51: "#",
        52: "$",
        53: "%",
        54: "^",
        55: "&",
        56: "*",
        57: "(",
        59: ":",
        61: "+",
        173: "_",
        186: ":",
        187: "+",
        188: "<",
        189: "_",
        190: ">",
        191: "?",
        192: "~",
        219: "{",
        220: "|",
        221: "}",
        222: '"'
    }, N = "undefined" != typeof navigator && /Mac/.test(navigator.platform), Y = "undefined" != typeof navigator && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), j = 0; j < 10; j++) q[48 + j] = q[96 + j] = String(j);
for (j = 1; j <= 24; j++) q[j + 111] = "F" + j;
for (j = 65; j <= 90; j++) q[j] = String.fromCharCode(j + 32), z[j] = String.fromCharCode(j);
for (var W in q) z.hasOwnProperty(W) || (z[W] = q[W]);

function getSelection(e) {
    let t;
    return t = 11 == e.nodeType ? e.getSelection ? e : e.ownerDocument : e, t.getSelection()
}

function contains(e, t) {
    return !!t && (e == t || e.contains(1 != t.nodeType ? t.parentNode : t))
}

function hasSelection(e, t) {
    if (!t.anchorNode) return !1;
    try {
        return contains(e, t.anchorNode)
    } catch (e) {
        return !1
    }
}

function clientRectsFor(e) {
    return 3 == e.nodeType ? textRange(e, 0, e.nodeValue.length).getClientRects() : 1 == e.nodeType ? e.getClientRects() : []
}

function isEquivalentPosition(e, t, n, o) {
    return !!n && (scanFor(e, t, n, o, -1) || scanFor(e, t, n, o, 1))
}

function domIndex(e) {
    for (var t = 0;; t++)
        if (!(e = e.previousSibling)) return t
}

function isBlockElement(e) {
    return 1 == e.nodeType && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(e.nodeName)
}

function scanFor(e, t, n, o, h) {
    for (;;) {
        if (e == n && t == o) return !0;
        if (t == (h < 0 ? 0 : maxOffset(e))) {
            if ("DIV" == e.nodeName) return !1;
            let n = e.parentNode;
            if (!n || 1 != n.nodeType) return !1;
            t = domIndex(e) + (h < 0 ? 0 : 1), e = n
        } else {
            if (1 != e.nodeType) return !1;
            if (1 == (e = e.childNodes[t + (h < 0 ? -1 : 0)]).nodeType && "false" == e.contentEditable) return !1;
            t = h < 0 ? maxOffset(e) : 0
        }
    }
}

function maxOffset(e) {
    return 3 == e.nodeType ? e.nodeValue.length : e.childNodes.length
}

function flattenRect(e, t) {
    let n = t ? e.left : e.right;
    return {
        left: n,
        right: n,
        top: e.top,
        bottom: e.bottom
    }
}

function windowRect(e) {
    let t = e.visualViewport;
    return t ? {
        left: 0,
        right: t.width,
        top: 0,
        bottom: t.height
    } : {
        left: 0,
        right: e.innerWidth,
        top: 0,
        bottom: e.innerHeight
    }
}

function getScale(e, t) {
    let n = t.width / e.offsetWidth,
        o = t.height / e.offsetHeight;
    return (n > .995 && n < 1.005 || !isFinite(n) || Math.abs(t.width - e.offsetWidth) < 1) && (n = 1), (o > .995 && o < 1.005 || !isFinite(o) || Math.abs(t.height - e.offsetHeight) < 1) && (o = 1), {
        scaleX: n,
        scaleY: o
    }
}
class DOMSelectionState {
    constructor() {
        this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0
    }
    eq(e) {
        return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset
    }
    setRange(e) {
        let {
            anchorNode: t,
            focusNode: n
        } = e;
        this.set(t, Math.min(e.anchorOffset, t ? maxOffset(t) : 0), n, Math.min(e.focusOffset, n ? maxOffset(n) : 0))
    }
    set(e, t, n, o) {
        this.anchorNode = e, this.anchorOffset = t, this.focusNode = n, this.focusOffset = o
    }
}
let G, H = null;

function focusPreventScroll(e) {
    if (e.setActive) return e.setActive();
    if (H) return e.focus(H);
    let t = [];
    for (let n = e; n && (t.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode);
    if (e.focus(null == H ? {
            get preventScroll() {
                return H = {
                    preventScroll: !0
                }, !0
            }
        } : void 0), !H) {
        H = !1;
        for (let e = 0; e < t.length;) {
            let n = t[e++],
                o = t[e++],
                h = t[e++];
            n.scrollTop != o && (n.scrollTop = o), n.scrollLeft != h && (n.scrollLeft = h)
        }
    }
}

function textRange(e, t, n = t) {
    let o = G || (G = document.createRange());
    return o.setEnd(e, n), o.setStart(e, t), o
}

function dispatchKey(e, t, n, o) {
    let h = {
        key: t,
        code: t,
        keyCode: n,
        which: n,
        cancelable: !0
    };
    o && ({
        altKey: h.altKey,
        ctrlKey: h.ctrlKey,
        shiftKey: h.shiftKey,
        metaKey: h.metaKey
    } = o);
    let p = new KeyboardEvent("keydown", h);
    p.synthetic = !0, e.dispatchEvent(p);
    let f = new KeyboardEvent("keyup", h);
    return f.synthetic = !0, e.dispatchEvent(f), p.defaultPrevented || f.defaultPrevented
}

function clearAttributes(e) {
    for (; e.attributes.length;) e.removeAttributeNode(e.attributes[0])
}

function isScrolledToBottom(e) {
    return e.scrollTop > Math.max(1, e.scrollHeight - e.clientHeight - 4)
}

function textNodeBefore(e, t) {
    for (let n = e, o = t;;) {
        if (3 == n.nodeType && o > 0) return {
            node: n,
            offset: o
        };
        if (1 == n.nodeType && o > 0) {
            if ("false" == n.contentEditable) return null;
            n = n.childNodes[o - 1], o = maxOffset(n)
        } else {
            if (!n.parentNode || isBlockElement(n)) return null;
            o = domIndex(n), n = n.parentNode
        }
    }
}

function textNodeAfter(e, t) {
    for (let n = e, o = t;;) {
        if (3 == n.nodeType && o < n.nodeValue.length) return {
            node: n,
            offset: o
        };
        if (1 == n.nodeType && o < n.childNodes.length) {
            if ("false" == n.contentEditable) return null;
            n = n.childNodes[o], o = 0
        } else {
            if (!n.parentNode || isBlockElement(n)) return null;
            o = domIndex(n) + 1, n = n.parentNode
        }
    }
}
class DOMPos {
    constructor(e, t, n = !0) {
        this.node = e, this.offset = t, this.precise = n
    }
    static before(e, t) {
        return new DOMPos(e.parentNode, domIndex(e), t)
    }
    static after(e, t) {
        return new DOMPos(e.parentNode, domIndex(e) + 1, t)
    }
}
const K = [];
class ContentView {
    constructor() {
        this.parent = null, this.dom = null, this.flags = 2
    }
    get overrideDOMText() {
        return null
    }
    get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0
    }
    get posAtEnd() {
        return this.posAtStart + this.length
    }
    posBefore(e) {
        let t = this.posAtStart;
        for (let n of this.children) {
            if (n == e) return t;
            t += n.length + n.breakAfter
        }
        throw new RangeError("Invalid child in posBefore")
    }
    posAfter(e) {
        return this.posBefore(e) + e.length
    }
    sync(e, t) {
        if (2 & this.flags) {
            let n, o = this.dom,
                h = null;
            for (let p of this.children) {
                if (7 & p.flags) {
                    if (!p.dom && (n = h ? h.nextSibling : o.firstChild)) {
                        let e = ContentView.get(n);
                        (!e || !e.parent && e.canReuseDOM(p)) && p.reuseDOM(n)
                    }
                    p.sync(e, t), p.flags &= -8
                }
                if (n = h ? h.nextSibling : o.firstChild, t && !t.written && t.node == o && n != p.dom && (t.written = !0), p.dom.parentNode == o)
                    for (; n && n != p.dom;) n = rm$1(n);
                else o.insertBefore(p.dom, n);
                h = p.dom
            }
            for (n = h ? h.nextSibling : o.firstChild, n && t && t.node == o && (t.written = !0); n;) n = rm$1(n)
        } else if (1 & this.flags)
            for (let n of this.children) 7 & n.flags && (n.sync(e, t), n.flags &= -8)
    }
    reuseDOM(e) {}
    localPosFromDOM(e, t) {
        let n;
        if (e == this.dom) n = this.dom.childNodes[t];
        else {
            let o = 0 == maxOffset(e) ? 0 : 0 == t ? -1 : 1;
            for (;;) {
                let t = e.parentNode;
                if (t == this.dom) break;
                0 == o && t.firstChild != t.lastChild && (o = e == t.firstChild ? -1 : 1), e = t
            }
            n = o < 0 ? e : e.nextSibling
        }
        if (n == this.dom.firstChild) return 0;
        for (; n && !ContentView.get(n);) n = n.nextSibling;
        if (!n) return this.length;
        for (let e = 0, t = 0;; e++) {
            let o = this.children[e];
            if (o.dom == n) return t;
            t += o.length + o.breakAfter
        }
    }
    domBoundsAround(e, t, n = 0) {
        let o = -1,
            h = -1,
            p = -1,
            f = -1;
        for (let g = 0, y = n, w = n; g < this.children.length; g++) {
            let n = this.children[g],
                b = y + n.length;
            if (y < e && b > t) return n.domBoundsAround(e, t, y);
            if (b >= e && -1 == o && (o = g, h = y), y > t && n.dom.parentNode == this.dom) {
                p = g, f = w;
                break
            }
            w = b, y = b + n.breakAfter
        }
        return {
            from: h,
            to: f < 0 ? n + this.length : f,
            startDOM: (o ? this.children[o - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: p < this.children.length && p >= 0 ? this.children[p].dom : null
        }
    }
    markDirty(e = !1) {
        this.flags |= 2, this.markParentsDirty(e)
    }
    markParentsDirty(e) {
        for (let t = this.parent; t; t = t.parent) {
            if (e && (t.flags |= 2), 1 & t.flags) return;
            t.flags |= 1, e = !1
        }
    }
    setParent(e) {
        this.parent != e && (this.parent = e, 7 & this.flags && this.markParentsDirty(!0))
    }
    setDOM(e) {
        this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this)
    }
    get rootView() {
        for (let e = this;;) {
            let t = e.parent;
            if (!t) return e;
            e = t
        }
    }
    replaceChildren(e, t, n = K) {
        this.markDirty();
        for (let o = e; o < t; o++) {
            let e = this.children[o];
            e.parent == this && n.indexOf(e) < 0 && e.destroy()
        }
        n.length < 250 ? this.children.splice(e, t - e, ...n) : this.children = [].concat(this.children.slice(0, e), n, this.children.slice(t));
        for (let e = 0; e < n.length; e++) n[e].setParent(this)
    }
    ignoreMutation(e) {
        return !1
    }
    ignoreEvent(e) {
        return !1
    }
    childCursor(e = this.length) {
        return new ChildCursor(this.children, e, this.children.length)
    }
    childPos(e, t = 1) {
        return this.childCursor().findPos(e, t)
    }
    toString() {
        let e = this.constructor.name.replace("View", "");
        return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + ("Text" == e ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "")
    }
    static get(e) {
        return e.cmView
    }
    get isEditable() {
        return !0
    }
    get isWidget() {
        return !1
    }
    get isHidden() {
        return !1
    }
    merge(e, t, n, o, h, p) {
        return !1
    }
    become(e) {
        return !1
    }
    canReuseDOM(e) {
        return e.constructor == this.constructor && !(8 & (this.flags | e.flags))
    }
    getSide() {
        return 0
    }
    destroy() {
        for (let e of this.children) e.parent == this && e.destroy();
        this.parent = null
    }
}

function rm$1(e) {
    let t = e.nextSibling;
    return e.parentNode.removeChild(e), t
}
ContentView.prototype.breakAfter = 0;
class ChildCursor {
    constructor(e, t, n) {
        this.children = e, this.pos = t, this.i = n, this.off = 0
    }
    findPos(e, t = 1) {
        for (;;) {
            if (e > this.pos || e == this.pos && (t > 0 || 0 == this.i || this.children[this.i - 1].breakAfter)) return this.off = e - this.pos, this;
            let n = this.children[--this.i];
            this.pos -= n.length + n.breakAfter
        }
    }
}

function replaceRange(e, t, n, o, h, p, f, g, y) {
    let {
        children: w
    } = e, b = w.length ? w[t] : null, S = p.length ? p[p.length - 1] : null, k = S ? S.breakAfter : f;
    if (!(t == o && b && !f && !k && p.length < 2 && b.merge(n, h, p.length ? S : null, 0 == n, g, y))) {
        if (o < w.length) {
            let e = w[o];
            e && (h < e.length || e.breakAfter && (null == S ? void 0 : S.breakAfter)) ? (t == o && (e = e.split(h), h = 0), !k && S && e.merge(0, h, S, !0, 0, y) ? p[p.length - 1] = e : ((h || e.children.length && !e.children[0].length) && e.merge(0, h, null, !1, 0, y), p.push(e))) : (null == e ? void 0 : e.breakAfter) && (S ? S.breakAfter = 1 : f = 1), o++
        }
        for (b && (b.breakAfter = f, n > 0 && (!f && p.length && b.merge(n, b.length, p[0], !1, g, 0) ? b.breakAfter = p.shift().breakAfter : (n < b.length || b.children.length && 0 == b.children[b.children.length - 1].length) && b.merge(n, b.length, null, !1, g, 0), t++)); t < o && p.length;)
            if (w[o - 1].become(p[p.length - 1])) o--, p.pop(), y = p.length ? 0 : g;
            else {
                if (!w[t].become(p[0])) break;
                t++, p.shift(), g = p.length ? 0 : y
            }!p.length && t && o < w.length && !w[t - 1].breakAfter && w[o].merge(0, 0, w[t - 1], !1, g, y) && t--, (t < o || p.length) && e.replaceChildren(t, o, p)
    }
}

function mergeChildrenInto(e, t, n, o, h, p) {
    let f = e.childCursor(),
        {
            i: g,
            off: y
        } = f.findPos(n, 1),
        {
            i: w,
            off: b
        } = f.findPos(t, -1),
        S = t - n;
    for (let e of o) S += e.length;
    e.length += S, replaceRange(e, w, b, g, y, o, 0, h, p)
}
let J = "undefined" != typeof navigator ? navigator : {
        userAgent: "",
        vendor: "",
        platform: ""
    },
    ee = "undefined" != typeof document ? document : {
        documentElement: {
            style: {}
        }
    };
const te = /Edge\/(\d+)/.exec(J.userAgent),
    ne = /MSIE \d/.test(J.userAgent),
    ie = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(J.userAgent),
    re = !!(ne || ie || te),
    oe = !re && /gecko\/(\d+)/i.test(J.userAgent),
    se = !re && /Chrome\/(\d+)/.exec(J.userAgent),
    ae = "webkitFontSmoothing" in ee.documentElement.style,
    le = !re && /Apple Computer/.test(J.vendor),
    ce = le && (/Mobile\/\w+/.test(J.userAgent) || J.maxTouchPoints > 2);
var he = {
    mac: ce || /Mac/.test(J.platform),
    windows: /Win/.test(J.platform),
    linux: /Linux|X11/.test(J.platform),
    ie: re,
    ie_version: ne ? ee.documentMode || 6 : ie ? +ie[1] : te ? +te[1] : 0,
    gecko: oe,
    gecko_version: oe ? +(/Firefox\/(\d+)/.exec(J.userAgent) || [0, 0])[1] : 0,
    chrome: !!se,
    chrome_version: se ? +se[1] : 0,
    ios: ce,
    android: /Android\b/.test(J.userAgent),
    safari: le,
    webkit_version: ae ? +(/\bAppleWebKit\/(\d+)/.exec(J.userAgent) || [0, 0])[1] : 0,
    tabSize: null != ee.documentElement.style.tabSize ? "tab-size" : "-moz-tab-size"
};
class TextView extends ContentView {
    constructor(e) {
        super(), this.text = e
    }
    get length() {
        return this.text.length
    }
    createDOM(e) {
        this.setDOM(e || document.createTextNode(this.text))
    }
    sync(e, t) {
        this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text)
    }
    reuseDOM(e) {
        3 == e.nodeType && this.createDOM(e)
    }
    merge(e, t, n) {
        return !(8 & this.flags || n && (!(n instanceof TextView) || this.length - (t - e) + n.length > 256 || 8 & n.flags)) && (this.text = this.text.slice(0, e) + (n ? n.text : "") + this.text.slice(t), this.markDirty(), !0)
    }
    split(e) {
        let t = new TextView(this.text.slice(e));
        return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= 8 & this.flags, t
    }
    localPosFromDOM(e, t) {
        return e == this.dom ? t : t ? this.text.length : 0
    }
    domAtPos(e) {
        return new DOMPos(this.dom, e)
    }
    domBoundsAround(e, t, n) {
        return {
            from: n,
            to: n + this.length,
            startDOM: this.dom,
            endDOM: this.dom.nextSibling
        }
    }
    coordsAt(e, t) {
        return function(e, t, n) {
            let o = e.nodeValue.length;
            t > o && (t = o);
            let h = t,
                p = t,
                f = 0;
            0 == t && n < 0 || t == o && n >= 0 ? he.chrome || he.gecko || (t ? (h--, f = 1) : p < o && (p++, f = -1)) : n < 0 ? h-- : p < o && p++;
            let g = textRange(e, h, p).getClientRects();
            if (!g.length) return null;
            let y = g[(f ? f < 0 : n >= 0) ? 0 : g.length - 1];
            he.safari && !f && 0 == y.width && (y = Array.prototype.find.call(g, (e => e.width)) || y);
            return f ? flattenRect(y, f < 0) : y || null
        }(this.dom, e, t)
    }
}
class MarkView extends ContentView {
    constructor(e, t = [], n = 0) {
        super(), this.mark = e, this.children = t, this.length = n;
        for (let e of t) e.setParent(this)
    }
    setAttrs(e) {
        if (clearAttributes(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
            for (let t in this.mark.attrs) e.setAttribute(t, this.mark.attrs[t]);
        return e
    }
    canReuseDOM(e) {
        return super.canReuseDOM(e) && !(8 & (this.flags | e.flags))
    }
    reuseDOM(e) {
        e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6)
    }
    sync(e, t) {
        this.dom ? 4 & this.flags && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t)
    }
    merge(e, t, n, o, h, p) {
        return (!n || !(!(n instanceof MarkView && n.mark.eq(this.mark)) || e && h <= 0 || t < this.length && p <= 0)) && (mergeChildrenInto(this, e, t, n ? n.children.slice() : [], h - 1, p - 1), this.markDirty(), !0)
    }
    split(e) {
        let t = [],
            n = 0,
            o = -1,
            h = 0;
        for (let p of this.children) {
            let f = n + p.length;
            f > e && t.push(n < e ? p.split(e - n) : p), o < 0 && n >= e && (o = h), n = f, h++
        }
        let p = this.length - e;
        return this.length = e, o > -1 && (this.children.length = o, this.markDirty()), new MarkView(this.mark, t, p)
    }
    domAtPos(e) {
        return inlineDOMAtPos(this, e)
    }
    coordsAt(e, t) {
        return coordsInChildren(this, e, t)
    }
}
class WidgetView extends ContentView {
    static create(e, t, n) {
        return new WidgetView(e, t, n)
    }
    constructor(e, t, n) {
        super(), this.widget = e, this.length = t, this.side = n, this.prevWidget = null
    }
    split(e) {
        let t = WidgetView.create(this.widget, this.length - e, this.side);
        return this.length -= e, t
    }
    sync(e) {
        this.dom && this.widget.updateDOM(this.dom, e) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"))
    }
    getSide() {
        return this.side
    }
    merge(e, t, n, o, h, p) {
        return !(n && (!(n instanceof WidgetView && this.widget.compare(n.widget)) || e > 0 && h <= 0 || t < this.length && p <= 0)) && (this.length = e + (n ? n.length : 0) + (this.length - t), !0)
    }
    become(e) {
        return e instanceof WidgetView && e.side == this.side && this.widget.constructor == e.widget.constructor && (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0)
    }
    ignoreMutation() {
        return !0
    }
    ignoreEvent(e) {
        return this.widget.ignoreEvent(e)
    }
    get overrideDOMText() {
        if (0 == this.length) return Text.empty;
        let e = this;
        for (; e.parent;) e = e.parent;
        let {
            view: t
        } = e, n = t && t.state.doc, o = this.posAtStart;
        return n ? n.slice(o, o + this.length) : Text.empty
    }
    domAtPos(e) {
        return (this.length ? 0 == e : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, e == this.length)
    }
    domBoundsAround() {
        return null
    }
    coordsAt(e, t) {
        let n = this.widget.coordsAt(this.dom, e, t);
        if (n) return n;
        let o = this.dom.getClientRects(),
            h = null;
        if (!o.length) return null;
        let p = this.side ? this.side < 0 : e > 0;
        for (let t = p ? o.length - 1 : 0; h = o[t], !(e > 0 ? 0 == t : t == o.length - 1 || h.top < h.bottom); t += p ? -1 : 1);
        return flattenRect(h, !p)
    }
    get isEditable() {
        return !1
    }
    get isWidget() {
        return !0
    }
    get isHidden() {
        return this.widget.isHidden
    }
    destroy() {
        super.destroy(), this.dom && this.widget.destroy(this.dom)
    }
}
class WidgetBufferView extends ContentView {
    constructor(e) {
        super(), this.side = e
    }
    get length() {
        return 0
    }
    merge() {
        return !1
    }
    become(e) {
        return e instanceof WidgetBufferView && e.side == this.side
    }
    split() {
        return new WidgetBufferView(this.side)
    }
    sync() {
        if (!this.dom) {
            let e = document.createElement("img");
            e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e)
        }
    }
    getSide() {
        return this.side
    }
    domAtPos(e) {
        return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom)
    }
    localPosFromDOM() {
        return 0
    }
    domBoundsAround() {
        return null
    }
    coordsAt(e) {
        return this.dom.getBoundingClientRect()
    }
    get overrideDOMText() {
        return Text.empty
    }
    get isHidden() {
        return !0
    }
}

function inlineDOMAtPos(e, t) {
    let n = e.dom,
        {
            children: o
        } = e,
        h = 0;
    for (let e = 0; h < o.length; h++) {
        let p = o[h],
            f = e + p.length;
        if (!(f == e && p.getSide() <= 0)) {
            if (t > e && t < f && p.dom.parentNode == n) return p.domAtPos(t - e);
            if (t <= e) break;
            e = f
        }
    }
    for (let e = h; e > 0; e--) {
        let t = o[e - 1];
        if (t.dom.parentNode == n) return t.domAtPos(t.length)
    }
    for (let e = h; e < o.length; e++) {
        let t = o[e];
        if (t.dom.parentNode == n) return t.domAtPos(0)
    }
    return new DOMPos(n, 0)
}

function joinInlineInto(e, t, n) {
    let o, {
        children: h
    } = e;
    n > 0 && t instanceof MarkView && h.length && (o = h[h.length - 1]) instanceof MarkView && o.mark.eq(t.mark) ? joinInlineInto(o, t.children[0], n - 1) : (h.push(t), t.setParent(e)), e.length += t.length
}

function coordsInChildren(e, t, n) {
    let o = null,
        h = -1,
        p = null,
        f = -1;
    ! function scan(e, t) {
        for (let g = 0, y = 0; g < e.children.length && y <= t; g++) {
            let w = e.children[g],
                b = y + w.length;
            b >= t && (w.children.length ? scan(w, t - y) : (!p || p.isHidden && n > 0) && (b > t || y == b && w.getSide() > 0) ? (p = w, f = t - y) : (y < t || y == b && w.getSide() < 0 && !w.isHidden) && (o = w, h = t - y)), y = b
        }
    }(e, t);
    let g = (n < 0 ? o : p) || o || p;
    return g ? g.coordsAt(Math.max(0, g == o ? h : f), n) : function(e) {
        let t = e.dom.lastChild;
        if (!t) return e.dom.getBoundingClientRect();
        let n = clientRectsFor(t);
        return n[n.length - 1] || null
    }(e)
}

function combineAttrs(e, t) {
    for (let n in e) "class" == n && t.class ? t.class += " " + e.class : "style" == n && t.style ? t.style += ";" + e.style : t[n] = e[n];
    return t
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = K;
const de = Object.create(null);

function attrsEq(e, t, n) {
    if (e == t) return !0;
    e || (e = de), t || (t = de);
    let o = Object.keys(e),
        h = Object.keys(t);
    if (o.length - (n && o.indexOf(n) > -1 ? 1 : 0) != h.length - (n && h.indexOf(n) > -1 ? 1 : 0)) return !1;
    for (let p of o)
        if (p != n && (-1 == h.indexOf(p) || e[p] !== t[p])) return !1;
    return !0
}

function updateAttrs(e, t, n) {
    let o = !1;
    if (t)
        for (let h in t) n && h in n || (o = !0, "style" == h ? e.style.cssText = "" : e.removeAttribute(h));
    if (n)
        for (let h in n) t && t[h] == n[h] || (o = !0, "style" == h ? e.style.cssText = n[h] : e.setAttribute(h, n[h]));
    return o
}

function getAttrs$1(e) {
    let t = Object.create(null);
    for (let n = 0; n < e.attributes.length; n++) {
        let o = e.attributes[n];
        t[o.name] = o.value
    }
    return t
}
class WidgetType {
    eq(e) {
        return !1
    }
    updateDOM(e, t) {
        return !1
    }
    compare(e) {
        return this == e || this.constructor == e.constructor && this.eq(e)
    }
    get estimatedHeight() {
        return -1
    }
    get lineBreaks() {
        return 0
    }
    ignoreEvent(e) {
        return !0
    }
    coordsAt(e, t, n) {
        return null
    }
    get isHidden() {
        return !1
    }
    get editable() {
        return !1
    }
    destroy(e) {}
}
var ue = function(e) {
    return e[e.Text = 0] = "Text", e[e.WidgetBefore = 1] = "WidgetBefore", e[e.WidgetAfter = 2] = "WidgetAfter", e[e.WidgetRange = 3] = "WidgetRange", e
}(ue || (ue = {}));
class Decoration extends RangeValue {
    constructor(e, t, n, o) {
        super(), this.startSide = e, this.endSide = t, this.widget = n, this.spec = o
    }
    get heightRelevant() {
        return !1
    }
    static mark(e) {
        return new MarkDecoration(e)
    }
    static widget(e) {
        let t = Math.max(-1e4, Math.min(1e4, e.side || 0)),
            n = !!e.block;
        return t += n && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new PointDecoration(e, t, t, n, e.widget || null, !1)
    }
    static replace(e) {
        let t, n, o = !!e.block;
        if (e.isBlockGap) t = -5e8, n = 4e8;
        else {
            let {
                start: h,
                end: p
            } = getInclusive(e, o);
            t = (h ? o ? -3e8 : -1 : 5e8) - 1, n = 1 + (p ? o ? 2e8 : 1 : -6e8)
        }
        return new PointDecoration(e, t, n, o, e.widget || null, !0)
    }
    static line(e) {
        return new LineDecoration(e)
    }
    static set(e, t = !1) {
        return RangeSet.of(e, t)
    }
    hasHeight() {
        return !!this.widget && this.widget.estimatedHeight > -1
    }
}
Decoration.none = RangeSet.empty;
class MarkDecoration extends Decoration {
    constructor(e) {
        let {
            start: t,
            end: n
        } = getInclusive(e);
        super(t ? -1 : 5e8, n ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null
    }
    eq(e) {
        var t, n;
        return this == e || e instanceof MarkDecoration && this.tagName == e.tagName && (this.class || (null === (t = this.attrs) || void 0 === t ? void 0 : t.class)) == (e.class || (null === (n = e.attrs) || void 0 === n ? void 0 : n.class)) && attrsEq(this.attrs, e.attrs, "class")
    }
    range(e, t = e) {
        if (e >= t) throw new RangeError("Mark decorations may not be empty");
        return super.range(e, t)
    }
}
MarkDecoration.prototype.point = !1;
class LineDecoration extends Decoration {
    constructor(e) {
        super(-2e8, -2e8, null, e)
    }
    eq(e) {
        return e instanceof LineDecoration && this.spec.class == e.spec.class && attrsEq(this.spec.attributes, e.spec.attributes)
    }
    range(e, t = e) {
        if (t != e) throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(e, t)
    }
}
LineDecoration.prototype.mapMode = o.TrackBefore, LineDecoration.prototype.point = !0;
class PointDecoration extends Decoration {
    constructor(e, t, n, h, p, f) {
        super(t, n, p, e), this.block = h, this.isReplace = f, this.mapMode = h ? t <= 0 ? o.TrackBefore : o.TrackAfter : o.TrackDel
    }
    get type() {
        return this.startSide != this.endSide ? ue.WidgetRange : this.startSide <= 0 ? ue.WidgetBefore : ue.WidgetAfter
    }
    get heightRelevant() {
        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0)
    }
    eq(e) {
        return e instanceof PointDecoration && (t = this.widget, n = e.widget, t == n || !!(t && n && t.compare(n))) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
        var t, n
    }
    range(e, t = e) {
        if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0)) throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && t != e) throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(e, t)
    }
}

function getInclusive(e, t = !1) {
    let {
        inclusiveStart: n,
        inclusiveEnd: o
    } = e;
    return null == n && (n = e.inclusive), null == o && (o = e.inclusive), {
        start: null != n ? n : t,
        end: null != o ? o : t
    }
}

function addRange(e, t, n, o = 0) {
    let h = n.length - 1;
    h >= 0 && n[h] + o >= e ? n[h] = Math.max(n[h], t) : n.push(e, t)
}
PointDecoration.prototype.point = !0;
class LineView extends ContentView {
    constructor() {
        super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0
    }
    merge(e, t, n, o, h, p) {
        if (n) {
            if (!(n instanceof LineView)) return !1;
            this.dom || n.transferDOM(this)
        }
        return o && this.setDeco(n ? n.attrs : null), mergeChildrenInto(this, e, t, n ? n.children.slice() : [], h, p), !0
    }
    split(e) {
        let t = new LineView;
        if (t.breakAfter = this.breakAfter, 0 == this.length) return t;
        let {
            i: n,
            off: o
        } = this.childPos(e);
        o && (t.append(this.children[n].split(o), 0), this.children[n].merge(o, this.children[n].length, null, !1, 0, 0), n++);
        for (let e = n; e < this.children.length; e++) t.append(this.children[e], 0);
        for (; n > 0 && 0 == this.children[n - 1].length;) this.children[--n].destroy();
        return this.children.length = n, this.markDirty(), this.length = e, t
    }
    transferDOM(e) {
        this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = void 0 === this.prevAttrs ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null)
    }
    setDeco(e) {
        attrsEq(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e)
    }
    append(e, t) {
        joinInlineInto(this, e, t)
    }
    addLineDeco(e) {
        let t = e.spec.attributes,
            n = e.spec.class;
        t && (this.attrs = combineAttrs(t, this.attrs || {})), n && (this.attrs = combineAttrs({
            class: n
        }, this.attrs || {}))
    }
    domAtPos(e) {
        return inlineDOMAtPos(this, e)
    }
    reuseDOM(e) {
        "DIV" == e.nodeName && (this.setDOM(e), this.flags |= 6)
    }
    sync(e, t) {
        var n;
        this.dom ? 4 & this.flags && (clearAttributes(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), void 0 !== this.prevAttrs && (updateAttrs(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
        let o = this.dom.lastChild;
        for (; o && ContentView.get(o) instanceof MarkView;) o = o.lastChild;
        if (!(o && this.length && ("BR" == o.nodeName || 0 != (null === (n = ContentView.get(o)) || void 0 === n ? void 0 : n.isEditable) || he.ios && this.children.some((e => e instanceof TextView))))) {
            let e = document.createElement("BR");
            e.cmIgnore = !0, this.dom.appendChild(e)
        }
    }
    measureTextSize() {
        if (0 == this.children.length || this.length > 20) return null;
        let e, t = 0;
        for (let n of this.children) {
            if (!(n instanceof TextView) || /[^ -~]/.test(n.text)) return null;
            let o = clientRectsFor(n.dom);
            if (1 != o.length) return null;
            t += o[0].width, e = o[0].height
        }
        return t ? {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: t / this.length,
            textHeight: e
        } : null
    }
    coordsAt(e, t) {
        let n = coordsInChildren(this, e, t);
        if (!this.children.length && n && this.parent) {
            let {
                heightOracle: e
            } = this.parent.view.viewState, t = n.bottom - n.top;
            if (Math.abs(t - e.lineHeight) < 2 && e.textHeight < t) {
                let o = (t - e.textHeight) / 2;
                return {
                    top: n.top + o,
                    bottom: n.bottom - o,
                    left: n.left,
                    right: n.left
                }
            }
        }
        return n
    }
    become(e) {
        return e instanceof LineView && 0 == this.children.length && 0 == e.children.length && attrsEq(this.attrs, e.attrs) && this.breakAfter == e.breakAfter
    }
    covers() {
        return !0
    }
    static find(e, t) {
        for (let n = 0, o = 0; n < e.children.length; n++) {
            let h = e.children[n],
                p = o + h.length;
            if (p >= t) {
                if (h instanceof LineView) return h;
                if (p > t) break
            }
            o = p + h.breakAfter
        }
        return null
    }
}
class BlockWidgetView extends ContentView {
    constructor(e, t, n) {
        super(), this.widget = e, this.length = t, this.deco = n, this.breakAfter = 0, this.prevWidget = null
    }
    merge(e, t, n, o, h, p) {
        return !(n && (!(n instanceof BlockWidgetView && this.widget.compare(n.widget)) || e > 0 && h <= 0 || t < this.length && p <= 0)) && (this.length = e + (n ? n.length : 0) + (this.length - t), !0)
    }
    domAtPos(e) {
        return 0 == e ? DOMPos.before(this.dom) : DOMPos.after(this.dom, e == this.length)
    }
    split(e) {
        let t = this.length - e;
        this.length = e;
        let n = new BlockWidgetView(this.widget, t, this.deco);
        return n.breakAfter = this.breakAfter, n
    }
    get children() {
        return K
    }
    sync(e) {
        this.dom && this.widget.updateDOM(this.dom, e) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"))
    }
    get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty
    }
    domBoundsAround() {
        return null
    }
    become(e) {
        return e instanceof BlockWidgetView && e.widget.constructor == this.widget.constructor && (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0)
    }
    ignoreMutation() {
        return !0
    }
    ignoreEvent(e) {
        return this.widget.ignoreEvent(e)
    }
    get isEditable() {
        return !1
    }
    get isWidget() {
        return !0
    }
    coordsAt(e, t) {
        let n = this.widget.coordsAt(this.dom, e, t);
        return n || (this.widget instanceof BlockGapWidget ? null : flattenRect(this.dom.getBoundingClientRect(), this.length ? 0 == e : t <= 0))
    }
    destroy() {
        super.destroy(), this.dom && this.widget.destroy(this.dom)
    }
    covers(e) {
        let {
            startSide: t,
            endSide: n
        } = this.deco;
        return t != n && (e < 0 ? t < 0 : n > 0)
    }
}
class BlockGapWidget extends WidgetType {
    constructor(e) {
        super(), this.height = e
    }
    toDOM() {
        let e = document.createElement("div");
        return e.className = "cm-gap", this.updateDOM(e), e
    }
    eq(e) {
        return e.height == this.height
    }
    updateDOM(e) {
        return e.style.height = this.height + "px", !0
    }
    get editable() {
        return !0
    }
    get estimatedHeight() {
        return this.height
    }
    ignoreEvent() {
        return !1
    }
}
class ContentBuilder {
    constructor(e, t, n, o) {
        this.doc = e, this.pos = t, this.end = n, this.disallowBlockEffectsFor = o, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t
    }
    posCovered() {
        if (0 == this.content.length) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let e = this.content[this.content.length - 1];
        return !(e.breakAfter || e instanceof BlockWidgetView && e.deco.endSide < 0)
    }
    getLine() {
        return this.curLine || (this.content.push(this.curLine = new LineView), this.atCursorPos = !0), this.curLine
    }
    flushBuffer(e = this.bufferMarks) {
        this.pendingBuffer && (this.curLine.append(wrapMarks(new WidgetBufferView(-1), e), e.length), this.pendingBuffer = 0)
    }
    addBlockWidget(e) {
        this.flushBuffer(), this.curLine = null, this.content.push(e)
    }
    finish(e) {
        this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || e && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView || this.getLine()
    }
    buildText(e, t, n) {
        for (; e > 0;) {
            if (this.textOff == this.text.length) {
                let {
                    value: t,
                    lineBreak: n,
                    done: o
                } = this.cursor.next(this.skip);
                if (this.skip = 0, o) throw new Error("Ran out of text content when drawing inline views");
                if (n) {
                    this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
                    continue
                }
                this.text = t, this.textOff = 0
            }
            let o = Math.min(this.text.length - this.textOff, e, 512);
            this.flushBuffer(t.slice(t.length - n)), this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + o)), t), n), this.atCursorPos = !0, this.textOff += o, e -= o, n = 0
        }
    }
    span(e, t, n, o) {
        this.buildText(t - e, n, o), this.pos = t, this.openStart < 0 && (this.openStart = o)
    }
    point(e, t, n, o, h, p) {
        if (this.disallowBlockEffectsFor[p] && n instanceof PointDecoration) {
            if (n.block) throw new RangeError("Block decorations may not be specified via plugins");
            if (t > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins")
        }
        let f = t - e;
        if (n instanceof PointDecoration)
            if (n.block) n.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new BlockWidgetView(n.widget || NullWidget.block, f, n));
            else {
                let p = WidgetView.create(n.widget || NullWidget.inline, f, f ? 0 : n.startSide),
                    g = this.atCursorPos && !p.isEditable && h <= o.length && (e < t || n.startSide > 0),
                    y = !p.isEditable && (e < t || h > o.length || n.startSide <= 0),
                    w = this.getLine();
                2 != this.pendingBuffer || g || p.isEditable || (this.pendingBuffer = 0), this.flushBuffer(o), g && (w.append(wrapMarks(new WidgetBufferView(1), o), h), h = o.length + Math.max(0, h - o.length)), w.append(wrapMarks(p, o), h), this.atCursorPos = y, this.pendingBuffer = y ? e < t || h > o.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = o.slice())
            }
        else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n);
        f && (this.textOff + f <= this.text.length ? this.textOff += f : (this.skip += f - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = h)
    }
    static build(e, t, n, o, h) {
        let p = new ContentBuilder(e, t, n, h);
        return p.openEnd = RangeSet.spans(o, t, n, p), p.openStart < 0 && (p.openStart = p.openEnd), p.finish(p.openEnd), p
    }
}

function wrapMarks(e, t) {
    for (let n of t) e = new MarkView(n, [e], e.length);
    return e
}
class NullWidget extends WidgetType {
    constructor(e) {
        super(), this.tag = e
    }
    eq(e) {
        return e.tag == this.tag
    }
    toDOM() {
        return document.createElement(this.tag)
    }
    updateDOM(e) {
        return e.nodeName.toLowerCase() == this.tag
    }
    get isHidden() {
        return !0
    }
}
NullWidget.inline = new NullWidget("span"), NullWidget.block = new NullWidget("div");
var pe = function(e) {
    return e[e.LTR = 0] = "LTR", e[e.RTL = 1] = "RTL", e
}(pe || (pe = {}));
const fe = pe.LTR,
    ge = pe.RTL;

function dec(e) {
    let t = [];
    for (let n = 0; n < e.length; n++) t.push(1 << +e[n]);
    return t
}
const me = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"),
    Oe = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"),
    ye = Object.create(null),
    we = [];
for (let nh of ["()", "[]", "{}"]) {
    let ih = nh.charCodeAt(0),
        rh = nh.charCodeAt(1);
    ye[ih] = rh, ye[rh] = -ih
}

function charType(e) {
    return e <= 247 ? me[e] : 1424 <= e && e <= 1524 ? 2 : 1536 <= e && e <= 1785 ? Oe[e - 1536] : 1774 <= e && e <= 2220 ? 4 : 8192 <= e && e <= 8204 ? 256 : 64336 <= e && e <= 65023 ? 4 : 1
}
const be = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class BidiSpan {
    get dir() {
        return this.level % 2 ? ge : fe
    }
    constructor(e, t, n) {
        this.from = e, this.to = t, this.level = n
    }
    side(e, t) {
        return this.dir == t == e ? this.to : this.from
    }
    forward(e, t) {
        return e == (this.dir == t)
    }
    static find(e, t, n, o) {
        let h = -1;
        for (let p = 0; p < e.length; p++) {
            let f = e[p];
            if (f.from <= t && f.to >= t) {
                if (f.level == n) return p;
                (h < 0 || (0 != o ? o < 0 ? f.from < t : f.to > t : e[h].level > f.level)) && (h = p)
            }
        }
        if (h < 0) throw new RangeError("Index out of range");
        return h
    }
}

function isolatesEq(e, t) {
    if (e.length != t.length) return !1;
    for (let n = 0; n < e.length; n++) {
        let o = e[n],
            h = t[n];
        if (o.from != h.from || o.to != h.to || o.direction != h.direction || !isolatesEq(o.inner, h.inner)) return !1
    }
    return !0
}
const Se = [];

function emitSpans(e, t, n, o, h, p, f) {
    let g = o % 2 ? 2 : 1;
    if (o % 2 == h % 2)
        for (let y = t, w = 0; y < n;) {
            let t = !0,
                b = !1;
            if (w == p.length || y < p[w].from) {
                let e = Se[y];
                e != g && (t = !1, b = 16 == e)
            }
            let S = t || 1 != g ? null : [],
                k = t ? o : o + 1,
                v = y;
            e: for (;;)
                if (w < p.length && v == p[w].from) {
                    if (b) break e;
                    let P = p[w];
                    if (!t)
                        for (let e = P.to, t = w + 1;;) {
                            if (e == n) break e;
                            if (!(t < p.length && p[t].from == e)) {
                                if (Se[e] == g) break e;
                                break
                            }
                            e = p[t++].to
                        }
                    if (w++, S) S.push(P);
                    else {
                        P.from > y && f.push(new BidiSpan(y, P.from, k)), computeSectionOrder(e, P.direction == fe != !(k % 2) ? o + 1 : o, h, P.inner, P.from, P.to, f), y = P.to
                    }
                    v = P.to
                } else {
                    if (v == n || (t ? Se[v] != g : Se[v] == g)) break;
                    v++
                }
            S ? emitSpans(e, y, v, o + 1, h, S, f) : y < v && f.push(new BidiSpan(y, v, k)), y = v
        } else
            for (let y = n, w = p.length; y > t;) {
                let n = !0,
                    b = !1;
                if (!w || y > p[w - 1].to) {
                    let e = Se[y - 1];
                    e != g && (n = !1, b = 16 == e)
                }
                let S = n || 1 != g ? null : [],
                    k = n ? o : o + 1,
                    v = y;
                e: for (;;)
                    if (w && v == p[w - 1].to) {
                        if (b) break e;
                        let P = p[--w];
                        if (!n)
                            for (let e = P.from, n = w;;) {
                                if (e == t) break e;
                                if (!n || p[n - 1].to != e) {
                                    if (Se[e - 1] == g) break e;
                                    break
                                }
                                e = p[--n].from
                            }
                        if (S) S.push(P);
                        else {
                            P.to < y && f.push(new BidiSpan(P.to, y, k)), computeSectionOrder(e, P.direction == fe != !(k % 2) ? o + 1 : o, h, P.inner, P.from, P.to, f), y = P.from
                        }
                        v = P.from
                    } else {
                        if (v == t || (n ? Se[v - 1] != g : Se[v - 1] == g)) break;
                        v--
                    }
                S ? emitSpans(e, v, y, o + 1, h, S, f) : v < y && f.push(new BidiSpan(v, y, k)), y = v
            }
}

function computeSectionOrder(e, t, n, o, h, p, f) {
    let g = t % 2 ? 2 : 1;
    ! function(e, t, n, o, h) {
        for (let p = 0; p <= o.length; p++) {
            let f = p ? o[p - 1].to : t,
                g = p < o.length ? o[p].from : n,
                y = p ? 256 : h;
            for (let t = f, n = y, o = y; t < g; t++) {
                let h = charType(e.charCodeAt(t));
                512 == h ? h = n : 8 == h && 4 == o && (h = 16), Se[t] = 4 == h ? 2 : h, 7 & h && (o = h), n = h
            }
            for (let e = f, t = y, o = y; e < g; e++) {
                let h = Se[e];
                if (128 == h) e < g - 1 && t == Se[e + 1] && 24 & t ? h = Se[e] = t : Se[e] = 256;
                else if (64 == h) {
                    let h = e + 1;
                    for (; h < g && 64 == Se[h];) h++;
                    let p = e && 8 == t || h < n && 8 == Se[h] ? 1 == o ? 1 : 8 : 256;
                    for (let t = e; t < h; t++) Se[t] = p;
                    e = h - 1
                } else 8 == h && 1 == o && (Se[e] = 1);
                t = h, 7 & h && (o = h)
            }
        }
    }(e, h, p, o, g),
    function(e, t, n, o, h) {
        let p = 1 == h ? 2 : 1;
        for (let f = 0, g = 0, y = 0; f <= o.length; f++) {
            let w = f ? o[f - 1].to : t,
                b = f < o.length ? o[f].from : n;
            for (let t, n, o, f = w; f < b; f++)
                if (n = ye[t = e.charCodeAt(f)])
                    if (n < 0) {
                        for (let e = g - 3; e >= 0; e -= 3)
                            if (we[e + 1] == -n) {
                                let t = we[e + 2],
                                    n = 2 & t ? h : 4 & t ? 1 & t ? p : h : 0;
                                n && (Se[f] = Se[we[e]] = n), g = e;
                                break
                            }
                    } else {
                        if (189 == we.length) break;
                        we[g++] = f, we[g++] = t, we[g++] = y
                    }
            else if (2 == (o = Se[f]) || 1 == o) {
                let e = o == h;
                y = e ? 0 : 1;
                for (let t = g - 3; t >= 0; t -= 3) {
                    let n = we[t + 2];
                    if (2 & n) break;
                    if (e) we[t + 2] |= 2;
                    else {
                        if (4 & n) break;
                        we[t + 2] |= 4
                    }
                }
            }
        }
    }(e, h, p, o, g),
    function(e, t, n, o) {
        for (let h = 0, p = o; h <= n.length; h++) {
            let f = h ? n[h - 1].to : e,
                g = h < n.length ? n[h].from : t;
            for (let y = f; y < g;) {
                let f = Se[y];
                if (256 == f) {
                    let f = y + 1;
                    for (;;)
                        if (f == g) {
                            if (h == n.length) break;
                            f = n[h++].to, g = h < n.length ? n[h].from : t
                        } else {
                            if (256 != Se[f]) break;
                            f++
                        }
                    let w = 1 == p,
                        b = w == (1 == (f < t ? Se[f] : o)) ? w ? 1 : 2 : o;
                    for (let t = f, o = h, p = o ? n[o - 1].to : e; t > y;) t == p && (t = n[--o].from, p = o ? n[o - 1].to : e), Se[--t] = b;
                    y = f
                } else p = f, y++
            }
        }
    }(h, p, o, g), emitSpans(e, h, p, t, n, o, f)
}

function computeOrder(e, t, n) {
    if (!e) return [new BidiSpan(0, 0, t == ge ? 1 : 0)];
    if (t == fe && !n.length && !be.test(e)) return trivialOrder(e.length);
    if (n.length)
        for (; e.length > Se.length;) Se[Se.length] = 256;
    let o = [],
        h = t == fe ? 0 : 1;
    return computeSectionOrder(e, h, h, n, 0, e.length, o), o
}

function trivialOrder(e) {
    return [new BidiSpan(0, e, 0)]
}
let xe = "";

function moveVisually(e, t, n, o, h) {
    var p;
    let f = o.head - e.from,
        g = BidiSpan.find(t, f, null !== (p = o.bidiLevel) && void 0 !== p ? p : -1, o.assoc),
        y = t[g],
        w = y.side(h, n);
    if (f == w) {
        let e = g += h ? 1 : -1;
        if (e < 0 || e >= t.length) return null;
        y = t[g = e], f = y.side(!h, n), w = y.side(h, n)
    }
    let b = findClusterBreak(e.text, f, y.forward(h, n));
    (b < y.from || b > y.to) && (b = w), xe = e.text.slice(Math.min(f, b), Math.max(f, b));
    let S = g == (h ? t.length - 1 : 0) ? null : t[g + (h ? 1 : -1)];
    return S && b == w && S.level + (h ? 0 : 1) < y.level ? EditorSelection.cursor(S.side(!h, n) + e.from, S.forward(h, n) ? 1 : -1, S.level) : EditorSelection.cursor(b + e.from, y.forward(h, n) ? -1 : 1, y.level)
}

function autoDirection(e, t, n) {
    for (let o = t; o < n; o++) {
        let t = charType(e.charCodeAt(o));
        if (1 == t) return fe;
        if (2 == t || 4 == t) return ge
    }
    return fe
}
const ke = Facet.define(),
    ve = Facet.define(),
    Pe = Facet.define(),
    Ce = Facet.define(),
    Qe = Facet.define(),
    Te = Facet.define(),
    $e = Facet.define(),
    Ee = Facet.define(),
    Ae = Facet.define(),
    Me = Facet.define({
        combine: e => e.some((e => e))
    }),
    Re = Facet.define({
        combine: e => e.some((e => e))
    }),
    De = Facet.define();
class ScrollTarget {
    constructor(e, t = "nearest", n = "nearest", o = 5, h = 5, p = !1) {
        this.range = e, this.y = t, this.x = n, this.yMargin = o, this.xMargin = h, this.isSnapshot = p
    }
    map(e) {
        return e.empty ? this : new ScrollTarget(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot)
    }
    clip(e) {
        return this.range.to <= e.doc.length ? this : new ScrollTarget(EditorSelection.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot)
    }
}
const Le = StateEffect.define({
        map: (e, t) => e.map(t)
    }),
    Ve = StateEffect.define();

function logException(e, t, n) {
    let o = e.facet(Ce);
    o.length ? o[0](t) : window.onerror ? window.onerror(String(t), n, void 0, void 0, t) : n ? console.error(n + ":", t) : console.error(t)
}
const Ze = Facet.define({
    combine: e => !e.length || e[0]
});
let _e = 0;
const Be = Facet.define();
class ViewPlugin {
    constructor(e, t, n, o, h) {
        this.id = e, this.create = t, this.domEventHandlers = n, this.domEventObservers = o, this.extension = h(this)
    }
    static define(e, t) {
        const {
            eventHandlers: n,
            eventObservers: o,
            provide: h,
            decorations: p
        } = t || {};
        return new ViewPlugin(_e++, e, n, o, (e => {
            let t = [Be.of(e)];
            return p && t.push(qe.of((t => {
                let n = t.plugin(e);
                return n ? p(n) : Decoration.none
            }))), h && t.push(h(e)), t
        }))
    }
    static fromClass(e, t) {
        return ViewPlugin.define((t => new e(t)), t)
    }
}
class PluginInstance {
    constructor(e) {
        this.spec = e, this.mustUpdate = null, this.value = null
    }
    update(e) {
        if (this.value) {
            if (this.mustUpdate) {
                let e = this.mustUpdate;
                if (this.mustUpdate = null, this.value.update) try {
                    this.value.update(e)
                } catch (t) {
                    if (logException(e.state, t, "CodeMirror plugin crashed"), this.value.destroy) try {
                        this.value.destroy()
                    } catch (e) {}
                    this.deactivate()
                }
            }
        } else if (this.spec) try {
            this.value = this.spec.create(e)
        } catch (t) {
            logException(e.state, t, "CodeMirror plugin crashed"), this.deactivate()
        }
        return this
    }
    destroy(e) {
        var t;
        if (null === (t = this.value) || void 0 === t ? void 0 : t.destroy) try {
            this.value.destroy()
        } catch (t) {
            logException(e.state, t, "CodeMirror plugin crashed")
        }
    }
    deactivate() {
        this.spec = this.value = null
    }
}
const Ie = Facet.define(),
    Xe = Facet.define(),
    qe = Facet.define(),
    ze = Facet.define(),
    Ne = Facet.define(),
    Ye = Facet.define();

function getIsolatedRanges(e, t) {
    let n = e.state.facet(Ye);
    if (!n.length) return n;
    let o = n.map((t => t instanceof Function ? t(e) : t)),
        h = [];
    return RangeSet.spans(o, t.from, t.to, {
        point() {},
        span(e, n, o, p) {
            let f = e - t.from,
                g = n - t.from,
                y = h;
            for (let e = o.length - 1; e >= 0; e--, p--) {
                let n, h = o[e].spec.bidiIsolate;
                if (null == h && (h = autoDirection(t.text, f, g)), p > 0 && y.length && (n = y[y.length - 1]).to == f && n.direction == h) n.to = g, y = n.inner;
                else {
                    let e = {
                        from: f,
                        to: g,
                        direction: h,
                        inner: []
                    };
                    y.push(e), y = e.inner
                }
            }
        }
    }), h
}
const je = Facet.define();

function getScrollMargins(e) {
    let t = 0,
        n = 0,
        o = 0,
        h = 0;
    for (let p of e.state.facet(je)) {
        let f = p(e);
        f && (null != f.left && (t = Math.max(t, f.left)), null != f.right && (n = Math.max(n, f.right)), null != f.top && (o = Math.max(o, f.top)), null != f.bottom && (h = Math.max(h, f.bottom)))
    }
    return {
        left: t,
        right: n,
        top: o,
        bottom: h
    }
}
const We = Facet.define();
class ChangedRange {
    constructor(e, t, n, o) {
        this.fromA = e, this.toA = t, this.fromB = n, this.toB = o
    }
    join(e) {
        return new ChangedRange(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB))
    }
    addToSet(e) {
        let t = e.length,
            n = this;
        for (; t > 0; t--) {
            let o = e[t - 1];
            if (!(o.fromA > n.toA)) {
                if (o.toA < n.fromA) break;
                n = n.join(o), e.splice(t - 1, 1)
            }
        }
        return e.splice(t, 0, n), e
    }
    static extendWithRanges(e, t) {
        if (0 == t.length) return e;
        let n = [];
        for (let o = 0, h = 0, p = 0, f = 0;; o++) {
            let g = o == e.length ? null : e[o],
                y = p - f,
                w = g ? g.fromB : 1e9;
            for (; h < t.length && t[h] < w;) {
                let e = t[h],
                    o = t[h + 1],
                    p = Math.max(f, e),
                    g = Math.min(w, o);
                if (p <= g && new ChangedRange(p + y, g + y, p, g).addToSet(n), o > w) break;
                h += 2
            }
            if (!g) return n;
            new ChangedRange(g.fromA, g.toA, g.fromB, g.toB).addToSet(n), p = g.toA, f = g.toB
        }
    }
}
class ViewUpdate {
    constructor(e, t, n) {
        this.view = e, this.state = t, this.transactions = n, this.flags = 0, this.startState = e.state, this.changes = ChangeSet.empty(this.startState.doc.length);
        for (let e of n) this.changes = this.changes.compose(e.changes);
        let o = [];
        this.changes.iterChangedRanges(((e, t, n, h) => o.push(new ChangedRange(e, t, n, h)))), this.changedRanges = o
    }
    static create(e, t, n) {
        return new ViewUpdate(e, t, n)
    }
    get viewportChanged() {
        return (4 & this.flags) > 0
    }
    get heightChanged() {
        return (2 & this.flags) > 0
    }
    get geometryChanged() {
        return this.docChanged || (10 & this.flags) > 0
    }
    get focusChanged() {
        return (1 & this.flags) > 0
    }
    get docChanged() {
        return !this.changes.empty
    }
    get selectionSet() {
        return this.transactions.some((e => e.selection))
    }
    get empty() {
        return 0 == this.flags && 0 == this.transactions.length
    }
}
class DocView extends ContentView {
    get length() {
        return this.view.state.doc.length
    }
    constructor(e) {
        super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = new Set, this.editContextFormatting = Decoration.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new LineView], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new ChangedRange(0, 0, 0, e.state.doc.length)], 0, null)
    }
    update(e) {
        var t;
        let n = e.changedRanges;
        this.minWidth > 0 && n.length && (n.every((({
            fromA: e,
            toA: t
        }) => t < this.minWidthFrom || e > this.minWidthTo)) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
        let o = -1;
        this.view.inputState.composing >= 0 && !this.view.observer.editContext && ((null === (t = this.domChanged) || void 0 === t ? void 0 : t.newSel) ? o = this.domChanged.newSel.head : function(e, t) {
            let n = !1;
            t && e.iterChangedRanges(((e, o) => {
                e < t.to && o > t.from && (n = !0)
            }));
            return n
        }(e.changes, this.hasComposition) || e.selectionSet || (o = e.state.selection.main.head));
        let h = o > -1 ? function(e, t, n) {
            let o = findCompositionNode(e, n);
            if (!o) return null;
            let {
                node: h,
                from: p,
                to: f
            } = o, g = h.nodeValue;
            if (/[\n\r]/.test(g)) return null;
            if (e.state.doc.sliceString(o.from, o.to) != g) return null;
            let y = t.invertedDesc,
                w = new ChangedRange(y.mapPos(p), y.mapPos(f), p, f),
                b = [];
            for (let t = h.parentNode;; t = t.parentNode) {
                let n = ContentView.get(t);
                if (n instanceof MarkView) b.push({
                    node: t,
                    deco: n.mark
                });
                else {
                    if (n instanceof LineView || "DIV" == t.nodeName && t.parentNode == e.contentDOM) return {
                        range: w,
                        text: h,
                        marks: b,
                        line: t
                    };
                    if (t == e.contentDOM) return null;
                    b.push({
                        node: t,
                        deco: new MarkDecoration({
                            inclusive: !0,
                            attributes: getAttrs$1(t),
                            tagName: t.tagName.toLowerCase()
                        })
                    })
                }
            }
        }(this.view, e.changes, o) : null;
        if (this.domChanged = null, this.hasComposition) {
            this.markedForComposition.clear();
            let {
                from: t,
                to: o
            } = this.hasComposition;
            n = new ChangedRange(t, o, e.changes.mapPos(t, -1), e.changes.mapPos(o, 1)).addToSet(n.slice())
        }
        this.hasComposition = h ? {
            from: h.range.fromB,
            to: h.range.toB
        } : null, (he.ie || he.chrome) && !h && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
        let p = function(e, t, n) {
            let o = new Ue;
            return RangeSet.compare(e, t, n, o), o.changes
        }(this.decorations, this.updateDeco(), e.changes);
        return n = ChangedRange.extendWithRanges(n, p), !!(7 & this.flags || 0 != n.length) && (this.updateInner(n, e.startState.doc.length, h), e.transactions.length && (this.lastUpdate = Date.now()), !0)
    }
    updateInner(e, t, n) {
        this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, n);
        let {
            observer: o
        } = this.view;
        o.ignore((() => {
            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
            let e = he.chrome || he.ios ? {
                node: o.selectionRange.focusNode,
                written: !1
            } : void 0;
            this.sync(this.view, e), this.flags &= -8, e && (e.written || o.selectionRange.focusNode != e.node) && (this.forceSelection = !0), this.dom.style.height = ""
        })), this.markedForComposition.forEach((e => e.flags &= -9));
        let h = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
            for (let e of this.children) e instanceof BlockWidgetView && e.widget instanceof BlockGapWidget && h.push(e.dom);
        o.updateGaps(h)
    }
    updateChildren(e, t, n) {
        let o = n ? n.range.addToSet(e.slice()) : e,
            h = this.childCursor(t);
        for (let e = o.length - 1;; e--) {
            let t = e >= 0 ? o[e] : null;
            if (!t) break;
            let p, f, g, y, {
                fromA: w,
                toA: b,
                fromB: S,
                toB: k
            } = t;
            if (n && n.range.fromB < k && n.range.toB > S) {
                let e = ContentBuilder.build(this.view.state.doc, S, n.range.fromB, this.decorations, this.dynamicDecorationMap),
                    t = ContentBuilder.build(this.view.state.doc, n.range.toB, k, this.decorations, this.dynamicDecorationMap);
                f = e.breakAtStart, g = e.openStart, y = t.openEnd;
                let o = this.compositionView(n);
                t.breakAtStart ? o.breakAfter = 1 : t.content.length && o.merge(o.length, o.length, t.content[0], !1, t.openStart, 0) && (o.breakAfter = t.content[0].breakAfter, t.content.shift()), e.content.length && o.merge(0, 0, e.content[e.content.length - 1], !0, 0, e.openEnd) && e.content.pop(), p = e.content.concat(o).concat(t.content)
            } else({
                content: p,
                breakAtStart: f,
                openStart: g,
                openEnd: y
            } = ContentBuilder.build(this.view.state.doc, S, k, this.decorations, this.dynamicDecorationMap));
            let {
                i: v,
                off: P
            } = h.findPos(b, 1), {
                i: C,
                off: Q
            } = h.findPos(w, -1);
            replaceRange(this, C, Q, v, P, p, f, g, y)
        }
        n && this.fixCompositionDOM(n)
    }
    updateEditContextFormatting(e) {
        this.editContextFormatting = this.editContextFormatting.map(e.changes);
        for (let t of e.transactions)
            for (let e of t.effects) e.is(Ve) && (this.editContextFormatting = e.value)
    }
    compositionView(e) {
        let t = new TextView(e.text.nodeValue);
        t.flags |= 8;
        for (let {
                deco: n
            } of e.marks) t = new MarkView(n, [t], t.length);
        let n = new LineView;
        return n.append(t, 0), n
    }
    fixCompositionDOM(e) {
        let fix = (e, t) => {
                t.flags |= 8 | (t.children.some((e => 7 & e.flags)) ? 1 : 0), this.markedForComposition.add(t);
                let n = ContentView.get(e);
                n && n != t && (n.dom = null), t.setDOM(e)
            },
            t = this.childPos(e.range.fromB, 1),
            n = this.children[t.i];
        fix(e.line, n);
        for (let o = e.marks.length - 1; o >= -1; o--) t = n.childPos(t.off, 1), n = n.children[t.i], fix(o >= 0 ? e.marks[o].node : e.text, n)
    }
    updateSelection(e = !1, t = !1) {
        !e && this.view.observer.selectionRange.focusNode || this.view.observer.readSelectionRange();
        let n = this.view.root.activeElement,
            o = n == this.dom,
            h = !o && hasSelection(this.dom, this.view.observer.selectionRange) && !(n && this.dom.contains(n));
        if (!(o || t || h)) return;
        let p = this.forceSelection;
        this.forceSelection = !1;
        let f = this.view.state.selection.main,
            g = this.moveToLine(this.domAtPos(f.anchor)),
            y = f.empty ? g : this.moveToLine(this.domAtPos(f.head));
        if (he.gecko && f.empty && !this.hasComposition && (1 == (w = g).node.nodeType && w.node.firstChild && (0 == w.offset || "false" == w.node.childNodes[w.offset - 1].contentEditable) && (w.offset == w.node.childNodes.length || "false" == w.node.childNodes[w.offset].contentEditable))) {
            let e = document.createTextNode("");
            this.view.observer.ignore((() => g.node.insertBefore(e, g.node.childNodes[g.offset] || null))), g = y = new DOMPos(e, 0), p = !0
        }
        var w;
        let b = this.view.observer.selectionRange;
        !p && b.focusNode && (isEquivalentPosition(g.node, g.offset, b.anchorNode, b.anchorOffset) && isEquivalentPosition(y.node, y.offset, b.focusNode, b.focusOffset) || this.suppressWidgetCursorChange(b, f)) || (this.view.observer.ignore((() => {
            he.android && he.chrome && this.dom.contains(b.focusNode) && function(e, t) {
                for (let n = e; n && n != t; n = n.assignedSlot || n.parentNode)
                    if (1 == n.nodeType && "false" == n.contentEditable) return !0;
                return !1
            }(b.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({
                preventScroll: !0
            }));
            let e = getSelection(this.view.root);
            if (e)
                if (f.empty) {
                    if (he.gecko) {
                        let e = (t = g.node, o = g.offset, 1 != t.nodeType ? 0 : (o && "false" == t.childNodes[o - 1].contentEditable ? 1 : 0) | (o < t.childNodes.length && "false" == t.childNodes[o].contentEditable ? 2 : 0));
                        if (e && 3 != e) {
                            let t = (1 == e ? textNodeBefore : textNodeAfter)(g.node, g.offset);
                            t && (g = new DOMPos(t.node, t.offset))
                        }
                    }
                    e.collapse(g.node, g.offset), null != f.bidiLevel && void 0 !== e.caretBidiLevel && (e.caretBidiLevel = f.bidiLevel)
                } else if (e.extend) {
                e.collapse(g.node, g.offset);
                try {
                    e.extend(y.node, y.offset)
                } catch (e) {}
            } else {
                let t = document.createRange();
                f.anchor > f.head && ([g, y] = [y, g]), t.setEnd(y.node, y.offset), t.setStart(g.node, g.offset), e.removeAllRanges(), e.addRange(t)
            } else;
            var t, o;
            h && this.view.root.activeElement == this.dom && (this.dom.blur(), n && n.focus())
        })), this.view.observer.setSelectionRange(g, y)), this.impreciseAnchor = g.precise ? null : new DOMPos(b.anchorNode, b.anchorOffset), this.impreciseHead = y.precise ? null : new DOMPos(b.focusNode, b.focusOffset)
    }
    suppressWidgetCursorChange(e, t) {
        return this.hasComposition && t.empty && isEquivalentPosition(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head
    }
    enforceCursorAssoc() {
        if (this.hasComposition) return;
        let {
            view: e
        } = this, t = e.state.selection.main, n = getSelection(e.root), {
            anchorNode: o,
            anchorOffset: h
        } = e.observer.selectionRange;
        if (!(n && t.empty && t.assoc && n.modify)) return;
        let p = LineView.find(this, t.head);
        if (!p) return;
        let f = p.posAtStart;
        if (t.head == f || t.head == f + p.length) return;
        let g = this.coordsAt(t.head, -1),
            y = this.coordsAt(t.head, 1);
        if (!g || !y || g.bottom > y.top) return;
        let w = this.domAtPos(t.head + t.assoc);
        n.collapse(w.node, w.offset), n.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
        let b = e.observer.selectionRange;
        e.docView.posFromDOM(b.anchorNode, b.anchorOffset) != t.from && n.collapse(o, h)
    }
    moveToLine(e) {
        let t, n = this.dom;
        if (e.node != n) return e;
        for (let o = e.offset; !t && o < n.childNodes.length; o++) {
            let e = ContentView.get(n.childNodes[o]);
            e instanceof LineView && (t = e.domAtPos(0))
        }
        for (let o = e.offset - 1; !t && o >= 0; o--) {
            let e = ContentView.get(n.childNodes[o]);
            e instanceof LineView && (t = e.domAtPos(e.length))
        }
        return t ? new DOMPos(t.node, t.offset, !0) : e
    }
    nearest(e) {
        for (let t = e; t;) {
            let e = ContentView.get(t);
            if (e && e.rootView == this) return e;
            t = t.parentNode
        }
        return null
    }
    posFromDOM(e, t) {
        let n = this.nearest(e);
        if (!n) throw new RangeError("Trying to find position for a DOM position outside of the document");
        return n.localPosFromDOM(e, t) + n.posAtStart
    }
    domAtPos(e) {
        let {
            i: t,
            off: n
        } = this.childCursor().findPos(e, -1);
        for (; t < this.children.length - 1;) {
            let e = this.children[t];
            if (n < e.length || e instanceof LineView) break;
            t++, n = 0
        }
        return this.children[t].domAtPos(n)
    }
    coordsAt(e, t) {
        let n = null,
            o = 0;
        for (let h = this.length, p = this.children.length - 1; p >= 0; p--) {
            let f = this.children[p],
                g = h - f.breakAfter,
                y = g - f.length;
            if (g < e) break;
            if (y <= e && (y < e || f.covers(-1)) && (g > e || f.covers(1)) && (!n || f instanceof LineView && !(n instanceof LineView && t >= 0))) n = f, o = y;
            else if (n && y == e && g == e && f instanceof BlockWidgetView && Math.abs(t) < 2) {
                if (f.deco.startSide < 0) break;
                p && (n = null)
            }
            h = y
        }
        return n ? n.coordsAt(e - o, t) : null
    }
    coordsForChar(e) {
        let {
            i: t,
            off: n
        } = this.childPos(e, 1), o = this.children[t];
        if (!(o instanceof LineView)) return null;
        for (; o.children.length;) {
            let {
                i: e,
                off: t
            } = o.childPos(n, 1);
            for (;; e++) {
                if (e == o.children.length) return null;
                if ((o = o.children[e]).length) break
            }
            n = t
        }
        if (!(o instanceof TextView)) return null;
        let h = findClusterBreak(o.text, n);
        if (h == n) return null;
        let p = textRange(o.dom, n, h).getClientRects();
        for (let e = 0; e < p.length; e++) {
            let t = p[e];
            if (e == p.length - 1 || t.top < t.bottom && t.left < t.right) return t
        }
        return null
    }
    measureVisibleLineHeights(e) {
        let t = [],
            {
                from: n,
                to: o
            } = e,
            h = this.view.contentDOM.clientWidth,
            p = h > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1,
            f = -1,
            g = this.view.textDirection == pe.LTR;
        for (let e = 0, y = 0; y < this.children.length; y++) {
            let w = this.children[y],
                b = e + w.length;
            if (b > o) break;
            if (e >= n) {
                let n = w.dom.getBoundingClientRect();
                if (t.push(n.height), p) {
                    let t = w.dom.lastChild,
                        o = t ? clientRectsFor(t) : [];
                    if (o.length) {
                        let t = o[o.length - 1],
                            p = g ? t.right - n.left : n.right - t.left;
                        p > f && (f = p, this.minWidth = h, this.minWidthFrom = e, this.minWidthTo = b)
                    }
                }
            }
            e = b + w.breakAfter
        }
        return t
    }
    textDirectionAt(e) {
        let {
            i: t
        } = this.childPos(e, 1);
        return "rtl" == getComputedStyle(this.children[t].dom).direction ? pe.RTL : pe.LTR
    }
    measureTextSize() {
        for (let e of this.children)
            if (e instanceof LineView) {
                let t = e.measureTextSize();
                if (t) return t
            }
        let e, t, n, o = document.createElement("div");
        return o.className = "cm-line", o.style.width = "99999px", o.style.position = "absolute", o.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore((() => {
            this.dom.appendChild(o);
            let h = clientRectsFor(o.firstChild)[0];
            e = o.getBoundingClientRect().height, t = h ? h.width / 27 : 7, n = h ? h.height : e, o.remove()
        })), {
            lineHeight: e,
            charWidth: t,
            textHeight: n
        }
    }
    childCursor(e = this.length) {
        let t = this.children.length;
        return t && (e -= this.children[--t].length), new ChildCursor(this.children, e, t)
    }
    computeBlockGapDeco() {
        let e = [],
            t = this.view.viewState;
        for (let n = 0, o = 0;; o++) {
            let h = o == t.viewports.length ? null : t.viewports[o],
                p = h ? h.from - 1 : this.length;
            if (p > n) {
                let o = (t.lineBlockAt(p).bottom - t.lineBlockAt(n).top) / this.view.scaleY;
                e.push(Decoration.replace({
                    widget: new BlockGapWidget(o),
                    block: !0,
                    inclusive: !0,
                    isBlockGap: !0
                }).range(n, p))
            }
            if (!h) break;
            n = h.to + 1
        }
        return Decoration.set(e)
    }
    updateDeco() {
        let e = 1,
            t = this.view.state.facet(qe).map((t => (this.dynamicDecorationMap[e++] = "function" == typeof t) ? t(this.view) : t)),
            n = !1,
            o = this.view.state.facet(ze).map(((e, t) => {
                let o = "function" == typeof e;
                return o && (n = !0), o ? e(this.view) : e
            }));
        for (o.length && (this.dynamicDecorationMap[e++] = n, t.push(RangeSet.join(o))), this.decorations = [this.editContextFormatting, ...t, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]; e < this.decorations.length;) this.dynamicDecorationMap[e++] = !1;
        return this.decorations
    }
    scrollIntoView(e) {
        if (e.isSnapshot) {
            let t = this.view.viewState.lineBlockAt(e.range.head);
            return this.view.scrollDOM.scrollTop = t.top - e.yMargin, void(this.view.scrollDOM.scrollLeft = e.xMargin)
        }
        for (let t of this.view.state.facet(De)) try {
            if (t(this.view, e.range, e)) return !0
        } catch (e) {
            logException(this.view.state, e, "scroll handler")
        }
        let t, {
                range: n
            } = e,
            o = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1);
        if (!o) return;
        !n.empty && (t = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (o = {
            left: Math.min(o.left, t.left),
            top: Math.min(o.top, t.top),
            right: Math.max(o.right, t.right),
            bottom: Math.max(o.bottom, t.bottom)
        });
        let h = getScrollMargins(this.view),
            p = {
                left: o.left - h.left,
                top: o.top - h.top,
                right: o.right + h.right,
                bottom: o.bottom + h.bottom
            },
            {
                offsetWidth: f,
                offsetHeight: g
            } = this.view.scrollDOM;
        ! function(e, t, n, o, h, p, f, g) {
            let y = e.ownerDocument,
                w = y.defaultView || window;
            for (let b = e, S = !1; b && !S;)
                if (1 == b.nodeType) {
                    let e, k = b == y.body,
                        v = 1,
                        P = 1;
                    if (k) e = windowRect(w);
                    else {
                        if (/^(fixed|sticky)$/.test(getComputedStyle(b).position) && (S = !0), b.scrollHeight <= b.clientHeight && b.scrollWidth <= b.clientWidth) {
                            b = b.assignedSlot || b.parentNode;
                            continue
                        }
                        let t = b.getBoundingClientRect();
                        ({
                            scaleX: v,
                            scaleY: P
                        } = getScale(b, t)), e = {
                            left: t.left,
                            right: t.left + b.clientWidth * v,
                            top: t.top,
                            bottom: t.top + b.clientHeight * P
                        }
                    }
                    let C = 0,
                        Q = 0;
                    if ("nearest" == h) t.top < e.top ? (Q = -(e.top - t.top + f), n > 0 && t.bottom > e.bottom + Q && (Q = t.bottom - e.bottom + Q + f)) : t.bottom > e.bottom && (Q = t.bottom - e.bottom + f, n < 0 && t.top - Q < e.top && (Q = -(e.top + Q - t.top + f)));
                    else {
                        let o = t.bottom - t.top,
                            p = e.bottom - e.top;
                        Q = ("center" == h && o <= p ? t.top + o / 2 - p / 2 : "start" == h || "center" == h && n < 0 ? t.top - f : t.bottom - p + f) - e.top
                    }
                    if ("nearest" == o ? t.left < e.left ? (C = -(e.left - t.left + p), n > 0 && t.right > e.right + C && (C = t.right - e.right + C + p)) : t.right > e.right && (C = t.right - e.right + p, n < 0 && t.left < e.left + C && (C = -(e.left + C - t.left + p))) : C = ("center" == o ? t.left + (t.right - t.left) / 2 - (e.right - e.left) / 2 : "start" == o == g ? t.left - p : t.right - (e.right - e.left) + p) - e.left, C || Q)
                        if (k) w.scrollBy(C, Q);
                        else {
                            let e = 0,
                                n = 0;
                            if (Q) {
                                let e = b.scrollTop;
                                b.scrollTop += Q / P, n = (b.scrollTop - e) * P
                            }
                            if (C) {
                                let t = b.scrollLeft;
                                b.scrollLeft += C / v, e = (b.scrollLeft - t) * v
                            }
                            t = {
                                left: t.left - e,
                                top: t.top - n,
                                right: t.right - e,
                                bottom: t.bottom - n
                            }, e && Math.abs(e - C) < 1 && (o = "nearest"), n && Math.abs(n - Q) < 1 && (h = "nearest")
                        }
                    if (k) break;
                    b = b.assignedSlot || b.parentNode
                } else {
                    if (11 != b.nodeType) break;
                    b = b.host
                }
        }(this.view.scrollDOM, p, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, f), -f), Math.max(Math.min(e.yMargin, g), -g), this.view.textDirection == pe.LTR)
    }
}

function findCompositionNode(e, t) {
    let n = e.observer.selectionRange;
    if (!n.focusNode) return null;
    let o = textNodeBefore(n.focusNode, n.focusOffset),
        h = textNodeAfter(n.focusNode, n.focusOffset),
        p = o || h;
    if (h && o && h.node != o.node) {
        let t = ContentView.get(h.node);
        if (!t || t instanceof TextView && t.text != h.node.nodeValue) p = h;
        else if (e.docView.lastCompositionAfterCursor) {
            let e = ContentView.get(o.node);
            !e || e instanceof TextView && e.text != o.node.nodeValue || (p = h)
        }
    }
    if (e.docView.lastCompositionAfterCursor = p != o, !p) return null;
    let f = t - p.offset;
    return {
        from: f,
        to: f + p.node.nodeValue.length,
        node: p.node
    }
}
let Ue = class {
    constructor() {
        this.changes = []
    }
    compareRange(e, t) {
        addRange(e, t, this.changes)
    }
    comparePoint(e, t) {
        addRange(e, t, this.changes)
    }
};

function getdx(e, t) {
    return t.left > e ? t.left - e : Math.max(0, e - t.right)
}

function getdy(e, t) {
    return t.top > e ? t.top - e : Math.max(0, e - t.bottom)
}

function yOverlap(e, t) {
    return e.top < t.bottom - 1 && e.bottom > t.top + 1
}

function upTop(e, t) {
    return t < e.top ? {
        top: t,
        left: e.left,
        right: e.right,
        bottom: e.bottom
    } : e
}

function upBot(e, t) {
    return t > e.bottom ? {
        top: e.top,
        left: e.left,
        right: e.right,
        bottom: t
    } : e
}

function domPosAtCoords(e, t, n) {
    let o, h, p, f, g, y, w, b, S = !1;
    for (let k = e.firstChild; k; k = k.nextSibling) {
        let e = clientRectsFor(k);
        for (let v = 0; v < e.length; v++) {
            let P = e[v];
            h && yOverlap(h, P) && (P = upTop(upBot(P, h.bottom), h.top));
            let C = getdx(t, P),
                Q = getdy(n, P);
            if (0 == C && 0 == Q) return 3 == k.nodeType ? domPosInText(k, t, n) : domPosAtCoords(k, t, n);
            if (!o || f > Q || f == Q && p > C) {
                o = k, h = P, p = C, f = Q;
                let g = Q ? n < P.top ? -1 : 1 : C ? t < P.left ? -1 : 1 : 0;
                S = !g || (g > 0 ? v < e.length - 1 : v > 0)
            }
            0 == C ? n > P.bottom && (!w || w.bottom < P.bottom) ? (g = k, w = P) : n < P.top && (!b || b.top > P.top) && (y = k, b = P) : w && yOverlap(w, P) ? w = upBot(w, P.bottom) : b && yOverlap(b, P) && (b = upTop(b, P.top))
        }
    }
    if (w && w.bottom >= n ? (o = g, h = w) : b && b.top <= n && (o = y, h = b), !o) return {
        node: e,
        offset: 0
    };
    let k = Math.max(h.left, Math.min(h.right, t));
    return 3 == o.nodeType ? domPosInText(o, k, n) : S && "false" != o.contentEditable ? domPosAtCoords(o, k, n) : {
        node: e,
        offset: Array.prototype.indexOf.call(e.childNodes, o) + (t >= (h.left + h.right) / 2 ? 1 : 0)
    }
}

function domPosInText(e, t, n) {
    let o = e.nodeValue.length,
        h = -1,
        p = 1e9,
        f = 0;
    for (let g = 0; g < o; g++) {
        let o = textRange(e, g, g + 1).getClientRects();
        for (let y = 0; y < o.length; y++) {
            let w = o[y];
            if (w.top == w.bottom) continue;
            f || (f = t - w.left);
            let b = (w.top > n ? w.top - n : n - w.bottom) - 1;
            if (w.left - 1 <= t && w.right + 1 >= t && b < p) {
                let n = t >= (w.left + w.right) / 2,
                    o = n;
                if (he.chrome || he.gecko) {
                    textRange(e, g).getBoundingClientRect().left == w.right && (o = !n)
                }
                if (b <= 0) return {
                    node: e,
                    offset: g + (o ? 1 : 0)
                };
                h = g + (o ? 1 : 0), p = b
            }
        }
    }
    return {
        node: e,
        offset: h > -1 ? h : f > 0 ? e.nodeValue.length : 0
    }
}

function posAtCoords(e, t, n, o = -1) {
    var h, p;
    let f, g = e.contentDOM.getBoundingClientRect(),
        y = g.top + e.viewState.paddingTop,
        {
            docHeight: w
        } = e.viewState,
        {
            x: b,
            y: S
        } = t,
        k = S - y;
    if (k < 0) return 0;
    if (k > w) return e.state.doc.length;
    for (let t = e.viewState.heightOracle.textHeight / 2, h = !1; f = e.elementAtHeight(k), f.type != ue.Text;)
        for (; k = o > 0 ? f.bottom + t : f.top - t, !(k >= 0 && k <= w);) {
            if (h) return n ? null : 0;
            h = !0, o = -o
        }
    S = y + k;
    let v = f.from;
    if (v < e.viewport.from) return 0 == e.viewport.from ? 0 : n ? null : posAtCoordsImprecise(e, g, f, b, S);
    if (v > e.viewport.to) return e.viewport.to == e.state.doc.length ? e.state.doc.length : n ? null : posAtCoordsImprecise(e, g, f, b, S);
    let P = e.dom.ownerDocument,
        C = e.root.elementFromPoint ? e.root : P,
        Q = C.elementFromPoint(b, S);
    Q && !e.contentDOM.contains(Q) && (Q = null), Q || (b = Math.max(g.left + 1, Math.min(g.right - 1, b)), Q = C.elementFromPoint(b, S), Q && !e.contentDOM.contains(Q) && (Q = null));
    let $, A = -1;
    if (Q && 0 != (null === (h = e.docView.nearest(Q)) || void 0 === h ? void 0 : h.isEditable)) {
        if (P.caretPositionFromPoint) {
            let e = P.caretPositionFromPoint(b, S);
            e && ({
                offsetNode: $,
                offset: A
            } = e)
        } else if (P.caretRangeFromPoint) {
            let t = P.caretRangeFromPoint(b, S);
            t && (({
                startContainer: $,
                startOffset: A
            } = t), (!e.contentDOM.contains($) || he.safari && function(e, t, n) {
                let o;
                if (3 != e.nodeType || t != (o = e.nodeValue.length)) return !1;
                for (let t = e.nextSibling; t; t = t.nextSibling)
                    if (1 != t.nodeType || "BR" != t.nodeName) return !1;
                return textRange(e, o - 1, o).getBoundingClientRect().left > n
            }($, A, b) || he.chrome && function(e, t, n) {
                if (0 != t) return !1;
                for (let t = e;;) {
                    let e = t.parentNode;
                    if (!e || 1 != e.nodeType || e.firstChild != t) return !1;
                    if (e.classList.contains("cm-line")) break;
                    t = e
                }
                let o = 1 == e.nodeType ? e.getBoundingClientRect() : textRange(e, 0, Math.max(e.nodeValue.length, 1)).getBoundingClientRect();
                return n - o.left > 5
            }($, A, b)) && ($ = void 0))
        }
        $ && (A = Math.min(maxOffset($), A))
    }
    if (!$ || !e.docView.dom.contains($)) {
        let t = LineView.find(e.docView, v);
        if (!t) return k > f.top + f.height / 2 ? f.to : f.from;
        ({
            node: $,
            offset: A
        } = domPosAtCoords(t.dom, b, S))
    }
    let M = e.docView.nearest($);
    if (!M) return null;
    if (M.isWidget && 1 == (null === (p = M.dom) || void 0 === p ? void 0 : p.nodeType)) {
        let e = M.dom.getBoundingClientRect();
        return t.y < e.top || t.y <= e.bottom && t.x <= (e.left + e.right) / 2 ? M.posAtStart : M.posAtEnd
    }
    return M.localPosFromDOM($, A) + M.posAtStart
}

function posAtCoordsImprecise(e, t, n, o, h) {
    let p = Math.round((o - t.left) * e.defaultCharacterWidth);
    if (e.lineWrapping && n.height > 1.5 * e.defaultLineHeight) {
        let t = e.viewState.heightOracle.textHeight;
        p += Math.floor((h - n.top - .5 * (e.defaultLineHeight - t)) / t) * e.viewState.heightOracle.lineLength
    }
    let f = e.state.sliceDoc(n.from, n.to);
    return n.from + findColumn(f, p, e.state.tabSize)
}

function blockAt(e, t) {
    let n = e.lineBlockAt(t);
    if (Array.isArray(n.type))
        for (let e of n.type)
            if (e.to > t || e.to == t && (e.to == n.to || e.type == ue.Text)) return e;
    return n
}

function moveByChar(e, t, n, o) {
    let h = e.state.doc.lineAt(t.head),
        p = e.bidiSpans(h),
        f = e.textDirectionAt(h.from);
    for (let g = t, y = null;;) {
        let t = moveVisually(h, p, f, g, n),
            w = xe;
        if (!t) {
            if (h.number == (n ? e.state.doc.lines : 1)) return g;
            w = "\n", h = e.state.doc.line(h.number + (n ? 1 : -1)), p = e.bidiSpans(h), t = e.visualLineSide(h, !n)
        }
        if (y) {
            if (!y(w)) return g
        } else {
            if (!o) return t;
            y = o(w)
        }
        g = t
    }
}

function skipAtomicRanges(e, t, n) {
    for (;;) {
        let o = 0;
        for (let h of e) h.between(t - 1, t + 1, ((e, h, p) => {
            if (t > e && t < h) {
                let p = o || n || (t - e < h - t ? -1 : 1);
                t = p < 0 ? e : h, o = p
            }
        }));
        if (!o) return t
    }
}

function skipAtoms(e, t, n) {
    let o = skipAtomicRanges(e.state.facet(Ne).map((t => t(e))), n.from, t.head > n.from ? -1 : 1);
    return o == n.from ? n : EditorSelection.cursor(o, o < n.from ? 1 : -1)
}
const Fe = "ï¿¿";
class DOMReader {
    constructor(e, t) {
        this.points = e, this.text = "", this.lineSeparator = t.facet(EditorState.lineSeparator)
    }
    append(e) {
        this.text += e
    }
    lineBreak() {
        this.text += Fe
    }
    readRange(e, t) {
        if (!e) return this;
        let n = e.parentNode;
        for (let o = e;;) {
            this.findPointBefore(n, o);
            let e = this.text.length;
            this.readNode(o);
            let h = o.nextSibling;
            if (h == t) break;
            let p = ContentView.get(o),
                f = ContentView.get(h);
            (p && f ? p.breakAfter : (p ? p.breakAfter : isBlockElement(o)) || isBlockElement(h) && ("BR" != o.nodeName || o.cmIgnore) && this.text.length > e) && this.lineBreak(), o = h
        }
        return this.findPointBefore(n, t), this
    }
    readTextNode(e) {
        let t = e.nodeValue;
        for (let n of this.points) n.node == e && (n.pos = this.text.length + Math.min(n.offset, t.length));
        for (let n = 0, o = this.lineSeparator ? null : /\r\n?|\n/g;;) {
            let h, p = -1,
                f = 1;
            if (this.lineSeparator ? (p = t.indexOf(this.lineSeparator, n), f = this.lineSeparator.length) : (h = o.exec(t)) && (p = h.index, f = h[0].length), this.append(t.slice(n, p < 0 ? t.length : p)), p < 0) break;
            if (this.lineBreak(), f > 1)
                for (let t of this.points) t.node == e && t.pos > this.text.length && (t.pos -= f - 1);
            n = p + f
        }
    }
    readNode(e) {
        if (e.cmIgnore) return;
        let t = ContentView.get(e),
            n = t && t.overrideDOMText;
        if (null != n) {
            this.findPointInside(e, n.length);
            for (let e = n.iter(); !e.next().done;) e.lineBreak ? this.lineBreak() : this.append(e.value)
        } else 3 == e.nodeType ? this.readTextNode(e) : "BR" == e.nodeName ? e.nextSibling && this.lineBreak() : 1 == e.nodeType && this.readRange(e.firstChild, null)
    }
    findPointBefore(e, t) {
        for (let n of this.points) n.node == e && e.childNodes[n.offset] == t && (n.pos = this.text.length)
    }
    findPointInside(e, t) {
        for (let n of this.points)(3 == e.nodeType ? n.node == e : e.contains(n.node)) && (n.pos = this.text.length + (isAtEnd(e, n.node, n.offset) ? t : 0))
    }
}

function isAtEnd(e, t, n) {
    for (;;) {
        if (!t || n < maxOffset(t)) return !1;
        if (t == e) return !0;
        n = domIndex(t) + 1, t = t.parentNode
    }
}
class DOMPoint {
    constructor(e, t) {
        this.node = e, this.offset = t, this.pos = -1
    }
}
class DOMChange {
    constructor(e, t, n, o) {
        this.typeOver = o, this.bounds = null, this.text = "", this.domChanged = t > -1;
        let {
            impreciseHead: h,
            impreciseAnchor: p
        } = e.docView;
        if (e.state.readOnly && t > -1) this.newSel = null;
        else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, n, 0))) {
            let t = h || p ? [] : function(e) {
                    let t = [];
                    if (e.root.activeElement != e.contentDOM) return t;
                    let {
                        anchorNode: n,
                        anchorOffset: o,
                        focusNode: h,
                        focusOffset: p
                    } = e.observer.selectionRange;
                    n && (t.push(new DOMPoint(n, o)), h == n && p == o || t.push(new DOMPoint(h, p)));
                    return t
                }(e),
                n = new DOMReader(t, e.state);
            n.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = n.text, this.newSel = function(e, t) {
                if (0 == e.length) return null;
                let n = e[0].pos,
                    o = 2 == e.length ? e[1].pos : n;
                return n > -1 && o > -1 ? EditorSelection.single(n + t, o + t) : null
            }(t, this.bounds.from)
        } else {
            let t = e.observer.selectionRange,
                n = h && h.node == t.focusNode && h.offset == t.focusOffset || !contains(e.contentDOM, t.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(t.focusNode, t.focusOffset),
                o = p && p.node == t.anchorNode && p.offset == t.anchorOffset || !contains(e.contentDOM, t.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(t.anchorNode, t.anchorOffset),
                f = e.viewport;
            if ((he.ios || he.chrome) && e.state.selection.main.empty && n != o && (f.from > 0 || f.to < e.state.doc.length)) {
                let t = Math.min(n, o),
                    h = Math.max(n, o),
                    p = f.from - t,
                    g = f.to - h;
                0 != p && 1 != p && 0 != t || 0 != g && -1 != g && h != e.state.doc.length || (n = 0, o = e.state.doc.length)
            }
            this.newSel = EditorSelection.single(o, n)
        }
    }
}

function applyDOMChange(e, t) {
    let n, {
            newSel: o
        } = t,
        h = e.state.selection.main,
        p = e.inputState.lastKeyTime > Date.now() - 100 ? e.inputState.lastKeyCode : -1;
    if (t.bounds) {
        let {
            from: o,
            to: f
        } = t.bounds, g = h.from, y = null;
        (8 === p || he.android && t.text.length < f - o) && (g = h.to, y = "end");
        let w = function(e, t, n, o) {
            let h = Math.min(e.length, t.length),
                p = 0;
            for (; p < h && e.charCodeAt(p) == t.charCodeAt(p);) p++;
            if (p == h && e.length == t.length) return null;
            let f = e.length,
                g = t.length;
            for (; f > 0 && g > 0 && e.charCodeAt(f - 1) == t.charCodeAt(g - 1);) f--, g--;
            if ("end" == o) {
                n -= f + Math.max(0, p - Math.min(f, g)) - p
            }
            if (f < p && e.length < t.length) {
                p -= n <= p && n >= f ? p - n : 0, g = p + (g - f), f = p
            } else if (g < p) {
                p -= n <= p && n >= g ? p - n : 0, f = p + (f - g), g = p
            }
            return {
                from: p,
                toA: f,
                toB: g
            }
        }(e.state.doc.sliceString(o, f, Fe), t.text, g - o, y);
        w && (he.chrome && 13 == p && w.toB == w.from + 2 && t.text.slice(w.from, w.toB) == Fe + Fe && w.toB--, n = {
            from: o + w.from,
            to: o + w.toA,
            insert: Text.of(t.text.slice(w.from, w.toB).split(Fe))
        })
    } else o && (!e.hasFocus && e.state.facet(Ze) || o.main.eq(h)) && (o = null);
    if (!n && !o) return !1;
    if (!n && t.typeOver && !h.empty && o && o.main.empty ? n = {
            from: h.from,
            to: h.to,
            insert: e.state.doc.slice(h.from, h.to)
        } : n && n.from >= h.from && n.to <= h.to && (n.from != h.from || n.to != h.to) && h.to - h.from - (n.to - n.from) <= 4 ? n = {
            from: h.from,
            to: h.to,
            insert: e.state.doc.slice(h.from, n.from).append(n.insert).append(e.state.doc.slice(n.to, h.to))
        } : (he.mac || he.android) && n && n.from == n.to && n.from == h.head - 1 && /^\. ?$/.test(n.insert.toString()) && "off" == e.contentDOM.getAttribute("autocorrect") ? (o && 2 == n.insert.length && (o = EditorSelection.single(o.main.anchor - 1, o.main.head - 1)), n = {
            from: h.from,
            to: h.to,
            insert: Text.of([" "])
        }) : he.chrome && n && n.from == n.to && n.from == h.head && "\n " == n.insert.toString() && e.lineWrapping && (o && (o = EditorSelection.single(o.main.anchor - 1, o.main.head - 1)), n = {
            from: h.from,
            to: h.to,
            insert: Text.of([" "])
        }), n) return applyDOMChangeInner(e, n, o, p);
    if (o && !o.main.eq(h)) {
        let t = !1,
            n = "select";
        return e.inputState.lastSelectionTime > Date.now() - 50 && ("select" == e.inputState.lastSelectionOrigin && (t = !0), n = e.inputState.lastSelectionOrigin), e.dispatch({
            selection: o,
            scrollIntoView: t,
            userEvent: n
        }), !0
    }
    return !1
}

function applyDOMChangeInner(e, t, n, o = -1) {
    if (he.ios && e.inputState.flushIOSKey(t)) return !0;
    let h = e.state.selection.main;
    if (he.android && (t.to == h.to && (t.from == h.from || t.from == h.from - 1 && " " == e.state.sliceDoc(t.from, h.from)) && 1 == t.insert.length && 2 == t.insert.lines && dispatchKey(e.contentDOM, "Enter", 13) || (t.from == h.from - 1 && t.to == h.to && 0 == t.insert.length || 8 == o && t.insert.length < t.to - t.from && t.to > h.head) && dispatchKey(e.contentDOM, "Backspace", 8) || t.from == h.from && t.to == h.to + 1 && 0 == t.insert.length && dispatchKey(e.contentDOM, "Delete", 46))) return !0;
    let p, f = t.insert.toString();
    e.inputState.composing >= 0 && e.inputState.composing++;
    let defaultInsert = () => p || (p = function(e, t, n) {
        let o, h = e.state,
            p = h.selection.main;
        if (t.from >= p.from && t.to <= p.to && t.to - t.from >= (p.to - p.from) / 3 && (!n || n.main.empty && n.main.from == t.from + t.insert.length) && e.inputState.composing < 0) {
            let n = p.from < t.from ? h.sliceDoc(p.from, t.from) : "",
                f = p.to > t.to ? h.sliceDoc(t.to, p.to) : "";
            o = h.replaceSelection(e.state.toText(n + t.insert.sliceString(0, void 0, e.state.lineBreak) + f))
        } else {
            let f = h.changes(t),
                g = n && n.main.to <= f.newLength ? n.main : void 0;
            if (h.selection.ranges.length > 1 && e.inputState.composing >= 0 && t.to <= p.to && t.to >= p.to - 10) {
                let y, w = e.state.sliceDoc(t.from, t.to),
                    b = n && findCompositionNode(e, n.main.head);
                if (b) {
                    let e = t.insert.length - (t.to - t.from);
                    y = {
                        from: b.from,
                        to: b.to - e
                    }
                } else y = e.state.doc.lineAt(p.head);
                let S = p.to - t.to,
                    k = p.to - p.from;
                o = h.changeByRange((n => {
                    if (n.from == p.from && n.to == p.to) return {
                        changes: f,
                        range: g || n.map(f)
                    };
                    let o = n.to - S,
                        b = o - w.length;
                    if (n.to - n.from != k || e.state.sliceDoc(b, o) != w || n.to >= y.from && n.from <= y.to) return {
                        range: n
                    };
                    let v = h.changes({
                            from: b,
                            to: o,
                            insert: t.insert
                        }),
                        P = n.to - p.to;
                    return {
                        changes: v,
                        range: g ? EditorSelection.range(Math.max(0, g.anchor + P), Math.max(0, g.head + P)) : n.map(v)
                    }
                }))
            } else o = {
                changes: f,
                selection: g && h.selection.replaceRange(g)
            }
        }
        let f = "input.type";
        (e.composing || e.inputState.compositionPendingChange && e.inputState.compositionEndedAt > Date.now() - 50) && (e.inputState.compositionPendingChange = !1, f += ".compose", e.inputState.compositionFirstChange && (f += ".start", e.inputState.compositionFirstChange = !1));
        return h.update(o, {
            userEvent: f,
            scrollIntoView: !0
        })
    }(e, t, n));
    return e.state.facet(Te).some((n => n(e, t.from, t.to, f, defaultInsert))) || e.dispatch(defaultInsert()), !0
}
class InputState {
    setSelectionOrigin(e) {
        this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now()
    }
    constructor(e) {
        this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, he.safari && e.contentDOM.addEventListener("input", (() => null)), he.gecko && function(e) {
            lt.has(e) || (lt.add(e), e.addEventListener("copy", (() => {})), e.addEventListener("cut", (() => {})))
        }(e.contentDOM.ownerDocument)
    }
    handleEvent(e) {
        (function(e, t) {
            if (!t.bubbles) return !0;
            if (t.defaultPrevented) return !1;
            for (let n, o = t.target; o != e.contentDOM; o = o.parentNode)
                if (!o || 11 == o.nodeType || (n = ContentView.get(o)) && n.ignoreEvent(t)) return !1;
            return !0
        })(this.view, e) && !this.ignoreDuringComposition(e) && ("keydown" == e.type && this.keydown(e) || this.runHandlers(e.type, e))
    }
    runHandlers(e, t) {
        let n = this.handlers[e];
        if (n) {
            for (let e of n.observers) e(this.view, t);
            for (let e of n.handlers) {
                if (t.defaultPrevented) break;
                if (e(this.view, t)) {
                    t.preventDefault();
                    break
                }
            }
        }
    }
    ensureHandlers(e) {
        let t = computeHandlers(e),
            n = this.handlers,
            o = this.view.contentDOM;
        for (let e in t)
            if ("scroll" != e) {
                let h = !t[e].handlers.length,
                    p = n[e];
                p && h != !p.handlers.length && (o.removeEventListener(e, this.handleEvent), p = null), p || o.addEventListener(e, this.handleEvent, {
                    passive: h
                })
            }
        for (let e in n) "scroll" == e || t[e] || o.removeEventListener(e, this.handleEvent);
        this.handlers = t
    }
    keydown(e) {
        if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), 9 == e.keyCode && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) return !0;
        if (this.tabFocusMode > 0 && 27 != e.keyCode && Ke.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), he.android && he.chrome && !e.synthetic && (13 == e.keyCode || 8 == e.keyCode)) return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
        let t;
        return !he.ios || e.synthetic || e.altKey || e.metaKey || !((t = Ge.find((t => t.keyCode == e.keyCode))) && !e.ctrlKey || He.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (229 != e.keyCode && this.view.observer.forceFlush(), !1) : (this.pendingIOSKey = t || e, setTimeout((() => this.flushIOSKey()), 250), !0)
    }
    flushIOSKey(e) {
        let t = this.pendingIOSKey;
        return !!t && (!("Enter" == t.key && e && e.from < e.to && /^\S+$/.test(e.insert.toString())) && (this.pendingIOSKey = void 0, dispatchKey(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0)))
    }
    ignoreDuringComposition(e) {
        return !!/^key/.test(e.type) && (this.composing > 0 || !!(he.safari && !he.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) && (this.compositionPendingKey = !1, !0))
    }
    startMouseSelection(e) {
        this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e
    }
    update(e) {
        this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0)
    }
    destroy() {
        this.mouseSelection && this.mouseSelection.destroy()
    }
}

function bindHandler(e, t) {
    return (n, o) => {
        try {
            return t.call(e, o, n)
        } catch (e) {
            logException(n.state, e)
        }
    }
}

function computeHandlers(e) {
    let t = Object.create(null);

    function record(e) {
        return t[e] || (t[e] = {
            observers: [],
            handlers: []
        })
    }
    for (let t of e) {
        let e = t.spec;
        if (e && e.domEventHandlers)
            for (let n in e.domEventHandlers) {
                let o = e.domEventHandlers[n];
                o && record(n).handlers.push(bindHandler(t.value, o))
            }
        if (e && e.domEventObservers)
            for (let n in e.domEventObservers) {
                let o = e.domEventObservers[n];
                o && record(n).observers.push(bindHandler(t.value, o))
            }
    }
    for (let e in Je) record(e).handlers.push(Je[e]);
    for (let e in et) record(e).observers.push(et[e]);
    return t
}
const Ge = [{
        key: "Backspace",
        keyCode: 8,
        inputType: "deleteContentBackward"
    }, {
        key: "Enter",
        keyCode: 13,
        inputType: "insertParagraph"
    }, {
        key: "Enter",
        keyCode: 13,
        inputType: "insertLineBreak"
    }, {
        key: "Delete",
        keyCode: 46,
        inputType: "deleteContentForward"
    }],
    He = "dthko",
    Ke = [16, 17, 18, 20, 91, 92, 224, 225];

function dragScrollSpeed(e) {
    return .7 * Math.max(0, e) + 8
}
class MouseSelection {
    constructor(e, t, n, o) {
        this.view = e, this.startEvent = t, this.style = n, this.mustSelect = o, this.scrollSpeed = {
            x: 0,
            y: 0
        }, this.scrolling = -1, this.lastEvent = t, this.scrollParents = function(e) {
            let t, n, o = e.ownerDocument;
            for (let h = e.parentNode; h && !(h == o.body || t && n);)
                if (1 == h.nodeType) !n && h.scrollHeight > h.clientHeight && (n = h), !t && h.scrollWidth > h.clientWidth && (t = h), h = h.assignedSlot || h.parentNode;
                else {
                    if (11 != h.nodeType) break;
                    h = h.host
                }
            return {
                x: t,
                y: n
            }
        }(e.contentDOM), this.atoms = e.state.facet(Ne).map((t => t(e)));
        let h = e.contentDOM.ownerDocument;
        h.addEventListener("mousemove", this.move = this.move.bind(this)), h.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(EditorState.allowMultipleSelections) && function(e, t) {
            let n = e.state.facet(ke);
            return n.length ? n[0](t) : he.mac ? t.metaKey : t.ctrlKey
        }(e, t), this.dragging = !(! function(e, t) {
            let {
                main: n
            } = e.state.selection;
            if (n.empty) return !1;
            let o = getSelection(e.root);
            if (!o || 0 == o.rangeCount) return !0;
            let h = o.getRangeAt(0).getClientRects();
            for (let e = 0; e < h.length; e++) {
                let n = h[e];
                if (n.left <= t.clientX && n.right >= t.clientX && n.top <= t.clientY && n.bottom >= t.clientY) return !0
            }
            return !1
        }(e, t) || 1 != getClickType(t)) && null
    }
    start(e) {
        !1 === this.dragging && this.select(e)
    }
    move(e) {
        if (0 == e.buttons) return this.destroy();
        if (this.dragging || null == this.dragging && (t = this.startEvent, n = e, Math.max(Math.abs(t.clientX - n.clientX), Math.abs(t.clientY - n.clientY)) < 10)) return;
        var t, n;
        this.select(this.lastEvent = e);
        let o = 0,
            h = 0,
            p = 0,
            f = 0,
            g = this.view.win.innerWidth,
            y = this.view.win.innerHeight;
        this.scrollParents.x && ({
            left: p,
            right: g
        } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({
            top: f,
            bottom: y
        } = this.scrollParents.y.getBoundingClientRect());
        let w = getScrollMargins(this.view);
        e.clientX - w.left <= p + 6 ? o = -dragScrollSpeed(p - e.clientX) : e.clientX + w.right >= g - 6 && (o = dragScrollSpeed(e.clientX - g)), e.clientY - w.top <= f + 6 ? h = -dragScrollSpeed(f - e.clientY) : e.clientY + w.bottom >= y - 6 && (h = dragScrollSpeed(e.clientY - y)), this.setScrollSpeed(o, h)
    }
    up(e) {
        null == this.dragging && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy()
    }
    destroy() {
        this.setScrollSpeed(0, 0);
        let e = this.view.contentDOM.ownerDocument;
        e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null
    }
    setScrollSpeed(e, t) {
        this.scrollSpeed = {
            x: e,
            y: t
        }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval((() => this.scroll()), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1)
    }
    scroll() {
        let {
            x: e,
            y: t
        } = this.scrollSpeed;
        e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), t && this.scrollParents.y && (this.scrollParents.y.scrollTop += t, t = 0), (e || t) && this.view.win.scrollBy(e, t), !1 === this.dragging && this.select(this.lastEvent)
    }
    skipAtoms(e) {
        let t = null;
        for (let n = 0; n < e.ranges.length; n++) {
            let o = e.ranges[n],
                h = null;
            if (o.empty) {
                let e = skipAtomicRanges(this.atoms, o.from, 0);
                e != o.from && (h = EditorSelection.cursor(e, -1))
            } else {
                let e = skipAtomicRanges(this.atoms, o.from, -1),
                    t = skipAtomicRanges(this.atoms, o.to, 1);
                e == o.from && t == o.to || (h = EditorSelection.range(o.from == o.anchor ? e : t, o.from == o.head ? e : t))
            }
            h && (t || (t = e.ranges.slice()), t[n] = h)
        }
        return t ? EditorSelection.create(t, e.mainIndex) : e
    }
    select(e) {
        let {
            view: t
        } = this, n = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
        !this.mustSelect && n.eq(t.state.selection, !1 === this.dragging) || this.view.dispatch({
            selection: n,
            userEvent: "select.pointer"
        }), this.mustSelect = !1
    }
    update(e) {
        e.transactions.some((e => e.isUserEvent("input.type"))) ? this.destroy() : this.style.update(e) && setTimeout((() => this.select(this.lastEvent)), 20)
    }
}
const Je = Object.create(null),
    et = Object.create(null),
    tt = he.ie && he.ie_version < 15 || he.ios && he.webkit_version < 604;

function textFilter(e, t, n) {
    for (let o of e.facet(t)) n = o(n, e);
    return n
}

function doPaste(e, t) {
    t = textFilter(e.state, Ee, t);
    let n, {
            state: o
        } = e,
        h = 1,
        p = o.toText(t),
        f = p.lines == o.selection.ranges.length;
    if (null != st && o.selection.ranges.every((e => e.empty)) && st == p.toString()) {
        let e = -1;
        n = o.changeByRange((n => {
            let g = o.doc.lineAt(n.from);
            if (g.from == e) return {
                range: n
            };
            e = g.from;
            let y = o.toText((f ? p.line(h++).text : t) + o.lineBreak);
            return {
                changes: {
                    from: g.from,
                    insert: y
                },
                range: EditorSelection.cursor(n.from + y.length)
            }
        }))
    } else n = f ? o.changeByRange((e => {
        let t = p.line(h++);
        return {
            changes: {
                from: e.from,
                to: e.to,
                insert: t.text
            },
            range: EditorSelection.cursor(e.from + t.length)
        }
    })) : o.replaceSelection(p);
    e.dispatch(n, {
        userEvent: "input.paste",
        scrollIntoView: !0
    })
}

function rangeForClick(e, t, n, o) {
    if (1 == o) return EditorSelection.cursor(t, n);
    if (2 == o) return function(e, t, n = 1) {
        let o = e.charCategorizer(t),
            h = e.doc.lineAt(t),
            p = t - h.from;
        if (0 == h.length) return EditorSelection.cursor(t);
        0 == p ? n = 1 : p == h.length && (n = -1);
        let f = p,
            g = p;
        n < 0 ? f = findClusterBreak(h.text, p, !1) : g = findClusterBreak(h.text, p);
        let y = o(h.text.slice(f, g));
        for (; f > 0;) {
            let e = findClusterBreak(h.text, f, !1);
            if (o(h.text.slice(e, f)) != y) break;
            f = e
        }
        for (; g < h.length;) {
            let e = findClusterBreak(h.text, g);
            if (o(h.text.slice(g, e)) != y) break;
            g = e
        }
        return EditorSelection.range(f + h.from, g + h.from)
    }(e.state, t, n); {
        let n = LineView.find(e.docView, t),
            o = e.state.doc.lineAt(n ? n.posAtEnd : t),
            h = n ? n.posAtStart : o.from,
            p = n ? n.posAtEnd : o.to;
        return p < e.state.doc.length && p == o.to && p++, EditorSelection.range(h, p)
    }
}
et.scroll = e => {
    e.inputState.lastScrollTop = e.scrollDOM.scrollTop, e.inputState.lastScrollLeft = e.scrollDOM.scrollLeft
}, Je.keydown = (e, t) => (e.inputState.setSelectionOrigin("select"), 27 == t.keyCode && 0 != e.inputState.tabFocusMode && (e.inputState.tabFocusMode = Date.now() + 2e3), !1), et.touchstart = (e, t) => {
    e.inputState.lastTouchTime = Date.now(), e.inputState.setSelectionOrigin("select.pointer")
}, et.touchmove = e => {
    e.inputState.setSelectionOrigin("select.pointer")
}, Je.mousedown = (e, t) => {
    if (e.observer.flush(), e.inputState.lastTouchTime > Date.now() - 2e3) return !1;
    let n = null;
    for (let o of e.state.facet(Pe))
        if (n = o(e, t), n) break;
    if (n || 0 != t.button || (n = function(e, t) {
            let n = queryPos(e, t),
                o = getClickType(t),
                h = e.state.selection;
            return {
                update(e) {
                    e.docChanged && (n.pos = e.changes.mapPos(n.pos), h = h.map(e.changes))
                },
                get(t, p, f) {
                    let g, y = queryPos(e, t),
                        w = rangeForClick(e, y.pos, y.bias, o);
                    if (n.pos != y.pos && !p) {
                        let t = rangeForClick(e, n.pos, n.bias, o),
                            h = Math.min(t.from, w.from),
                            p = Math.max(t.to, w.to);
                        w = h < w.from ? EditorSelection.range(h, p) : EditorSelection.range(p, h)
                    }
                    return p ? h.replaceRange(h.main.extend(w.from, w.to)) : f && 1 == o && h.ranges.length > 1 && (g = function(e, t) {
                        for (let n = 0; n < e.ranges.length; n++) {
                            let {
                                from: o,
                                to: h
                            } = e.ranges[n];
                            if (o <= t && h >= t) return EditorSelection.create(e.ranges.slice(0, n).concat(e.ranges.slice(n + 1)), e.mainIndex == n ? 0 : e.mainIndex - (e.mainIndex > n ? 1 : 0))
                        }
                        return null
                    }(h, y.pos)) ? g : f ? h.addRange(w) : EditorSelection.create([w])
                }
            }
        }(e, t)), n) {
        let o = !e.hasFocus;
        e.inputState.startMouseSelection(new MouseSelection(e, t, n, o)), o && e.observer.ignore((() => {
            focusPreventScroll(e.contentDOM);
            let t = e.root.activeElement;
            t && !t.contains(e.contentDOM) && t.blur()
        }));
        let h = e.inputState.mouseSelection;
        if (h) return h.start(t), !1 === h.dragging
    }
    return !1
};
let inside = (e, t, n) => t >= n.top && t <= n.bottom && e >= n.left && e <= n.right;

function findPositionSide(e, t, n, o) {
    let h = LineView.find(e.docView, t);
    if (!h) return 1;
    let p = t - h.posAtStart;
    if (0 == p) return 1;
    if (p == h.length) return -1;
    let f = h.coordsAt(p, -1);
    if (f && inside(n, o, f)) return -1;
    let g = h.coordsAt(p, 1);
    return g && inside(n, o, g) ? 1 : f && f.bottom >= o ? -1 : 1
}

function queryPos(e, t) {
    let n = e.posAtCoords({
        x: t.clientX,
        y: t.clientY
    }, !1);
    return {
        pos: n,
        bias: findPositionSide(e, n, t.clientX, t.clientY)
    }
}
const nt = he.ie && he.ie_version <= 11;
let it = null,
    rt = 0,
    ot = 0;

function getClickType(e) {
    if (!nt) return e.detail;
    let t = it,
        n = ot;
    return it = e, ot = Date.now(), rt = !t || n > Date.now() - 400 && Math.abs(t.clientX - e.clientX) < 2 && Math.abs(t.clientY - e.clientY) < 2 ? (rt + 1) % 3 : 1
}

function dropText(e, t, n, o) {
    if (!(n = textFilter(e.state, Ee, n))) return;
    let h = e.posAtCoords({
            x: t.clientX,
            y: t.clientY
        }, !1),
        {
            draggedContent: p
        } = e.inputState,
        f = o && p && function(e, t) {
            let n = e.state.facet(ve);
            return n.length ? n[0](t) : he.mac ? !t.altKey : !t.ctrlKey
        }(e, t) ? {
            from: p.from,
            to: p.to
        } : null,
        g = {
            from: h,
            insert: n
        },
        y = e.state.changes(f ? [f, g] : g);
    e.focus(), e.dispatch({
        changes: y,
        selection: {
            anchor: y.mapPos(h, -1),
            head: y.mapPos(h, 1)
        },
        userEvent: f ? "move.drop" : "input.drop"
    }), e.inputState.draggedContent = null
}
Je.dragstart = (e, t) => {
    let {
        selection: {
            main: n
        }
    } = e.state;
    if (t.target.draggable) {
        let o = e.docView.nearest(t.target);
        if (o && o.isWidget) {
            let e = o.posAtStart,
                t = e + o.length;
            (e >= n.to || t <= n.from) && (n = EditorSelection.range(e, t))
        }
    }
    let {
        inputState: o
    } = e;
    return o.mouseSelection && (o.mouseSelection.dragging = !0), o.draggedContent = n, t.dataTransfer && (t.dataTransfer.setData("Text", textFilter(e.state, Ae, e.state.sliceDoc(n.from, n.to))), t.dataTransfer.effectAllowed = "copyMove"), !1
}, Je.dragend = e => (e.inputState.draggedContent = null, !1), Je.drop = (e, t) => {
    if (!t.dataTransfer) return !1;
    if (e.state.readOnly) return !0;
    let n = t.dataTransfer.files;
    if (n && n.length) {
        let o = Array(n.length),
            h = 0,
            finishFile = () => {
                ++h == n.length && dropText(e, t, o.filter((e => null != e)).join(e.state.lineBreak), !1)
            };
        for (let e = 0; e < n.length; e++) {
            let t = new FileReader;
            t.onerror = finishFile, t.onload = () => {
                /[\x00-\x08\x0e-\x1f]{2}/.test(t.result) || (o[e] = t.result), finishFile()
            }, t.readAsText(n[e])
        }
        return !0
    } {
        let n = t.dataTransfer.getData("Text");
        if (n) return dropText(e, t, n, !0), !0
    }
    return !1
}, Je.paste = (e, t) => {
    if (e.state.readOnly) return !0;
    e.observer.flush();
    let n = tt ? null : t.clipboardData;
    return n ? (doPaste(e, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (function(e) {
        let t = e.dom.parentNode;
        if (!t) return;
        let n = t.appendChild(document.createElement("textarea"));
        n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout((() => {
            e.focus(), n.remove(), doPaste(e, n.value)
        }), 50)
    }(e), !1)
};
let st = null;
Je.copy = Je.cut = (e, t) => {
    let {
        text: n,
        ranges: o,
        linewise: h
    } = function(e) {
        let t = [],
            n = [],
            o = !1;
        for (let o of e.selection.ranges) o.empty || (t.push(e.sliceDoc(o.from, o.to)), n.push(o));
        if (!t.length) {
            let h = -1;
            for (let {
                    from: o
                } of e.selection.ranges) {
                let p = e.doc.lineAt(o);
                p.number > h && (t.push(p.text), n.push({
                    from: p.from,
                    to: Math.min(e.doc.length, p.to + 1)
                })), h = p.number
            }
            o = !0
        }
        return {
            text: textFilter(e, Ae, t.join(e.lineBreak)),
            ranges: n,
            linewise: o
        }
    }(e.state);
    if (!n && !h) return !1;
    st = h ? n : null, "cut" != t.type || e.state.readOnly || e.dispatch({
        changes: o,
        scrollIntoView: !0,
        userEvent: "delete.cut"
    });
    let p = tt ? null : t.clipboardData;
    return p ? (p.clearData(), p.setData("text/plain", n), !0) : (function(e, t) {
        let n = e.dom.parentNode;
        if (!n) return;
        let o = n.appendChild(document.createElement("textarea"));
        o.style.cssText = "position: fixed; left: -10000px; top: 10px", o.value = t, o.focus(), o.selectionEnd = t.length, o.selectionStart = 0, setTimeout((() => {
            o.remove(), e.focus()
        }), 50)
    }(e, n), !1)
};
const at = Annotation.define();

function focusChangeTransaction(e, t) {
    let n = [];
    for (let o of e.facet($e)) {
        let h = o(e, t);
        h && n.push(h)
    }
    return n ? e.update({
        effects: n,
        annotations: at.of(!0)
    }) : null
}

function updateForFocusChange(e) {
    setTimeout((() => {
        let t = e.hasFocus;
        if (t != e.inputState.notifiedFocused) {
            let n = focusChangeTransaction(e.state, t);
            n ? e.dispatch(n) : e.update([])
        }
    }), 10)
}
et.focus = e => {
    e.inputState.lastFocusTime = Date.now(), e.scrollDOM.scrollTop || !e.inputState.lastScrollTop && !e.inputState.lastScrollLeft || (e.scrollDOM.scrollTop = e.inputState.lastScrollTop, e.scrollDOM.scrollLeft = e.inputState.lastScrollLeft), updateForFocusChange(e)
}, et.blur = e => {
    e.observer.clearSelectionRange(), updateForFocusChange(e)
}, et.compositionstart = et.compositionupdate = e => {
    e.observer.editContext || (null == e.inputState.compositionFirstChange && (e.inputState.compositionFirstChange = !0), e.inputState.composing < 0 && (e.inputState.composing = 0))
}, et.compositionend = e => {
    e.observer.editContext || (e.inputState.composing = -1, e.inputState.compositionEndedAt = Date.now(), e.inputState.compositionPendingKey = !0, e.inputState.compositionPendingChange = e.observer.pendingRecords().length > 0, e.inputState.compositionFirstChange = null, he.chrome && he.android ? e.observer.flushSoon() : e.inputState.compositionPendingChange ? Promise.resolve().then((() => e.observer.flush())) : setTimeout((() => {
        e.inputState.composing < 0 && e.docView.hasComposition && e.update([])
    }), 50))
}, et.contextmenu = e => {
    e.inputState.lastContextMenu = Date.now()
}, Je.beforeinput = (e, t) => {
    var n, o;
    if ("insertReplacementText" == t.inputType && e.observer.editContext) {
        let o = null === (n = t.dataTransfer) || void 0 === n ? void 0 : n.getData("text/plain"),
            h = t.getTargetRanges();
        if (o && h.length) {
            let t = h[0],
                n = e.posAtDOM(t.startContainer, t.startOffset),
                p = e.posAtDOM(t.endContainer, t.endOffset);
            return applyDOMChangeInner(e, {
                from: n,
                to: p,
                insert: e.state.toText(o)
            }, null), !0
        }
    }
    let h;
    if (he.chrome && he.android && (h = Ge.find((e => e.inputType == t.inputType))) && (e.observer.delayAndroidKey(h.key, h.keyCode), "Backspace" == h.key || "Delete" == h.key)) {
        let t = (null === (o = window.visualViewport) || void 0 === o ? void 0 : o.height) || 0;
        setTimeout((() => {
            var n;
            ((null === (n = window.visualViewport) || void 0 === n ? void 0 : n.height) || 0) > t + 10 && e.hasFocus && (e.contentDOM.blur(), e.focus())
        }), 100)
    }
    return he.ios && "deleteContentForward" == t.inputType && e.observer.flushSoon(), he.safari && "insertText" == t.inputType && e.inputState.composing >= 0 && setTimeout((() => et.compositionend(e, t)), 20), !1
};
const lt = new Set;
const ct = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let ht = !1;

function clearHeightChangeFlag() {
    ht = !1
}
class HeightOracle {
    constructor(e) {
        this.lineWrapping = e, this.doc = Text.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30
    }
    heightForGap(e, t) {
        let n = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
        return this.lineWrapping && (n += Math.max(0, Math.ceil((t - e - n * this.lineLength * .5) / this.lineLength))), this.lineHeight * n
    }
    heightForLine(e) {
        if (!this.lineWrapping) return this.lineHeight;
        return (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight
    }
    setDoc(e) {
        return this.doc = e, this
    }
    mustRefreshForWrapping(e) {
        return ct.indexOf(e) > -1 != this.lineWrapping
    }
    mustRefreshForHeights(e) {
        let t = !1;
        for (let n = 0; n < e.length; n++) {
            let o = e[n];
            o < 0 ? n++ : this.heightSamples[Math.floor(10 * o)] || (t = !0, this.heightSamples[Math.floor(10 * o)] = !0)
        }
        return t
    }
    refresh(e, t, n, o, h, p) {
        let f = ct.indexOf(e) > -1,
            g = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != f;
        if (this.lineWrapping = f, this.lineHeight = t, this.charWidth = n, this.textHeight = o, this.lineLength = h, g) {
            this.heightSamples = {};
            for (let e = 0; e < p.length; e++) {
                let t = p[e];
                t < 0 ? e++ : this.heightSamples[Math.floor(10 * t)] = !0
            }
        }
        return g
    }
}
class MeasuredHeights {
    constructor(e, t) {
        this.from = e, this.heights = t, this.index = 0
    }
    get more() {
        return this.index < this.heights.length
    }
}
class BlockInfo {
    constructor(e, t, n, o, h) {
        this.from = e, this.length = t, this.top = n, this.height = o, this._content = h
    }
    get type() {
        return "number" == typeof this._content ? ue.Text : Array.isArray(this._content) ? this._content : this._content.type
    }
    get to() {
        return this.from + this.length
    }
    get bottom() {
        return this.top + this.height
    }
    get widget() {
        return this._content instanceof PointDecoration ? this._content.widget : null
    }
    get widgetLineBreaks() {
        return "number" == typeof this._content ? this._content : 0
    }
    join(e) {
        let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
        return new BlockInfo(this.from, this.length + e.length, this.top, this.height + e.height, t)
    }
}
var dt = function(e) {
    return e[e.ByPos = 0] = "ByPos", e[e.ByHeight = 1] = "ByHeight", e[e.ByPosNoHeight = 2] = "ByPosNoHeight", e
}(dt || (dt = {}));
const ut = .001;
class HeightMap {
    constructor(e, t, n = 2) {
        this.length = e, this.height = t, this.flags = n
    }
    get outdated() {
        return (2 & this.flags) > 0
    }
    set outdated(e) {
        this.flags = (e ? 2 : 0) | -3 & this.flags
    }
    setHeight(e) {
        this.height != e && (Math.abs(this.height - e) > ut && (ht = !0), this.height = e)
    }
    replace(e, t, n) {
        return HeightMap.of(n)
    }
    decomposeLeft(e, t) {
        t.push(this)
    }
    decomposeRight(e, t) {
        t.push(this)
    }
    applyChanges(e, t, n, o) {
        let h = this,
            p = n.doc;
        for (let f = o.length - 1; f >= 0; f--) {
            let {
                fromA: g,
                toA: y,
                fromB: w,
                toB: b
            } = o[f], S = h.lineAt(g, dt.ByPosNoHeight, n.setDoc(t), 0, 0), k = S.to >= y ? S : h.lineAt(y, dt.ByPosNoHeight, n, 0, 0);
            for (b += k.to - y, y = k.to; f > 0 && S.from <= o[f - 1].toA;) g = o[f - 1].fromA, w = o[f - 1].fromB, f--, g < S.from && (S = h.lineAt(g, dt.ByPosNoHeight, n, 0, 0));
            w += S.from - g, g = S.from;
            let v = NodeBuilder.build(n.setDoc(p), e, w, b);
            h = replace(h, h.replace(g, y, v))
        }
        return h.updateHeight(n, 0)
    }
    static empty() {
        return new HeightMapText(0, 0)
    }
    static of (e) {
        if (1 == e.length) return e[0];
        let t = 0,
            n = e.length,
            o = 0,
            h = 0;
        for (;;)
            if (t == n)
                if (o > 2 * h) {
                    let h = e[t - 1];
                    h.break ? e.splice(--t, 1, h.left, null, h.right) : e.splice(--t, 1, h.left, h.right), n += 1 + h.break, o -= h.size
                } else {
                    if (!(h > 2 * o)) break; {
                        let t = e[n];
                        t.break ? e.splice(n, 1, t.left, null, t.right) : e.splice(n, 1, t.left, t.right), n += 2 + t.break, h -= t.size
                    }
                }
        else if (o < h) {
            let n = e[t++];
            n && (o += n.size)
        } else {
            let t = e[--n];
            t && (h += t.size)
        }
        let p = 0;
        return null == e[t - 1] ? (p = 1, t--) : null == e[t] && (p = 1, n++), new HeightMapBranch(HeightMap.of(e.slice(0, t)), p, HeightMap.of(e.slice(n)))
    }
}

function replace(e, t) {
    return e == t ? e : (e.constructor != t.constructor && (ht = !0), t)
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
    constructor(e, t, n) {
        super(e, t), this.deco = n
    }
    blockAt(e, t, n, o) {
        return new BlockInfo(o, this.length, n, this.height, this.deco || 0)
    }
    lineAt(e, t, n, o, h) {
        return this.blockAt(0, n, o, h)
    }
    forEachLine(e, t, n, o, h, p) {
        e <= h + this.length && t >= h && p(this.blockAt(0, n, o, h))
    }
    updateHeight(e, t = 0, n = !1, o) {
        return o && o.from <= t && o.more && this.setHeight(o.heights[o.index++]), this.outdated = !1, this
    }
    toString() {
        return `block(${this.length})`
    }
}
class HeightMapText extends HeightMapBlock {
    constructor(e, t) {
        super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0
    }
    blockAt(e, t, n, o) {
        return new BlockInfo(o, this.length, n, this.height, this.breaks)
    }
    replace(e, t, n) {
        let o = n[0];
        return 1 == n.length && (o instanceof HeightMapText || o instanceof HeightMapGap && 4 & o.flags) && Math.abs(this.length - o.length) < 10 ? (o instanceof HeightMapGap ? o = new HeightMapText(o.length, this.height) : o.height = this.height, this.outdated || (o.outdated = !1), o) : HeightMap.of(n)
    }
    updateHeight(e, t = 0, n = !1, o) {
        return o && o.from <= t && o.more ? this.setHeight(o.heights[o.index++]) : (n || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this
    }
    toString() {
        return `line(${this.length}${this.collapsed?-this.collapsed:""}${this.widgetHeight?":"+this.widgetHeight:""})`
    }
}
class HeightMapGap extends HeightMap {
    constructor(e) {
        super(e, 0)
    }
    heightMetrics(e, t) {
        let n, o = e.doc.lineAt(t).number,
            h = e.doc.lineAt(t + this.length).number,
            p = h - o + 1,
            f = 0;
        if (e.lineWrapping) {
            let t = Math.min(this.height, e.lineHeight * p);
            n = t / p, this.length > p + 1 && (f = (this.height - t) / (this.length - p - 1))
        } else n = this.height / p;
        return {
            firstLine: o,
            lastLine: h,
            perLine: n,
            perChar: f
        }
    }
    blockAt(e, t, n, o) {
        let {
            firstLine: h,
            lastLine: p,
            perLine: f,
            perChar: g
        } = this.heightMetrics(t, o);
        if (t.lineWrapping) {
            let h = o + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length)),
                p = t.doc.lineAt(h),
                y = f + p.length * g,
                w = Math.max(n, e - y / 2);
            return new BlockInfo(p.from, p.length, w, y, 0)
        } {
            let o = Math.max(0, Math.min(p - h, Math.floor((e - n) / f))),
                {
                    from: g,
                    length: y
                } = t.doc.line(h + o);
            return new BlockInfo(g, y, n + f * o, f, 0)
        }
    }
    lineAt(e, t, n, o, h) {
        if (t == dt.ByHeight) return this.blockAt(e, n, o, h);
        if (t == dt.ByPosNoHeight) {
            let {
                from: t,
                to: o
            } = n.doc.lineAt(e);
            return new BlockInfo(t, o - t, 0, 0, 0)
        }
        let {
            firstLine: p,
            perLine: f,
            perChar: g
        } = this.heightMetrics(n, h), y = n.doc.lineAt(e), w = f + y.length * g, b = y.number - p, S = o + f * b + g * (y.from - h - b);
        return new BlockInfo(y.from, y.length, Math.max(o, Math.min(S, o + this.height - w)), w, 0)
    }
    forEachLine(e, t, n, o, h, p) {
        e = Math.max(e, h), t = Math.min(t, h + this.length);
        let {
            firstLine: f,
            perLine: g,
            perChar: y
        } = this.heightMetrics(n, h);
        for (let w = e, b = o; w <= t;) {
            let t = n.doc.lineAt(w);
            if (w == e) {
                let n = t.number - f;
                b += g * n + y * (e - h - n)
            }
            let o = g + y * t.length;
            p(new BlockInfo(t.from, t.length, b, o, 0)), b += o, w = t.to + 1
        }
    }
    replace(e, t, n) {
        let o = this.length - t;
        if (o > 0) {
            let e = n[n.length - 1];
            e instanceof HeightMapGap ? n[n.length - 1] = new HeightMapGap(e.length + o) : n.push(null, new HeightMapGap(o - 1))
        }
        if (e > 0) {
            let t = n[0];
            t instanceof HeightMapGap ? n[0] = new HeightMapGap(e + t.length) : n.unshift(new HeightMapGap(e - 1), null)
        }
        return HeightMap.of(n)
    }
    decomposeLeft(e, t) {
        t.push(new HeightMapGap(e - 1), null)
    }
    decomposeRight(e, t) {
        t.push(null, new HeightMapGap(this.length - e - 1))
    }
    updateHeight(e, t = 0, n = !1, o) {
        let h = t + this.length;
        if (o && o.from <= t + this.length && o.more) {
            let n = [],
                p = Math.max(t, o.from),
                f = -1;
            for (o.from > t && n.push(new HeightMapGap(o.from - t - 1).updateHeight(e, t)); p <= h && o.more;) {
                let t = e.doc.lineAt(p).length;
                n.length && n.push(null);
                let h = o.heights[o.index++]; - 1 == f ? f = h : Math.abs(h - f) >= ut && (f = -2);
                let g = new HeightMapText(t, h);
                g.outdated = !1, n.push(g), p += t + 1
            }
            p <= h && n.push(null, new HeightMapGap(h - p).updateHeight(e, p));
            let g = HeightMap.of(n);
            return (f < 0 || Math.abs(g.height - this.height) >= ut || Math.abs(f - this.heightMetrics(e, t).perLine) >= ut) && (ht = !0), replace(this, g)
        }
        return (n || this.outdated) && (this.setHeight(e.heightForGap(t, t + this.length)), this.outdated = !1), this
    }
    toString() {
        return `gap(${this.length})`
    }
}
class HeightMapBranch extends HeightMap {
    constructor(e, t, n) {
        super(e.length + t + n.length, e.height + n.height, t | (e.outdated || n.outdated ? 2 : 0)), this.left = e, this.right = n, this.size = e.size + n.size
    }
    get break() {
        return 1 & this.flags
    }
    blockAt(e, t, n, o) {
        let h = n + this.left.height;
        return e < h ? this.left.blockAt(e, t, n, o) : this.right.blockAt(e, t, h, o + this.left.length + this.break)
    }
    lineAt(e, t, n, o, h) {
        let p = o + this.left.height,
            f = h + this.left.length + this.break,
            g = t == dt.ByHeight ? e < p : e < f,
            y = g ? this.left.lineAt(e, t, n, o, h) : this.right.lineAt(e, t, n, p, f);
        if (this.break || (g ? y.to < f : y.from > f)) return y;
        let w = t == dt.ByPosNoHeight ? dt.ByPosNoHeight : dt.ByPos;
        return g ? y.join(this.right.lineAt(f, w, n, p, f)) : this.left.lineAt(f, w, n, o, h).join(y)
    }
    forEachLine(e, t, n, o, h, p) {
        let f = o + this.left.height,
            g = h + this.left.length + this.break;
        if (this.break) e < g && this.left.forEachLine(e, t, n, o, h, p), t >= g && this.right.forEachLine(e, t, n, f, g, p);
        else {
            let y = this.lineAt(g, dt.ByPos, n, o, h);
            e < y.from && this.left.forEachLine(e, y.from - 1, n, o, h, p), y.to >= e && y.from <= t && p(y), t > y.to && this.right.forEachLine(y.to + 1, t, n, f, g, p)
        }
    }
    replace(e, t, n) {
        let o = this.left.length + this.break;
        if (t < o) return this.balanced(this.left.replace(e, t, n), this.right);
        if (e > this.left.length) return this.balanced(this.left, this.right.replace(e - o, t - o, n));
        let h = [];
        e > 0 && this.decomposeLeft(e, h);
        let p = h.length;
        for (let e of n) h.push(e);
        if (e > 0 && mergeGaps(h, p - 1), t < this.length) {
            let e = h.length;
            this.decomposeRight(t, h), mergeGaps(h, e)
        }
        return HeightMap.of(h)
    }
    decomposeLeft(e, t) {
        let n = this.left.length;
        if (e <= n) return this.left.decomposeLeft(e, t);
        t.push(this.left), this.break && (n++, e >= n && t.push(null)), e > n && this.right.decomposeLeft(e - n, t)
    }
    decomposeRight(e, t) {
        let n = this.left.length,
            o = n + this.break;
        if (e >= o) return this.right.decomposeRight(e - o, t);
        e < n && this.left.decomposeRight(e, t), this.break && e < o && t.push(null), t.push(this.right)
    }
    balanced(e, t) {
        return e.size > 2 * t.size || t.size > 2 * e.size ? HeightMap.of(this.break ? [e, null, t] : [e, t]) : (this.left = replace(this.left, e), this.right = replace(this.right, t), this.setHeight(e.height + t.height), this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break+t.length, this)
    }
    updateHeight(e, t = 0, n = !1, o) {
        let {
            left: h,
            right: p
        } = this, f = t + h.length + this.break, g = null;
        return o && o.from <= t + h.length && o.more ? g = h = h.updateHeight(e, t, n, o) : h.updateHeight(e, t, n), o && o.from <= f + p.length && o.more ? g = p = p.updateHeight(e, f, n, o) : p.updateHeight(e, f, n), g ? this.balanced(h, p) : (this.height = this.left.height + this.right.height, this.outdated = !1, this)
    }
    toString() {
        return this.left + (this.break ? " " : "-") + this.right
    }
}

function mergeGaps(e, t) {
    let n, o;
    null == e[t] && (n = e[t - 1]) instanceof HeightMapGap && (o = e[t + 1]) instanceof HeightMapGap && e.splice(t - 1, 3, new HeightMapGap(n.length + 1 + o.length))
}
class NodeBuilder {
    constructor(e, t) {
        this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e
    }
    get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering
    }
    span(e, t) {
        if (this.lineStart > -1) {
            let e = Math.min(t, this.lineEnd),
                n = this.nodes[this.nodes.length - 1];
            n instanceof HeightMapText ? n.length += e - this.pos : (e > this.pos || !this.isCovered) && this.nodes.push(new HeightMapText(e - this.pos, -1)), this.writtenTo = e, t > e && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1)
        }
        this.pos = t
    }
    point(e, t, n) {
        if (e < t || n.heightRelevant) {
            let o = n.widget ? n.widget.estimatedHeight : 0,
                h = n.widget ? n.widget.lineBreaks : 0;
            o < 0 && (o = this.oracle.lineHeight);
            let p = t - e;
            n.block ? this.addBlock(new HeightMapBlock(p, o, n)) : (p || h || o >= 5) && this.addLineDeco(o, h, p)
        } else t > e && this.span(e, t);
        this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to)
    }
    enterLine() {
        if (this.lineStart > -1) return;
        let {
            from: e,
            to: t
        } = this.oracle.doc.lineAt(this.pos);
        this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || null == this.nodes[this.nodes.length - 1]) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new HeightMapText(this.pos - e, -1)), this.writtenTo = this.pos
    }
    blankContent(e, t) {
        let n = new HeightMapGap(t - e);
        return this.oracle.doc.lineAt(e).to == t && (n.flags |= 4), n
    }
    ensureLine() {
        this.enterLine();
        let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (e instanceof HeightMapText) return e;
        let t = new HeightMapText(0, -1);
        return this.nodes.push(t), t
    }
    addBlock(e) {
        this.enterLine();
        let t = e.deco;
        t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e)
    }
    addLineDeco(e, t, n) {
        let o = this.ensureLine();
        o.length += n, o.collapsed += n, o.widgetHeight = Math.max(o.widgetHeight, e), o.breaks += t, this.writtenTo = this.pos = this.pos + n
    }
    finish(e) {
        let t = 0 == this.nodes.length ? null : this.nodes[this.nodes.length - 1];
        !(this.lineStart > -1) || t instanceof HeightMapText || this.isCovered ? (this.writtenTo < this.pos || null == t) && this.nodes.push(this.blankContent(this.writtenTo, this.pos)) : this.nodes.push(new HeightMapText(0, -1));
        let n = e;
        for (let e of this.nodes) e instanceof HeightMapText && e.updateHeight(this.oracle, n), n += e ? e.length : 1;
        return this.nodes
    }
    static build(e, t, n, o) {
        let h = new NodeBuilder(n, e);
        return RangeSet.spans(t, n, o, h, 0), h.finish(n)
    }
}
class DecorationComparator {
    constructor() {
        this.changes = []
    }
    compareRange() {}
    comparePoint(e, t, n, o) {
        (e < t || n && n.heightRelevant || o && o.heightRelevant) && addRange(e, t, this.changes, 5)
    }
}

function visiblePixelRange(e, t) {
    let n = e.getBoundingClientRect(),
        o = e.ownerDocument,
        h = o.defaultView || window,
        p = Math.max(0, n.left),
        f = Math.min(h.innerWidth, n.right),
        g = Math.max(0, n.top),
        y = Math.min(h.innerHeight, n.bottom);
    for (let t = e.parentNode; t && t != o.body;)
        if (1 == t.nodeType) {
            let n = t,
                o = window.getComputedStyle(n);
            if ((n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth) && "visible" != o.overflow) {
                let o = n.getBoundingClientRect();
                p = Math.max(p, o.left), f = Math.min(f, o.right), g = Math.max(g, o.top), y = Math.min(t == e.parentNode ? h.innerHeight : y, o.bottom)
            }
            t = "absolute" == o.position || "fixed" == o.position ? n.offsetParent : n.parentNode
        } else {
            if (11 != t.nodeType) break;
            t = t.host
        }
    return {
        left: p - n.left,
        right: Math.max(p, f) - n.left,
        top: g - (n.top + t),
        bottom: Math.max(g, y) - (n.top + t)
    }
}

function fullPixelRange(e, t) {
    let n = e.getBoundingClientRect();
    return {
        left: 0,
        right: n.right - n.left,
        top: t,
        bottom: n.bottom - (n.top + t)
    }
}
class LineGap {
    constructor(e, t, n, o) {
        this.from = e, this.to = t, this.size = n, this.displaySize = o
    }
    static same(e, t) {
        if (e.length != t.length) return !1;
        for (let n = 0; n < e.length; n++) {
            let o = e[n],
                h = t[n];
            if (o.from != h.from || o.to != h.to || o.size != h.size) return !1
        }
        return !0
    }
    draw(e, t) {
        return Decoration.replace({
            widget: new LineGapWidget(this.displaySize * (t ? e.scaleY : e.scaleX), t)
        }).range(this.from, this.to)
    }
}
class LineGapWidget extends WidgetType {
    constructor(e, t) {
        super(), this.size = e, this.vertical = t
    }
    eq(e) {
        return e.size == this.size && e.vertical == this.vertical
    }
    toDOM() {
        let e = document.createElement("div");
        return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e
    }
    get estimatedHeight() {
        return this.vertical ? this.size : -1
    }
}
class ViewState {
    constructor(e) {
        this.state = e, this.pixelViewport = {
            left: 0,
            right: window.innerWidth,
            top: 0,
            bottom: 0
        }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = pt, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = pe.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
        let t = e.facet(Xe).some((e => "function" != typeof e && "cm-lineWrapping" == e.class));
        this.heightOracle = new HeightOracle(t), this.stateDeco = e.facet(qe).filter((e => "function" != typeof e)), this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(e.doc), [new ChangedRange(0, 0, 0, e.doc.length)]);
        for (let e = 0; e < 2 && (this.viewport = this.getViewport(0, null), this.updateForViewport()); e++);
        this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Decoration.set(this.lineGaps.map((e => e.draw(this, !1)))), this.computeVisibleRanges()
    }
    updateForViewport() {
        let e = [this.viewport],
            {
                main: t
            } = this.state.selection;
        for (let n = 0; n <= 1; n++) {
            let o = n ? t.head : t.anchor;
            if (!e.some((({
                    from: e,
                    to: t
                }) => o >= e && o <= t))) {
                let {
                    from: t,
                    to: n
                } = this.lineBlockAt(o);
                e.push(new Viewport(t, n))
            }
        }
        return this.viewports = e.sort(((e, t) => e.from - t.from)), this.updateScaler()
    }
    updateScaler() {
        let e = this.scaler;
        return this.scaler = this.heightMap.height <= 7e6 ? pt : new BigScaler(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2
    }
    updateViewportLines() {
        this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e => {
            this.viewportLines.push(scaleBlock(e, this.scaler))
        }))
    }
    update(e, t = null) {
        this.state = e.state;
        let n = this.stateDeco;
        this.stateDeco = this.state.facet(qe).filter((e => "function" != typeof e));
        let o = e.changedRanges,
            h = ChangedRange.extendWithRanges(o, function(e, t, n) {
                let o = new DecorationComparator;
                return RangeSet.compare(e, t, n, o, 0), o.changes
            }(n, this.stateDeco, e ? e.changes : ChangeSet.empty(this.state.doc.length))),
            p = this.heightMap.height,
            f = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
        clearHeightChangeFlag(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), h), (this.heightMap.height != p || ht) && (e.flags |= 2), f ? (this.scrollAnchorPos = e.changes.mapPos(f.from, -1), this.scrollAnchorHeight = f.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
        let g = h.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
        (t && (t.range.head < g.from || t.range.head > g.to) || !this.viewportIsAppropriate(g)) && (g = this.getViewport(0, t));
        let y = g.from != this.viewport.from || g.to != this.viewport.to;
        this.viewport = g, e.flags |= this.updateForViewport(), (y || !e.changes.empty || 2 & e.flags) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(Re) && (this.mustEnforceCursorAssoc = !0)
    }
    measure(e) {
        let t = e.contentDOM,
            n = window.getComputedStyle(t),
            o = this.heightOracle,
            h = n.whiteSpace;
        this.defaultTextDirection = "rtl" == n.direction ? pe.RTL : pe.LTR;
        let p = this.heightOracle.mustRefreshForWrapping(h),
            f = t.getBoundingClientRect(),
            g = p || this.mustMeasureContent || this.contentDOMHeight != f.height;
        this.contentDOMHeight = f.height, this.mustMeasureContent = !1;
        let y = 0,
            w = 0;
        if (f.width && f.height) {
            let {
                scaleX: e,
                scaleY: n
            } = getScale(t, f);
            (e > .005 && Math.abs(this.scaleX - e) > .005 || n > .005 && Math.abs(this.scaleY - n) > .005) && (this.scaleX = e, this.scaleY = n, y |= 8, p = g = !0)
        }
        let b = (parseInt(n.paddingTop) || 0) * this.scaleY,
            S = (parseInt(n.paddingBottom) || 0) * this.scaleY;
        this.paddingTop == b && this.paddingBottom == S || (this.paddingTop = b, this.paddingBottom = S, y |= 10), this.editorWidth != e.scrollDOM.clientWidth && (o.lineWrapping && (g = !0), this.editorWidth = e.scrollDOM.clientWidth, y |= 8);
        let k = e.scrollDOM.scrollTop * this.scaleY;
        this.scrollTop != k && (this.scrollAnchorHeight = -1, this.scrollTop = k), this.scrolledToBottom = isScrolledToBottom(e.scrollDOM);
        let v = (this.printing ? fullPixelRange : visiblePixelRange)(t, this.paddingTop),
            P = v.top - this.pixelViewport.top,
            C = v.bottom - this.pixelViewport.bottom;
        this.pixelViewport = v;
        let Q = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (Q != this.inView && (this.inView = Q, Q && (g = !0)), !this.inView && !this.scrollTarget) return 0;
        let $ = f.width;
        if (this.contentDOMWidth == $ && this.editorHeight == e.scrollDOM.clientHeight || (this.contentDOMWidth = f.width, this.editorHeight = e.scrollDOM.clientHeight, y |= 8), g) {
            let t = e.docView.measureVisibleLineHeights(this.viewport);
            if (o.mustRefreshForHeights(t) && (p = !0), p || o.lineWrapping && Math.abs($ - this.contentDOMWidth) > o.charWidth) {
                let {
                    lineHeight: n,
                    charWidth: f,
                    textHeight: g
                } = e.docView.measureTextSize();
                p = n > 0 && o.refresh(h, n, f, g, $ / f, t), p && (e.docView.minWidth = 0, y |= 8)
            }
            P > 0 && C > 0 ? w = Math.max(P, C) : P < 0 && C < 0 && (w = Math.min(P, C)), clearHeightChangeFlag();
            for (let n of this.viewports) {
                let h = n.from == this.viewport.from ? t : e.docView.measureVisibleLineHeights(n);
                this.heightMap = (p ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(o, 0, p, new MeasuredHeights(n.from, h))
            }
            ht && (y |= 2)
        }
        let A = !this.viewportIsAppropriate(this.viewport, w) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
        return A && (2 & y && (y |= this.updateScaler()), this.viewport = this.getViewport(w, this.scrollTarget), y |= this.updateForViewport()), (2 & y || A) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(p ? [] : this.lineGaps, e)), y |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), y
    }
    get visibleTop() {
        return this.scaler.fromDOM(this.pixelViewport.top)
    }
    get visibleBottom() {
        return this.scaler.fromDOM(this.pixelViewport.bottom)
    }
    getViewport(e, t) {
        let n = .5 - Math.max(-.5, Math.min(.5, e / 1e3 / 2)),
            o = this.heightMap,
            h = this.heightOracle,
            {
                visibleTop: p,
                visibleBottom: f
            } = this,
            g = new Viewport(o.lineAt(p - 1e3 * n, dt.ByHeight, h, 0, 0).from, o.lineAt(f + 1e3 * (1 - n), dt.ByHeight, h, 0, 0).to);
        if (t) {
            let {
                head: e
            } = t.range;
            if (e < g.from || e > g.to) {
                let n, p = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top),
                    f = o.lineAt(e, dt.ByPos, h, 0, 0);
                n = "center" == t.y ? (f.top + f.bottom) / 2 - p / 2 : "start" == t.y || "nearest" == t.y && e < g.from ? f.top : f.bottom - p, g = new Viewport(o.lineAt(n - 500, dt.ByHeight, h, 0, 0).from, o.lineAt(n + p + 500, dt.ByHeight, h, 0, 0).to)
            }
        }
        return g
    }
    mapViewport(e, t) {
        let n = t.mapPos(e.from, -1),
            o = t.mapPos(e.to, 1);
        return new Viewport(this.heightMap.lineAt(n, dt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(o, dt.ByPos, this.heightOracle, 0, 0).to)
    }
    viewportIsAppropriate({
        from: e,
        to: t
    }, n = 0) {
        if (!this.inView) return !0;
        let {
            top: o
        } = this.heightMap.lineAt(e, dt.ByPos, this.heightOracle, 0, 0), {
            bottom: h
        } = this.heightMap.lineAt(t, dt.ByPos, this.heightOracle, 0, 0), {
            visibleTop: p,
            visibleBottom: f
        } = this;
        return (0 == e || o <= p - Math.max(10, Math.min(-n, 250))) && (t == this.state.doc.length || h >= f + Math.max(10, Math.min(n, 250))) && o > p - 2e3 && h < f + 2e3
    }
    mapLineGaps(e, t) {
        if (!e.length || t.empty) return e;
        let n = [];
        for (let o of e) t.touchesRange(o.from, o.to) || n.push(new LineGap(t.mapPos(o.from), t.mapPos(o.to), o.size, o.displaySize));
        return n
    }
    ensureLineGaps(e, t) {
        let n = this.heightOracle.lineWrapping,
            o = n ? 1e4 : 2e3,
            h = o >> 1,
            p = o << 1;
        if (this.defaultTextDirection != pe.LTR && !n) return [];
        let f = [],
            addGap = (o, p, g, y) => {
                if (p - o < h) return;
                let w = this.state.selection.main,
                    b = [w.from];
                w.empty || b.push(w.to);
                for (let e of b)
                    if (e > o && e < p) return addGap(o, e - 10, g, y), void addGap(e + 10, p, g, y);
                let S = function(e, t) {
                    for (let n of e)
                        if (t(n)) return n;
                    return
                }(e, (e => e.from >= g.from && e.to <= g.to && Math.abs(e.from - o) < h && Math.abs(e.to - p) < h && !b.some((t => e.from < t && e.to > t))));
                if (!S) {
                    if (p < g.to && t && n && t.visibleRanges.some((e => e.from <= p && e.to >= p))) {
                        let e = t.moveToLineBoundary(EditorSelection.cursor(p), !1, !0).head;
                        e > o && (p = e)
                    }
                    let e = this.gapSize(g, o, p, y);
                    S = new LineGap(o, p, e, n || e < 2e6 ? e : 2e6)
                }
                f.push(S)
            },
            checkLine = t => {
                if (t.length < p || t.type != ue.Text) return;
                let h = function(e, t, n) {
                    let o = [],
                        h = e,
                        p = 0;
                    RangeSet.spans(n, e, t, {
                        span() {},
                        point(e, t) {
                            e > h && (o.push({
                                from: h,
                                to: e
                            }), p += e - h), h = t
                        }
                    }, 20), h < t && (o.push({
                        from: h,
                        to: t
                    }), p += t - h);
                    return {
                        total: p,
                        ranges: o
                    }
                }(t.from, t.to, this.stateDeco);
                if (h.total < p) return;
                let f, g, y = this.scrollTarget ? this.scrollTarget.range.head : null;
                if (n) {
                    let e, n, p = o / this.heightOracle.lineLength * this.heightOracle.lineHeight;
                    if (null != y) {
                        let o = findFraction(h, y),
                            f = ((this.visibleBottom - this.visibleTop) / 2 + p) / t.height;
                        e = o - f, n = o + f
                    } else e = (this.visibleTop - t.top - p) / t.height, n = (this.visibleBottom - t.top + p) / t.height;
                    f = findPosition$1(h, e), g = findPosition$1(h, n)
                } else {
                    let n = h.total * this.heightOracle.charWidth,
                        p = o * this.heightOracle.charWidth,
                        w = 0;
                    if (n > 2e6)
                        for (let n of e) n.from >= t.from && n.from < t.to && n.size != n.displaySize && n.from * this.heightOracle.charWidth + w < this.pixelViewport.left && (w = n.size - n.displaySize);
                    let b, S, k = this.pixelViewport.left + w,
                        v = this.pixelViewport.right + w;
                    if (null != y) {
                        let e = findFraction(h, y),
                            t = ((v - k) / 2 + p) / n;
                        b = e - t, S = e + t
                    } else b = (k - p) / n, S = (v + p) / n;
                    f = findPosition$1(h, b), g = findPosition$1(h, S)
                }
                f > t.from && addGap(t.from, f, t, h), g < t.to && addGap(g, t.to, t, h)
            };
        for (let e of this.viewportLines) Array.isArray(e.type) ? e.type.forEach(checkLine) : checkLine(e);
        return f
    }
    gapSize(e, t, n, o) {
        let h = findFraction(o, n) - findFraction(o, t);
        return this.heightOracle.lineWrapping ? e.height * h : o.total * this.heightOracle.charWidth * h
    }
    updateLineGaps(e) {
        LineGap.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Decoration.set(e.map((e => e.draw(this, this.heightOracle.lineWrapping)))))
    }
    computeVisibleRanges() {
        let e = this.stateDeco;
        this.lineGaps.length && (e = e.concat(this.lineGapDeco));
        let t = [];
        RangeSet.spans(e, this.viewport.from, this.viewport.to, {
            span(e, n) {
                t.push({
                    from: e,
                    to: n
                })
            },
            point() {}
        }, 20);
        let n = t.length != this.visibleRanges.length || this.visibleRanges.some(((e, n) => e.from != t[n].from || e.to != t[n].to));
        return this.visibleRanges = t, n ? 4 : 0
    }
    lineBlockAt(e) {
        return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t => t.from <= e && t.to >= e)) || scaleBlock(this.heightMap.lineAt(e, dt.ByPos, this.heightOracle, 0, 0), this.scaler)
    }
    lineBlockAtHeight(e) {
        return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((t => t.top <= e && t.bottom >= e)) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(e), dt.ByHeight, this.heightOracle, 0, 0), this.scaler)
    }
    scrollAnchorAt(e) {
        let t = this.lineBlockAtHeight(e + 8);
        return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0]
    }
    elementAtHeight(e) {
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler)
    }
    get docHeight() {
        return this.scaler.toDOM(this.heightMap.height)
    }
    get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom
    }
}
class Viewport {
    constructor(e, t) {
        this.from = e, this.to = t
    }
}

function findPosition$1({
    total: e,
    ranges: t
}, n) {
    if (n <= 0) return t[0].from;
    if (n >= 1) return t[t.length - 1].to;
    let o = Math.floor(e * n);
    for (let e = 0;; e++) {
        let {
            from: n,
            to: h
        } = t[e], p = h - n;
        if (o <= p) return n + o;
        o -= p
    }
}

function findFraction(e, t) {
    let n = 0;
    for (let {
            from: o,
            to: h
        } of e.ranges) {
        if (t <= h) {
            n += t - o;
            break
        }
        n += h - o
    }
    return n / e.total
}
const pt = {
    toDOM: e => e,
    fromDOM: e => e,
    scale: 1,
    eq(e) {
        return e == this
    }
};
class BigScaler {
    constructor(e, t, n) {
        let o = 0,
            h = 0,
            p = 0;
        this.viewports = n.map((({
            from: n,
            to: h
        }) => {
            let p = t.lineAt(n, dt.ByPos, e, 0, 0).top,
                f = t.lineAt(h, dt.ByPos, e, 0, 0).bottom;
            return o += f - p, {
                from: n,
                to: h,
                top: p,
                bottom: f,
                domTop: 0,
                domBottom: 0
            }
        })), this.scale = (7e6 - o) / (t.height - o);
        for (let e of this.viewports) e.domTop = p + (e.top - h) * this.scale, p = e.domBottom = e.domTop + (e.bottom - e.top), h = e.bottom
    }
    toDOM(e) {
        for (let t = 0, n = 0, o = 0;; t++) {
            let h = t < this.viewports.length ? this.viewports[t] : null;
            if (!h || e < h.top) return o + (e - n) * this.scale;
            if (e <= h.bottom) return h.domTop + (e - h.top);
            n = h.bottom, o = h.domBottom
        }
    }
    fromDOM(e) {
        for (let t = 0, n = 0, o = 0;; t++) {
            let h = t < this.viewports.length ? this.viewports[t] : null;
            if (!h || e < h.domTop) return n + (e - o) / this.scale;
            if (e <= h.domBottom) return h.top + (e - h.domTop);
            n = h.bottom, o = h.domBottom
        }
    }
    eq(e) {
        return e instanceof BigScaler && (this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every(((t, n) => t.from == e.viewports[n].from && t.to == e.viewports[n].to)))
    }
}

function scaleBlock(e, t) {
    if (1 == t.scale) return e;
    let n = t.toDOM(e.top),
        o = t.toDOM(e.bottom);
    return new BlockInfo(e.from, e.length, n, o - n, Array.isArray(e._content) ? e._content.map((e => scaleBlock(e, t))) : e._content)
}
const ft = Facet.define({
        combine: e => e.join(" ")
    }),
    gt = Facet.define({
        combine: e => e.indexOf(!0) > -1
    }),
    mt = StyleModule.newName(),
    Ot = StyleModule.newName(),
    yt = StyleModule.newName(),
    wt = {
        "&light": "." + Ot,
        "&dark": "." + yt
    };

function buildTheme(e, t, n) {
    return new StyleModule(t, {
        finish: t => /&/.test(t) ? t.replace(/&\w*/, (t => {
            if ("&" == t) return e;
            if (!n || !n[t]) throw new RangeError(`Unsupported selector: ${t}`);
            return n[t]
        })) : e + " " + t
    })
}
const bt = buildTheme("." + mt, {
        "&": {
            position: "relative !important",
            boxSizing: "border-box",
            "&.cm-focused": {
                outline: "1px dotted #212121"
            },
            display: "flex !important",
            flexDirection: "column"
        },
        ".cm-scroller": {
            display: "flex !important",
            alignItems: "flex-start !important",
            fontFamily: "monospace",
            lineHeight: 1.4,
            height: "100%",
            overflowX: "auto",
            position: "relative",
            zIndex: 0,
            overflowAnchor: "none"
        },
        ".cm-content": {
            margin: 0,
            flexGrow: 2,
            flexShrink: 0,
            display: "block",
            whiteSpace: "pre",
            wordWrap: "normal",
            boxSizing: "border-box",
            minHeight: "100%",
            padding: "4px 0",
            outline: "none",
            "&[contenteditable=true]": {
                WebkitUserModify: "read-write-plaintext-only"
            }
        },
        ".cm-lineWrapping": {
            whiteSpace_fallback: "pre-wrap",
            whiteSpace: "break-spaces",
            wordBreak: "break-word",
            overflowWrap: "anywhere",
            flexShrink: 1
        },
        "&light .cm-content": {
            caretColor: "black"
        },
        "&dark .cm-content": {
            caretColor: "white"
        },
        ".cm-line": {
            display: "block",
            padding: "0 2px 0 6px"
        },
        ".cm-layer": {
            position: "absolute",
            left: 0,
            top: 0,
            contain: "size style",
            "& > *": {
                position: "absolute"
            }
        },
        "&light .cm-selectionBackground": {
            background: "#d9d9d9"
        },
        "&dark .cm-selectionBackground": {
            background: "#222"
        },
        "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
            background: "#d7d4f0"
        },
        "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
            background: "#233"
        },
        ".cm-cursorLayer": {
            pointerEvents: "none"
        },
        "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
            animation: "steps(1) cm-blink 1.2s infinite"
        },
        "@keyframes cm-blink": {
            "0%": {},
            "50%": {
                opacity: 0
            },
            "100%": {}
        },
        "@keyframes cm-blink2": {
            "0%": {},
            "50%": {
                opacity: 0
            },
            "100%": {}
        },
        ".cm-cursor, .cm-dropCursor": {
            borderLeft: "1.2px solid black",
            marginLeft: "-0.6px",
            pointerEvents: "none"
        },
        ".cm-cursor": {
            display: "none"
        },
        "&dark .cm-cursor": {
            borderLeftColor: "#ddd"
        },
        ".cm-dropCursor": {
            position: "absolute"
        },
        "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
            display: "block"
        },
        ".cm-iso": {
            unicodeBidi: "isolate"
        },
        ".cm-announced": {
            position: "fixed",
            top: "-10000px"
        },
        "@media print": {
            ".cm-announced": {
                display: "none"
            }
        },
        "&light .cm-activeLine": {
            backgroundColor: "#cceeff44"
        },
        "&dark .cm-activeLine": {
            backgroundColor: "#99eeff33"
        },
        "&light .cm-specialChar": {
            color: "red"
        },
        "&dark .cm-specialChar": {
            color: "#f78"
        },
        ".cm-gutters": {
            flexShrink: 0,
            display: "flex",
            height: "100%",
            boxSizing: "border-box",
            insetInlineStart: 0,
            zIndex: 200
        },
        "&light .cm-gutters": {
            backgroundColor: "#f5f5f5",
            color: "#6c6c6c",
            borderRight: "1px solid #ddd"
        },
        "&dark .cm-gutters": {
            backgroundColor: "#333338",
            color: "#ccc"
        },
        ".cm-gutter": {
            display: "flex !important",
            flexDirection: "column",
            flexShrink: 0,
            boxSizing: "border-box",
            minHeight: "100%",
            overflow: "hidden"
        },
        ".cm-gutterElement": {
            boxSizing: "border-box"
        },
        ".cm-lineNumbers .cm-gutterElement": {
            padding: "0 3px 0 5px",
            minWidth: "20px",
            textAlign: "right",
            whiteSpace: "nowrap"
        },
        "&light .cm-activeLineGutter": {
            backgroundColor: "#e2f2ff"
        },
        "&dark .cm-activeLineGutter": {
            backgroundColor: "#222227"
        },
        ".cm-panels": {
            boxSizing: "border-box",
            position: "sticky",
            left: 0,
            right: 0,
            zIndex: 300
        },
        "&light .cm-panels": {
            backgroundColor: "#f5f5f5",
            color: "black"
        },
        "&light .cm-panels-top": {
            borderBottom: "1px solid #ddd"
        },
        "&light .cm-panels-bottom": {
            borderTop: "1px solid #ddd"
        },
        "&dark .cm-panels": {
            backgroundColor: "#333338",
            color: "white"
        },
        ".cm-tab": {
            display: "inline-block",
            overflow: "hidden",
            verticalAlign: "bottom"
        },
        ".cm-widgetBuffer": {
            verticalAlign: "text-top",
            height: "1em",
            width: 0,
            display: "inline"
        },
        ".cm-placeholder": {
            color: "#888",
            display: "inline-block",
            verticalAlign: "top"
        },
        ".cm-highlightSpace": {
            backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
            backgroundPosition: "center"
        },
        ".cm-highlightTab": {
            backgroundImage: 'url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>\')',
            backgroundSize: "auto 100%",
            backgroundPosition: "right 90%",
            backgroundRepeat: "no-repeat"
        },
        ".cm-trailingSpace": {
            backgroundColor: "#ff332255"
        },
        ".cm-button": {
            verticalAlign: "middle",
            color: "inherit",
            fontSize: "70%",
            padding: ".2em 1em",
            borderRadius: "1px"
        },
        "&light .cm-button": {
            backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
            border: "1px solid #888",
            "&:active": {
                backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
            }
        },
        "&dark .cm-button": {
            backgroundImage: "linear-gradient(#393939, #111)",
            border: "1px solid #888",
            "&:active": {
                backgroundImage: "linear-gradient(#111, #333)"
            }
        },
        ".cm-textfield": {
            verticalAlign: "middle",
            color: "inherit",
            fontSize: "70%",
            border: "1px solid silver",
            padding: ".2em .5em"
        },
        "&light .cm-textfield": {
            backgroundColor: "white"
        },
        "&dark .cm-textfield": {
            border: "1px solid #555",
            backgroundColor: "inherit"
        }
    }, wt),
    St = {
        childList: !0,
        characterData: !0,
        subtree: !0,
        attributes: !0,
        characterDataOldValue: !0
    },
    xt = he.ie && he.ie_version <= 11;
class DOMObserver {
    constructor(e) {
        this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new DOMSelectionState, this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t => {
            for (let e of t) this.queue.push(e);
            (he.ie && he.ie_version <= 11 || he.ios && e.composing) && t.some((e => "childList" == e.type && e.removedNodes.length || "characterData" == e.type && e.oldValue.length > e.target.nodeValue.length)) ? this.flushSoon() : this.flush()
        })), !window.EditContext || !1 === e.constructor.EDIT_CONTEXT || he.chrome && he.chrome_version < 126 || (this.editContext = new EditContextManager(e), e.state.facet(Ze) && (e.contentDOM.editContext = this.editContext.editContext)), xt && (this.onCharData = e => {
            this.queue.push({
                target: e.target,
                type: "characterData",
                oldValue: e.prevValue
            }), this.flushSoon()
        }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), "function" == typeof ResizeObserver && (this.resizeScroll = new ResizeObserver((() => {
            var e;
            (null === (e = this.view.docView) || void 0 === e ? void 0 : e.lastUpdate) < Date.now() - 75 && this.onResize()
        })), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), "function" == typeof IntersectionObserver && (this.intersection = new IntersectionObserver((e => {
            this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), e.length > 0 && e[e.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")))
        }), {
            threshold: [0, .001]
        }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((e => {
            e.length > 0 && e[e.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"))
        }), {})), this.listenForScroll(), this.readSelectionRange()
    }
    onScrollChanged(e) {
        this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure()
    }
    onScroll(e) {
        this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e)
    }
    onResize() {
        this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout((() => {
            this.resizeTimeout = -1, this.view.requestMeasure()
        }), 50))
    }
    onPrint(e) {
        ("change" != e.type && e.type || e.matches) && (this.view.viewState.printing = !0, this.view.measure(), setTimeout((() => {
            this.view.viewState.printing = !1, this.view.requestMeasure()
        }), 500))
    }
    updateGaps(e) {
        if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some(((t, n) => t != e[n])))) {
            this.gapIntersection.disconnect();
            for (let t of e) this.gapIntersection.observe(t);
            this.gaps = e
        }
    }
    onSelectionChange(e) {
        let t = this.selectionChanged;
        if (!this.readSelectionRange() || this.delayedAndroidKey) return;
        let {
            view: n
        } = this, o = this.selectionRange;
        if (n.state.facet(Ze) ? n.root.activeElement != this.dom : !hasSelection(this.dom, o)) return;
        let h = o.anchorNode && n.docView.nearest(o.anchorNode);
        h && h.ignoreEvent(e) ? t || (this.selectionChanged = !1) : (he.ie && he.ie_version <= 11 || he.android && he.chrome) && !n.state.selection.main.empty && o.focusNode && isEquivalentPosition(o.focusNode, o.focusOffset, o.anchorNode, o.anchorOffset) ? this.flushSoon() : this.flush(!1)
    }
    readSelectionRange() {
        let {
            view: e
        } = this, t = getSelection(e.root);
        if (!t) return !1;
        let n = he.safari && 11 == e.root.nodeType && e.root.activeElement == this.dom && function(e, t) {
            if (t.getComposedRanges) {
                let n = t.getComposedRanges(e.root)[0];
                if (n) return buildSelectionRangeFromRange(e, n)
            }
            let n = null;

            function read(e) {
                e.preventDefault(), e.stopImmediatePropagation(), n = e.getTargetRanges()[0]
            }
            return e.contentDOM.addEventListener("beforeinput", read, !0), e.dom.ownerDocument.execCommand("indent"), e.contentDOM.removeEventListener("beforeinput", read, !0), n ? buildSelectionRangeFromRange(e, n) : null
        }(this.view, t) || t;
        if (!n || this.selectionRange.eq(n)) return !1;
        let o = hasSelection(this.dom, n);
        return o && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && function(e, t) {
            let n = t.focusNode,
                o = t.focusOffset;
            if (!n || t.anchorNode != n || t.anchorOffset != o) return !1;
            for (o = Math.min(o, maxOffset(n));;)
                if (o) {
                    if (1 != n.nodeType) return !1;
                    let e = n.childNodes[o - 1];
                    "false" == e.contentEditable ? o-- : (n = e, o = maxOffset(n))
                } else {
                    if (n == e) return !0;
                    o = domIndex(n), n = n.parentNode
                }
        }(this.dom, n) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(n), o && (this.selectionChanged = !0), !0)
    }
    setSelectionRange(e, t) {
        this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1
    }
    clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0)
    }
    listenForScroll() {
        this.parentCheck = -1;
        let e = 0,
            t = null;
        for (let n = this.dom; n;)
            if (1 == n.nodeType) !t && e < this.scrollTargets.length && this.scrollTargets[e] == n ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(n), n = n.assignedSlot || n.parentNode;
            else {
                if (11 != n.nodeType) break;
                n = n.host
            }
        if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
            for (let e of this.scrollTargets) e.removeEventListener("scroll", this.onScroll);
            for (let e of this.scrollTargets = t) e.addEventListener("scroll", this.onScroll)
        }
    }
    ignore(e) {
        if (!this.active) return e();
        try {
            return this.stop(), e()
        } finally {
            this.start(), this.clear()
        }
    }
    start() {
        this.active || (this.observer.observe(this.dom, St), xt && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0)
    }
    stop() {
        this.active && (this.active = !1, this.observer.disconnect(), xt && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData))
    }
    clear() {
        this.processRecords(), this.queue.length = 0, this.selectionChanged = !1
    }
    delayAndroidKey(e, t) {
        var n;
        if (!this.delayedAndroidKey) {
            let flush = () => {
                let e = this.delayedAndroidKey;
                if (e) {
                    this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = e.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && e.force && dispatchKey(this.dom, e.key, e.keyCode)
                }
            };
            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush)
        }
        this.delayedAndroidKey && "Enter" != e || (this.delayedAndroidKey = {
            key: e,
            keyCode: t,
            force: this.lastChange < Date.now() - 50 || !!(null === (n = this.delayedAndroidKey) || void 0 === n ? void 0 : n.force)
        })
    }
    clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1
    }
    flushSoon() {
        this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame((() => {
            this.delayedFlush = -1, this.flush()
        })))
    }
    forceFlush() {
        this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush()
    }
    pendingRecords() {
        for (let e of this.observer.takeRecords()) this.queue.push(e);
        return this.queue
    }
    processRecords() {
        let e = this.pendingRecords();
        e.length && (this.queue = []);
        let t = -1,
            n = -1,
            o = !1;
        for (let h of e) {
            let e = this.readMutation(h);
            e && (e.typeOver && (o = !0), -1 == t ? ({
                from: t,
                to: n
            } = e) : (t = Math.min(e.from, t), n = Math.max(e.to, n)))
        }
        return {
            from: t,
            to: n,
            typeOver: o
        }
    }
    readChange() {
        let {
            from: e,
            to: t,
            typeOver: n
        } = this.processRecords(), o = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
        if (e < 0 && !o) return null;
        e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
        let h = new DOMChange(this.view, e, t, n);
        return this.view.docView.domChanged = {
            newSel: h.newSel ? h.newSel.main : null
        }, h
    }
    flush(e = !0) {
        if (this.delayedFlush >= 0 || this.delayedAndroidKey) return !1;
        e && this.readSelectionRange();
        let t = this.readChange();
        if (!t) return this.view.requestMeasure(), !1;
        let n = this.view.state,
            o = applyDOMChange(this.view, t);
        return this.view.state == n && (t.domChanged || t.newSel && !t.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), o
    }
    readMutation(e) {
        let t = this.view.docView.nearest(e.target);
        if (!t || t.ignoreMutation(e)) return null;
        if (t.markDirty("attributes" == e.type), "attributes" == e.type && (t.flags |= 4), "childList" == e.type) {
            let n = findChild(t, e.previousSibling || e.target.previousSibling, -1),
                o = findChild(t, e.nextSibling || e.target.nextSibling, 1);
            return {
                from: n ? t.posAfter(n) : t.posAtStart,
                to: o ? t.posBefore(o) : t.posAtEnd,
                typeOver: !1
            }
        }
        return "characterData" == e.type ? {
            from: t.posAtStart,
            to: t.posAtEnd,
            typeOver: e.target.nodeValue == e.oldValue
        } : null
    }
    setWindow(e) {
        e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win))
    }
    addWindowListeners(e) {
        e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange)
    }
    removeWindowListeners(e) {
        e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange)
    }
    update(e) {
        this.editContext && (this.editContext.update(e), e.startState.facet(Ze) != e.state.facet(Ze) && (e.view.contentDOM.editContext = e.state.facet(Ze) ? this.editContext.editContext : null))
    }
    destroy() {
        var e, t, n;
        this.stop(), null === (e = this.intersection) || void 0 === e || e.disconnect(), null === (t = this.gapIntersection) || void 0 === t || t.disconnect(), null === (n = this.resizeScroll) || void 0 === n || n.disconnect();
        for (let e of this.scrollTargets) e.removeEventListener("scroll", this.onScroll);
        this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy())
    }
}

function findChild(e, t, n) {
    for (; t;) {
        let o = ContentView.get(t);
        if (o && o.parent == e) return o;
        let h = t.parentNode;
        t = h != e.dom ? h : n > 0 ? t.nextSibling : t.previousSibling
    }
    return null
}

function buildSelectionRangeFromRange(e, t) {
    let n = t.startContainer,
        o = t.startOffset,
        h = t.endContainer,
        p = t.endOffset,
        f = e.docView.domAtPos(e.state.selection.main.anchor);
    return isEquivalentPosition(f.node, f.offset, h, p) && ([n, o, h, p] = [h, p, n, o]), {
        anchorNode: n,
        anchorOffset: o,
        focusNode: h,
        focusOffset: p
    }
}
class EditContextManager {
    constructor(e) {
        this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = Object.create(null), this.composing = null, this.resetRange(e.state);
        let t = this.editContext = new window.EditContext({
            text: e.state.doc.sliceString(this.from, this.to),
            selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
            selectionEnd: this.toContextPos(e.state.selection.main.head)
        });
        this.handlers.textupdate = t => {
            let {
                anchor: n
            } = e.state.selection.main, o = this.toEditorPos(t.updateRangeStart), h = this.toEditorPos(t.updateRangeEnd);
            e.inputState.composing >= 0 && !this.composing && (this.composing = {
                contextBase: t.updateRangeStart,
                editorBase: o,
                drifted: !1
            });
            let p = {
                from: o,
                to: h,
                insert: Text.of(t.text.split("\n"))
            };
            p.from == this.from && n < this.from ? p.from = n : p.to == this.to && n > this.to && (p.to = n), (p.from != p.to || p.insert.length) && (this.pendingContextChange = p, e.state.readOnly || applyDOMChangeInner(e, p, EditorSelection.single(this.toEditorPos(t.selectionStart), this.toEditorPos(t.selectionEnd))), this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)))
        }, this.handlers.characterboundsupdate = n => {
            let o = [],
                h = null;
            for (let t = this.toEditorPos(n.rangeStart), p = this.toEditorPos(n.rangeEnd); t < p; t++) {
                let n = e.coordsForChar(t);
                h = n && new DOMRect(n.left, n.top, n.right - n.left, n.bottom - n.top) || h || new DOMRect, o.push(h)
            }
            t.updateCharacterBounds(n.rangeStart, o)
        }, this.handlers.textformatupdate = t => {
            let n = [];
            for (let e of t.getTextFormats()) {
                let t = e.underlineStyle,
                    o = e.underlineThickness;
                if ("None" != t && "None" != o) {
                    let h = `text-decoration: underline ${"Dashed"==t?"dashed ":"Squiggle"==t?"wavy ":""}${"Thin"==o?1:2}px`;
                    n.push(Decoration.mark({
                        attributes: {
                            style: h
                        }
                    }).range(this.toEditorPos(e.rangeStart), this.toEditorPos(e.rangeEnd)))
                }
            }
            e.dispatch({
                effects: Ve.of(Decoration.set(n))
            })
        }, this.handlers.compositionstart = () => {
            e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0)
        }, this.handlers.compositionend = () => {
            if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
                let {
                    drifted: t
                } = this.composing;
                this.composing = null, t && this.reset(e.state)
            }
        };
        for (let e in this.handlers) t.addEventListener(e, this.handlers[e]);
        this.measureReq = {
            read: e => {
                this.editContext.updateControlBounds(e.contentDOM.getBoundingClientRect());
                let t = getSelection(e.root);
                t && t.rangeCount && this.editContext.updateSelectionBounds(t.getRangeAt(0).getBoundingClientRect())
            }
        }
    }
    applyEdits(e) {
        let t = 0,
            n = !1,
            o = this.pendingContextChange;
        return e.changes.iterChanges(((h, p, f, g, y) => {
            if (n) return;
            let w = y.length - (p - h);
            if (o && p >= o.to) {
                if (o.from == h && o.to == p && o.insert.eq(y)) return o = this.pendingContextChange = null, t += w, void(this.to += w);
                o = null, this.revertPending(e.state)
            }
            if (h += t, (p += t) <= this.from) this.from += w, this.to += w;
            else if (h < this.to) {
                if (h < this.from || p > this.to || this.to - this.from + y.length > 3e4) return void(n = !0);
                this.editContext.updateText(this.toContextPos(h), this.toContextPos(p), y.toString()), this.to += w
            }
            t += w
        })), o && !n && this.revertPending(e.state), !n
    }
    update(e) {
        let t = this.pendingContextChange;
        this.composing && (this.composing.drifted || e.transactions.some((e => !e.isUserEvent("input.type") && e.changes.touchesRange(this.from, this.to)))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : this.applyEdits(e) && this.rangeIsValid(e.state) ? (e.docChanged || e.selectionSet || t) && this.setSelection(e.state) : (this.pendingContextChange = null, this.reset(e.state)), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq)
    }
    resetRange(e) {
        let {
            head: t
        } = e.selection.main;
        this.from = Math.max(0, t - 1e4), this.to = Math.min(e.doc.length, t + 1e4)
    }
    reset(e) {
        this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e)
    }
    revertPending(e) {
        let t = this.pendingContextChange;
        this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(t.from), this.toContextPos(t.from + t.insert.length), e.doc.sliceString(t.from, t.to))
    }
    setSelection(e) {
        let {
            main: t
        } = e.selection, n = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor))), o = this.toContextPos(t.head);
        this.editContext.selectionStart == n && this.editContext.selectionEnd == o || this.editContext.updateSelection(n, o)
    }
    rangeIsValid(e) {
        let {
            head: t
        } = e.selection.main;
        return !(this.from > 0 && t - this.from < 500 || this.to < e.doc.length && this.to - t < 500 || this.to - this.from > 3e4)
    }
    toEditorPos(e) {
        let t = this.composing;
        return t && t.drifted ? t.editorBase + (e - t.contextBase) : e + this.from
    }
    toContextPos(e) {
        let t = this.composing;
        return t && t.drifted ? t.contextBase + (e - t.editorBase) : e - this.from
    }
    destroy() {
        for (let e in this.handlers) this.editContext.removeEventListener(e, this.handlers[e])
    }
}
class EditorView {
    get state() {
        return this.viewState.state
    }
    get viewport() {
        return this.viewState.viewport
    }
    get visibleRanges() {
        return this.viewState.visibleRanges
    }
    get inView() {
        return this.viewState.inView
    }
    get composing() {
        return this.inputState.composing > 0
    }
    get compositionStarted() {
        return this.inputState.composing >= 0
    }
    get root() {
        return this._root
    }
    get win() {
        return this.dom.ownerDocument.defaultView || window
    }
    constructor(e = {}) {
        var t;
        this.plugins = [], this.pluginMap = new Map, this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
        let {
            dispatch: n
        } = e;
        this.dispatchTransactions = e.dispatchTransactions || n && (e => e.forEach((e => n(e, this)))) || (e => this.update(e)), this.dispatch = this.dispatch.bind(this), this._root = e.root || function(e) {
            for (; e;) {
                if (e && (9 == e.nodeType || 11 == e.nodeType && e.host)) return e;
                e = e.assignedSlot || e.parentNode
            }
            return null
        }(e.parent) || document, this.viewState = new ViewState(e.state || EditorState.create(e)), e.scrollTo && e.scrollTo.is(Le) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Be).map((e => new PluginInstance(e)));
        for (let e of this.plugins) e.update(this);
        this.observer = new DOMObserver(this), this.inputState = new InputState(this), this.inputState.ensureHandlers(this.plugins), this.docView = new DocView(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), (null === (t = document.fonts) || void 0 === t ? void 0 : t.ready) && document.fonts.ready.then((() => this.requestMeasure()))
    }
    dispatch(...e) {
        let t = 1 == e.length && e[0] instanceof A ? e : 1 == e.length && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
        this.dispatchTransactions(t, this)
    }
    update(e) {
        if (0 != this.updateState) throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let t, n = !1,
            o = !1,
            h = this.state;
        for (let t of e) {
            if (t.startState != h) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            h = t.state
        }
        if (this.destroyed) return void(this.viewState.state = h);
        let p = this.hasFocus,
            f = 0,
            g = null;
        e.some((e => e.annotation(at))) ? (this.inputState.notifiedFocused = p, f = 1) : p != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = p, g = focusChangeTransaction(h, p), g || (f = 1));
        let y = this.observer.delayedAndroidKey,
            w = null;
        if (y ? (this.observer.clearDelayedAndroidKey(), w = this.observer.readChange(), (w && !this.state.doc.eq(h.doc) || !this.state.selection.eq(h.selection)) && (w = null)) : this.observer.clear(), h.facet(EditorState.phrases) != this.state.facet(EditorState.phrases)) return this.setState(h);
        t = ViewUpdate.create(this, h, e), t.flags |= f;
        let b = this.viewState.scrollTarget;
        try {
            this.updateState = 2;
            for (let t of e) {
                if (b && (b = b.map(t.changes)), t.scrollIntoView) {
                    let {
                        main: e
                    } = t.state.selection;
                    b = new ScrollTarget(e.empty ? e : EditorSelection.cursor(e.head, e.head > e.anchor ? -1 : 1))
                }
                for (let e of t.effects) e.is(Le) && (b = e.value.clip(this.state))
            }
            this.viewState.update(t, b), this.bidiCache = CachedOrder.update(this.bidiCache, t.changes), t.empty || (this.updatePlugins(t), this.inputState.update(t)), n = this.docView.update(t), this.state.facet(We) != this.styleModules && this.mountStyles(), o = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((e => e.isUserEvent("select.pointer"))))
        } finally {
            this.updateState = 0
        }
        if (t.startState.facet(ft) != t.state.facet(ft) && (this.viewState.mustMeasureContent = !0), (n || o || b || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !t.empty)
            for (let e of this.state.facet(Qe)) try {
                e(t)
            } catch (e) {
                logException(this.state, e, "update listener")
            }(g || w) && Promise.resolve().then((() => {
                g && this.state == g.startState && this.dispatch(g), w && !applyDOMChange(this, w) && y.force && dispatchKey(this.contentDOM, y.key, y.keyCode)
            }))
    }
    setState(e) {
        if (0 != this.updateState) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) return void(this.viewState.state = e);
        this.updateState = 2;
        let t = this.hasFocus;
        try {
            for (let e of this.plugins) e.destroy(this);
            this.viewState = new ViewState(e), this.plugins = e.facet(Be).map((e => new PluginInstance(e))), this.pluginMap.clear();
            for (let e of this.plugins) e.update(this);
            this.docView.destroy(), this.docView = new DocView(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = []
        } finally {
            this.updateState = 0
        }
        t && this.focus(), this.requestMeasure()
    }
    updatePlugins(e) {
        let t = e.startState.facet(Be),
            n = e.state.facet(Be);
        if (t != n) {
            let o = [];
            for (let h of n) {
                let n = t.indexOf(h);
                if (n < 0) o.push(new PluginInstance(h));
                else {
                    let t = this.plugins[n];
                    t.mustUpdate = e, o.push(t)
                }
            }
            for (let t of this.plugins) t.mustUpdate != e && t.destroy(this);
            this.plugins = o, this.pluginMap.clear()
        } else
            for (let t of this.plugins) t.mustUpdate = e;
        for (let e = 0; e < this.plugins.length; e++) this.plugins[e].update(this);
        t != n && this.inputState.ensureHandlers(this.plugins)
    }
    docViewUpdate() {
        for (let e of this.plugins) {
            let t = e.value;
            if (t && t.docViewUpdate) try {
                t.docViewUpdate(this)
            } catch (e) {
                logException(this.state, e, "doc view update listener")
            }
        }
    }
    measure(e = !0) {
        if (this.destroyed) return;
        if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) return this.measureScheduled = -1, void this.requestMeasure();
        this.measureScheduled = 0, e && this.observer.forceFlush();
        let t = null,
            n = this.scrollDOM,
            o = n.scrollTop * this.scaleY,
            {
                scrollAnchorPos: h,
                scrollAnchorHeight: p
            } = this.viewState;
        Math.abs(o - this.viewState.scrollTop) > 1 && (p = -1), this.viewState.scrollAnchorHeight = -1;
        try {
            for (let e = 0;; e++) {
                if (p < 0)
                    if (isScrolledToBottom(n)) h = -1, p = this.viewState.heightMap.height;
                    else {
                        let e = this.viewState.scrollAnchorAt(o);
                        h = e.from, p = e.top
                    }
                this.updateState = 1;
                let f = this.viewState.measure(this);
                if (!f && !this.measureRequests.length && null == this.viewState.scrollTarget) break;
                if (e > 5) {
                    console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
                    break
                }
                let g = [];
                4 & f || ([this.measureRequests, g] = [g, this.measureRequests]);
                let y = g.map((e => {
                        try {
                            return e.read(this)
                        } catch (e) {
                            return logException(this.state, e), vt
                        }
                    })),
                    w = ViewUpdate.create(this, this.state, []),
                    b = !1;
                w.flags |= f, t ? t.flags |= f : t = w, this.updateState = 2, w.empty || (this.updatePlugins(w), this.inputState.update(w), this.updateAttrs(), b = this.docView.update(w), b && this.docViewUpdate());
                for (let e = 0; e < g.length; e++)
                    if (y[e] != vt) try {
                        let t = g[e];
                        t.write && t.write(y[e], this)
                    } catch (e) {
                        logException(this.state, e)
                    }
                if (b && this.docView.updateSelection(!0), !w.viewportChanged && 0 == this.measureRequests.length) {
                    if (this.viewState.editorHeight) {
                        if (this.viewState.scrollTarget) {
                            this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, p = -1;
                            continue
                        } {
                            let e = (h < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(h).top) - p;
                            if (e > 1 || e < -1) {
                                o += e, n.scrollTop = o / this.scaleY, p = -1;
                                continue
                            }
                        }
                    }
                    break
                }
            }
        } finally {
            this.updateState = 0, this.measureScheduled = -1
        }
        if (t && !t.empty)
            for (let e of this.state.facet(Qe)) e(t)
    }
    get themeClasses() {
        return mt + " " + (this.state.facet(gt) ? yt : Ot) + " " + this.state.facet(ft)
    }
    updateAttrs() {
        let e = attrsFromFacet(this, Ie, {
                class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
            }),
            t = {
                spellcheck: "false",
                autocorrect: "off",
                autocapitalize: "off",
                translate: "no",
                contenteditable: this.state.facet(Ze) ? "true" : "false",
                class: "cm-content",
                style: `${he.tabSize}: ${this.state.tabSize}`,
                role: "textbox",
                "aria-multiline": "true"
            };
        this.state.readOnly && (t["aria-readonly"] = "true"), attrsFromFacet(this, Xe, t);
        let n = this.observer.ignore((() => {
            let n = updateAttrs(this.contentDOM, this.contentAttrs, t),
                o = updateAttrs(this.dom, this.editorAttrs, e);
            return n || o
        }));
        return this.editorAttrs = e, this.contentAttrs = t, n
    }
    showAnnouncements(e) {
        let t = !0;
        for (let n of e)
            for (let e of n.effects)
                if (e.is(EditorView.announce)) {
                    t && (this.announceDOM.textContent = ""), t = !1, this.announceDOM.appendChild(document.createElement("div")).textContent = e.value
                }
    }
    mountStyles() {
        this.styleModules = this.state.facet(We);
        let e = this.state.facet(EditorView.cspNonce);
        StyleModule.mount(this.root, this.styleModules.concat(bt).reverse(), e ? {
            nonce: e
        } : void 0)
    }
    readMeasured() {
        if (2 == this.updateState) throw new Error("Reading the editor layout isn't allowed during an update");
        0 == this.updateState && this.measureScheduled > -1 && this.measure(!1)
    }
    requestMeasure(e) {
        if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame((() => this.measure()))), e) {
            if (this.measureRequests.indexOf(e) > -1) return;
            if (null != e.key)
                for (let t = 0; t < this.measureRequests.length; t++)
                    if (this.measureRequests[t].key === e.key) return void(this.measureRequests[t] = e);
            this.measureRequests.push(e)
        }
    }
    plugin(e) {
        let t = this.pluginMap.get(e);
        return (void 0 === t || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((t => t.spec == e)) || null), t && t.update(this).value
    }
    get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop
    }
    get documentPadding() {
        return {
            top: this.viewState.paddingTop,
            bottom: this.viewState.paddingBottom
        }
    }
    get scaleX() {
        return this.viewState.scaleX
    }
    get scaleY() {
        return this.viewState.scaleY
    }
    elementAtHeight(e) {
        return this.readMeasured(), this.viewState.elementAtHeight(e)
    }
    lineBlockAtHeight(e) {
        return this.readMeasured(), this.viewState.lineBlockAtHeight(e)
    }
    get viewportLineBlocks() {
        return this.viewState.viewportLines
    }
    lineBlockAt(e) {
        return this.viewState.lineBlockAt(e)
    }
    get contentHeight() {
        return this.viewState.contentHeight
    }
    moveByChar(e, t, n) {
        return skipAtoms(this, e, moveByChar(this, e, t, n))
    }
    moveByGroup(e, t) {
        return skipAtoms(this, e, moveByChar(this, e, t, (t => function(e, t, n) {
            let o = e.state.charCategorizer(t),
                h = o(n);
            return e => {
                let t = o(e);
                return h == R.Space && (h = t), h == t
            }
        }(this, e.head, t))))
    }
    visualLineSide(e, t) {
        let n = this.bidiSpans(e),
            o = this.textDirectionAt(e.from),
            h = n[t ? n.length - 1 : 0];
        return EditorSelection.cursor(h.side(t, o) + e.from, h.forward(!t, o) ? 1 : -1)
    }
    moveToLineBoundary(e, t, n = !0) {
        return function(e, t, n, o) {
            let h = blockAt(e, t.head),
                p = o && h.type == ue.Text && (e.lineWrapping || h.widgetLineBreaks) ? e.coordsAtPos(t.assoc < 0 && t.head > h.from ? t.head - 1 : t.head) : null;
            if (p) {
                let t = e.dom.getBoundingClientRect(),
                    o = e.textDirectionAt(h.from),
                    f = e.posAtCoords({
                        x: n == (o == pe.LTR) ? t.right - 1 : t.left + 1,
                        y: (p.top + p.bottom) / 2
                    });
                if (null != f) return EditorSelection.cursor(f, n ? -1 : 1)
            }
            return EditorSelection.cursor(n ? h.to : h.from, n ? -1 : 1)
        }(this, e, t, n)
    }
    moveVertically(e, t, n) {
        return skipAtoms(this, e, function(e, t, n, o) {
            let h = t.head,
                p = n ? 1 : -1;
            if (h == (n ? e.state.doc.length : 0)) return EditorSelection.cursor(h, t.assoc);
            let f, g = t.goalColumn,
                y = e.contentDOM.getBoundingClientRect(),
                w = e.coordsAtPos(h, t.assoc || -1),
                b = e.documentTop;
            if (w) null == g && (g = w.left - y.left), f = p < 0 ? w.top : w.bottom;
            else {
                let t = e.viewState.lineBlockAt(h);
                null == g && (g = Math.min(y.right - y.left, e.defaultCharacterWidth * (h - t.from))), f = (p < 0 ? t.top : t.bottom) + b
            }
            let S = y.left + g,
                k = null != o ? o : e.viewState.heightOracle.textHeight >> 1;
            for (let t = 0;; t += 10) {
                let n = f + (k + t) * p,
                    o = posAtCoords(e, {
                        x: S,
                        y: n
                    }, !1, p);
                if (n < y.top || n > y.bottom || (p < 0 ? o < h : o > h)) {
                    let t = e.docView.coordsForChar(o),
                        h = !t || n < t.top ? -1 : 1;
                    return EditorSelection.cursor(o, h, void 0, g)
                }
            }
        }(this, e, t, n))
    }
    domAtPos(e) {
        return this.docView.domAtPos(e)
    }
    posAtDOM(e, t = 0) {
        return this.docView.posFromDOM(e, t)
    }
    posAtCoords(e, t = !0) {
        return this.readMeasured(), posAtCoords(this, e, t)
    }
    coordsAtPos(e, t = 1) {
        this.readMeasured();
        let n = this.docView.coordsAt(e, t);
        if (!n || n.left == n.right) return n;
        let o = this.state.doc.lineAt(e),
            h = this.bidiSpans(o);
        return flattenRect(n, h[BidiSpan.find(h, e - o.from, -1, t)].dir == pe.LTR == t > 0)
    }
    coordsForChar(e) {
        return this.readMeasured(), this.docView.coordsForChar(e)
    }
    get defaultCharacterWidth() {
        return this.viewState.heightOracle.charWidth
    }
    get defaultLineHeight() {
        return this.viewState.heightOracle.lineHeight
    }
    get textDirection() {
        return this.viewState.defaultTextDirection
    }
    textDirectionAt(e) {
        return !this.state.facet(Me) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e))
    }
    get lineWrapping() {
        return this.viewState.heightOracle.lineWrapping
    }
    bidiSpans(e) {
        if (e.length > kt) return trivialOrder(e.length);
        let t, n = this.textDirectionAt(e.from);
        for (let o of this.bidiCache)
            if (o.from == e.from && o.dir == n && (o.fresh || isolatesEq(o.isolates, t = getIsolatedRanges(this, e)))) return o.order;
        t || (t = getIsolatedRanges(this, e));
        let o = computeOrder(e.text, n, t);
        return this.bidiCache.push(new CachedOrder(e.from, e.to, n, t, !0, o)), o
    }
    get hasFocus() {
        var e;
        return (this.dom.ownerDocument.hasFocus() || he.safari && (null === (e = this.inputState) || void 0 === e ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM
    }
    focus() {
        this.observer.ignore((() => {
            focusPreventScroll(this.contentDOM), this.docView.updateSelection()
        }))
    }
    setRoot(e) {
        this._root != e && (this._root = e, this.observer.setWindow((9 == e.nodeType ? e : e.ownerDocument).defaultView || window), this.mountStyles())
    }
    destroy() {
        this.root.activeElement == this.contentDOM && this.contentDOM.blur();
        for (let e of this.plugins) e.destroy(this);
        this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0
    }
    static scrollIntoView(e, t = {}) {
        return Le.of(new ScrollTarget("number" == typeof e ? EditorSelection.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin))
    }
    scrollSnapshot() {
        let {
            scrollTop: e,
            scrollLeft: t
        } = this.scrollDOM, n = this.viewState.scrollAnchorAt(e);
        return Le.of(new ScrollTarget(EditorSelection.cursor(n.from), "start", "start", n.top - e, t, !0))
    }
    setTabFocusMode(e) {
        null == e ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : "boolean" == typeof e ? this.inputState.tabFocusMode = e ? 0 : -1 : 0 != this.inputState.tabFocusMode && (this.inputState.tabFocusMode = Date.now() + e)
    }
    static domEventHandlers(e) {
        return ViewPlugin.define((() => ({})), {
            eventHandlers: e
        })
    }
    static domEventObservers(e) {
        return ViewPlugin.define((() => ({})), {
            eventObservers: e
        })
    }
    static theme(e, t) {
        let n = StyleModule.newName(),
            o = [ft.of(n), We.of(buildTheme(`.${n}`, e))];
        return t && t.dark && o.push(gt.of(!0)), o
    }
    static baseTheme(e) {
        return b.lowest(We.of(buildTheme("." + mt, e, wt)))
    }
    static findFromDOM(e) {
        var t;
        let n = e.querySelector(".cm-content"),
            o = n && ContentView.get(n) || ContentView.get(e);
        return (null === (t = null == o ? void 0 : o.rootView) || void 0 === t ? void 0 : t.view) || null
    }
}
EditorView.styleModule = We, EditorView.inputHandler = Te, EditorView.clipboardInputFilter = Ee, EditorView.clipboardOutputFilter = Ae, EditorView.scrollHandler = De, EditorView.focusChangeEffect = $e, EditorView.perLineTextDirection = Me, EditorView.exceptionSink = Ce, EditorView.updateListener = Qe, EditorView.editable = Ze, EditorView.mouseSelectionStyle = Pe, EditorView.dragMovesSelection = ve, EditorView.clickAddsSelectionRange = ke, EditorView.decorations = qe, EditorView.outerDecorations = ze, EditorView.atomicRanges = Ne, EditorView.bidiIsolatedRanges = Ye, EditorView.scrollMargins = je, EditorView.darkTheme = gt, EditorView.cspNonce = Facet.define({
    combine: e => e.length ? e[0] : ""
}), EditorView.contentAttributes = Xe, EditorView.editorAttributes = Ie, EditorView.lineWrapping = EditorView.contentAttributes.of({
    class: "cm-lineWrapping"
}), EditorView.announce = StateEffect.define();
const kt = 4096,
    vt = {};
class CachedOrder {
    constructor(e, t, n, o, h, p) {
        this.from = e, this.to = t, this.dir = n, this.isolates = o, this.fresh = h, this.order = p
    }
    static update(e, t) {
        if (t.empty && !e.some((e => e.fresh))) return e;
        let n = [],
            o = e.length ? e[e.length - 1].dir : pe.LTR;
        for (let h = Math.max(0, e.length - 10); h < e.length; h++) {
            let p = e[h];
            p.dir != o || t.touchesRange(p.from, p.to) || n.push(new CachedOrder(t.mapPos(p.from, 1), t.mapPos(p.to, -1), p.dir, p.isolates, !1, p.order))
        }
        return n
    }
}

function attrsFromFacet(e, t, n) {
    for (let o = e.state.facet(t), h = o.length - 1; h >= 0; h--) {
        let t = o[h],
            p = "function" == typeof t ? t(e) : t;
        p && combineAttrs(p, n)
    }
    return n
}
const Pt = he.mac ? "mac" : he.windows ? "win" : he.linux ? "linux" : "key";

function modifiers(e, t, n) {
    return t.altKey && (e = "Alt-" + e), t.ctrlKey && (e = "Ctrl-" + e), t.metaKey && (e = "Meta-" + e), !1 !== n && t.shiftKey && (e = "Shift-" + e), e
}
const Ct = b.default(EditorView.domEventHandlers({
        keydown: (e, t) => runHandlers(getKeymap(t.state), e, t, "editor")
    })),
    Qt = Facet.define({
        enables: Ct
    }),
    Tt = new WeakMap;

function getKeymap(e) {
    let t = e.facet(Qt),
        n = Tt.get(t);
    return n || Tt.set(t, n = function(e, t = Pt) {
        let n = Object.create(null),
            o = Object.create(null),
            checkPrefix = (e, t) => {
                let n = o[e];
                if (null == n) o[e] = t;
                else if (n != t) throw new Error("Key binding " + e + " is used both as a regular binding and as a multi-stroke prefix")
            },
            add = (e, o, h, p, f) => {
                var g, y;
                let w = n[e] || (n[e] = Object.create(null)),
                    b = o.split(/ (?!$)/).map((e => function(e, t) {
                        const n = e.split(/-(?!$)/);
                        let o, h, p, f, g = n[n.length - 1];
                        "Space" == g && (g = " ");
                        for (let e = 0; e < n.length - 1; ++e) {
                            const g = n[e];
                            if (/^(cmd|meta|m)$/i.test(g)) f = !0;
                            else if (/^a(lt)?$/i.test(g)) o = !0;
                            else if (/^(c|ctrl|control)$/i.test(g)) h = !0;
                            else if (/^s(hift)?$/i.test(g)) p = !0;
                            else {
                                if (!/^mod$/i.test(g)) throw new Error("Unrecognized modifier name: " + g);
                                "mac" == t ? f = !0 : h = !0
                            }
                        }
                        return o && (g = "Alt-" + g), h && (g = "Ctrl-" + g), f && (g = "Meta-" + g), p && (g = "Shift-" + g), g
                    }(e, t)));
                for (let t = 1; t < b.length; t++) {
                    let n = b.slice(0, t).join(" ");
                    checkPrefix(n, !0), w[n] || (w[n] = {
                        preventDefault: !0,
                        stopPropagation: !1,
                        run: [t => {
                            let o = $t = {
                                view: t,
                                prefix: n,
                                scope: e
                            };
                            return setTimeout((() => {
                                $t == o && ($t = null)
                            }), Et), !0
                        }]
                    })
                }
                let S = b.join(" ");
                checkPrefix(S, !1);
                let k = w[S] || (w[S] = {
                    preventDefault: !1,
                    stopPropagation: !1,
                    run: (null === (y = null === (g = w._any) || void 0 === g ? void 0 : g.run) || void 0 === y ? void 0 : y.slice()) || []
                });
                h && k.run.push(h), p && (k.preventDefault = !0), f && (k.stopPropagation = !0)
            };
        for (let o of e) {
            let e = o.scope ? o.scope.split(" ") : ["editor"];
            if (o.any)
                for (let t of e) {
                    let e = n[t] || (n[t] = Object.create(null));
                    e._any || (e._any = {
                        preventDefault: !1,
                        stopPropagation: !1,
                        run: []
                    });
                    let {
                        any: h
                    } = o;
                    for (let t in e) e[t].run.push((e => h(e, At)))
                }
            let h = o[t] || o.key;
            if (h)
                for (let t of e) add(t, h, o.run, o.preventDefault, o.stopPropagation), o.shift && add(t, "Shift-" + h, o.shift, o.preventDefault, o.stopPropagation)
        }
        return n
    }(t.reduce(((e, t) => e.concat(t)), []))), n
}

function runScopeHandlers(e, t, n) {
    return runHandlers(getKeymap(e.state), t, e, n)
}
let $t = null;
const Et = 4e3;
let At = null;

function runHandlers(e, t, n, o) {
    At = t;
    let h = function(e) {
            var t = !(N && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || Y && e.shiftKey && e.key && 1 == e.key.length || "Unidentified" == e.key) && e.key || (e.shiftKey ? z : q)[e.keyCode] || e.key || "Unidentified";
            return "Esc" == t && (t = "Escape"), "Del" == t && (t = "Delete"), "Left" == t && (t = "ArrowLeft"), "Up" == t && (t = "ArrowUp"), "Right" == t && (t = "ArrowRight"), "Down" == t && (t = "ArrowDown"), t
        }(t),
        p = codePointSize(codePointAt(h, 0)) == h.length && " " != h,
        f = "",
        g = !1,
        y = !1,
        w = !1;
    $t && $t.view == n && $t.scope == o && (f = $t.prefix + " ", Ke.indexOf(t.keyCode) < 0 && (y = !0, $t = null));
    let b, S, k = new Set,
        runFor = e => {
            if (e) {
                for (let t of e.run)
                    if (!k.has(t) && (k.add(t), t(n))) return e.stopPropagation && (w = !0), !0;
                e.preventDefault && (e.stopPropagation && (w = !0), y = !0)
            }
            return !1
        },
        v = e[o];
    return v && (runFor(v[f + modifiers(h, t, !p)]) ? g = !0 : p && (t.altKey || t.metaKey || t.ctrlKey) && !(he.windows && t.ctrlKey && t.altKey) && (b = q[t.keyCode]) && b != h ? (runFor(v[f + modifiers(b, t, !0)]) || t.shiftKey && (S = z[t.keyCode]) != h && S != b && runFor(v[f + modifiers(S, t, !1)])) && (g = !0) : p && t.shiftKey && runFor(v[f + modifiers(h, t, !0)]) && (g = !0), !g && runFor(v._any) && (g = !0)), y && (g = !0), g && w && t.stopPropagation(), At = null, g
}
class RectangleMarker {
    constructor(e, t, n, o, h) {
        this.className = e, this.left = t, this.top = n, this.width = o, this.height = h
    }
    draw() {
        let e = document.createElement("div");
        return e.className = this.className, this.adjust(e), e
    }
    update(e, t) {
        return t.className == this.className && (this.adjust(e), !0)
    }
    adjust(e) {
        e.style.left = this.left + "px", e.style.top = this.top + "px", null != this.width && (e.style.width = this.width + "px"), e.style.height = this.height + "px"
    }
    eq(e) {
        return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className
    }
    static forRange(e, t, n) {
        if (n.empty) {
            let o = e.coordsAtPos(n.head, n.assoc || 1);
            if (!o) return [];
            let h = getBase(e);
            return [new RectangleMarker(t, o.left - h.left, o.top - h.top, null, o.bottom - o.top)]
        }
        return function(e, t, n) {
            if (n.to <= e.viewport.from || n.from >= e.viewport.to) return [];
            let o = Math.max(n.from, e.viewport.from),
                h = Math.min(n.to, e.viewport.to),
                p = e.textDirection == pe.LTR,
                f = e.contentDOM,
                g = f.getBoundingClientRect(),
                y = getBase(e),
                w = f.querySelector(".cm-line"),
                b = w && window.getComputedStyle(w),
                S = g.left + (b ? parseInt(b.paddingLeft) + Math.min(0, parseInt(b.textIndent)) : 0),
                k = g.right - (b ? parseInt(b.paddingRight) : 0),
                v = blockAt(e, o),
                P = blockAt(e, h),
                C = v.type == ue.Text ? v : null,
                Q = P.type == ue.Text ? P : null;
            C && (e.lineWrapping || v.widgetLineBreaks) && (C = wrappedLine(e, o, 1, C));
            Q && (e.lineWrapping || P.widgetLineBreaks) && (Q = wrappedLine(e, h, -1, Q));
            if (C && Q && C.from == Q.from && C.to == Q.to) return pieces(drawForLine(n.from, n.to, C)); {
                let t = C ? drawForLine(n.from, null, C) : drawForWidget(v, !1),
                    o = Q ? drawForLine(null, n.to, Q) : drawForWidget(P, !0),
                    h = [];
                return (C || v).to < (Q || P).from - (C && Q ? 1 : 0) || v.widgetLineBreaks > 1 && t.bottom + e.defaultLineHeight / 2 < o.top ? h.push(piece(S, t.bottom, k, o.top)) : t.bottom < o.top && e.elementAtHeight((t.bottom + o.top) / 2).type == ue.Text && (t.bottom = o.top = (t.bottom + o.top) / 2), pieces(t).concat(h).concat(pieces(o))
            }

            function piece(e, n, o, h) {
                return new RectangleMarker(t, e - y.left, n - y.top - .01, o - e, h - n + .01)
            }

            function pieces({
                top: e,
                bottom: t,
                horizontal: n
            }) {
                let o = [];
                for (let h = 0; h < n.length; h += 2) o.push(piece(n[h], e, n[h + 1], t));
                return o
            }

            function drawForLine(t, n, o) {
                let h = 1e9,
                    f = -1e9,
                    g = [];

                function addSpan(t, n, y, w, b) {
                    let v = e.coordsAtPos(t, t == o.to ? -2 : 2),
                        P = e.coordsAtPos(y, y == o.from ? 2 : -2);
                    v && P && (h = Math.min(v.top, P.top, h), f = Math.max(v.bottom, P.bottom, f), b == pe.LTR ? g.push(p && n ? S : v.left, p && w ? k : P.right) : g.push(!p && w ? S : P.left, !p && n ? k : v.right))
                }
                let y = null != t ? t : o.from,
                    w = null != n ? n : o.to;
                for (let o of e.visibleRanges)
                    if (o.to > y && o.from < w)
                        for (let h = Math.max(o.from, y), p = Math.min(o.to, w);;) {
                            let o = e.state.doc.lineAt(h);
                            for (let f of e.bidiSpans(o)) {
                                let e = f.from + o.from,
                                    g = f.to + o.from;
                                if (e >= p) break;
                                g > h && addSpan(Math.max(e, h), null == t && e <= y, Math.min(g, p), null == n && g >= w, f.dir)
                            }
                            if (h = o.to + 1, h >= p) break
                        }
                return 0 == g.length && addSpan(y, null == t, w, null == n, e.textDirection), {
                    top: h,
                    bottom: f,
                    horizontal: g
                }
            }

            function drawForWidget(e, t) {
                let n = g.top + (t ? e.top : e.bottom);
                return {
                    top: n,
                    bottom: n,
                    horizontal: []
                }
            }
        }(e, t, n)
    }
}

function getBase(e) {
    let t = e.scrollDOM.getBoundingClientRect();
    return {
        left: (e.textDirection == pe.LTR ? t.left : t.right - e.scrollDOM.clientWidth * e.scaleX) - e.scrollDOM.scrollLeft * e.scaleX,
        top: t.top - e.scrollDOM.scrollTop * e.scaleY
    }
}

function wrappedLine(e, t, n, o) {
    let h = e.coordsAtPos(t, 2 * n);
    if (!h) return o;
    let p = e.dom.getBoundingClientRect(),
        f = (h.top + h.bottom) / 2,
        g = e.posAtCoords({
            x: p.left + 1,
            y: f
        }),
        y = e.posAtCoords({
            x: p.right - 1,
            y: f
        });
    return null == g || null == y ? o : {
        from: Math.max(o.from, Math.min(g, y)),
        to: Math.min(o.to, Math.max(g, y))
    }
}
class LayerView {
    constructor(e, t) {
        this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = {
            read: this.measure.bind(this),
            write: this.draw.bind(this)
        }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e)
    }
    update(e) {
        e.startState.facet(Mt) != e.state.facet(Mt) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq))
    }
    docViewUpdate(e) {
        !1 !== this.layer.updateOnDocViewUpdate && e.requestMeasure(this.measureReq)
    }
    setOrder(e) {
        let t = 0,
            n = e.facet(Mt);
        for (; t < n.length && n[t] != this.layer;) t++;
        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t)
    }
    measure() {
        return this.layer.markers(this.view)
    }
    scale() {
        let {
            scaleX: e,
            scaleY: t
        } = this.view;
        e == this.scaleX && t == this.scaleY || (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1/e}, ${1/t})`)
    }
    draw(e) {
        if (e.length != this.drawn.length || e.some(((e, t) => {
                return n = e, o = this.drawn[t], !(n.constructor == o.constructor && n.eq(o));
                var n, o
            }))) {
            let t = this.dom.firstChild,
                n = 0;
            for (let o of e) o.update && t && o.constructor && this.drawn[n].constructor && o.update(t, this.drawn[n]) ? (t = t.nextSibling, n++) : this.dom.insertBefore(o.draw(), t);
            for (; t;) {
                let e = t.nextSibling;
                t.remove(), t = e
            }
            this.drawn = e
        }
    }
    destroy() {
        this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove()
    }
}
const Mt = Facet.define();

function layer(e) {
    return [ViewPlugin.define((t => new LayerView(t, e))), Mt.of(e)]
}
const Rt = !he.ios,
    Dt = Facet.define({
        combine: e => combineConfig(e, {
            cursorBlinkRate: 1200,
            drawRangeCursor: !0
        }, {
            cursorBlinkRate: (e, t) => Math.min(e, t),
            drawRangeCursor: (e, t) => e || t
        })
    });

function drawSelection(e = {}) {
    return [Dt.of(e), Lt, Vt, _t, Re.of(!0)]
}

function configChanged(e) {
    return e.startState.facet(Dt) != e.state.facet(Dt)
}
const Lt = layer({
    above: !0,
    markers(e) {
        let {
            state: t
        } = e, n = t.facet(Dt), o = [];
        for (let h of t.selection.ranges) {
            let p = h == t.selection.main;
            if (h.empty ? !p || Rt : n.drawRangeCursor) {
                let t = p ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary",
                    n = h.empty ? h : EditorSelection.cursor(h.head, h.head > h.anchor ? -1 : 1);
                for (let h of RectangleMarker.forRange(e, t, n)) o.push(h)
            }
        }
        return o
    },
    update(e, t) {
        e.transactions.some((e => e.selection)) && (t.style.animationName = "cm-blink" == t.style.animationName ? "cm-blink2" : "cm-blink");
        let n = configChanged(e);
        return n && setBlinkRate(e.state, t), e.docChanged || e.selectionSet || n
    },
    mount(e, t) {
        setBlinkRate(t.state, e)
    },
    class: "cm-cursorLayer"
});

function setBlinkRate(e, t) {
    t.style.animationDuration = e.facet(Dt).cursorBlinkRate + "ms"
}
const Vt = layer({
        above: !1,
        markers: e => e.state.selection.ranges.map((t => t.empty ? [] : RectangleMarker.forRange(e, "cm-selectionBackground", t))).reduce(((e, t) => e.concat(t))),
        update: (e, t) => e.docChanged || e.selectionSet || e.viewportChanged || configChanged(e),
        class: "cm-selectionLayer"
    }),
    Zt = {
        ".cm-line": {
            "& ::selection, &::selection": {
                backgroundColor: "transparent !important"
            }
        },
        ".cm-content": {
            "& :focus": {
                caretColor: "initial !important",
                "&::selection, & ::selection": {
                    backgroundColor: "Highlight !important"
                }
            }
        }
    };
Rt && (Zt[".cm-line"].caretColor = Zt[".cm-content"].caretColor = "transparent !important");
const _t = b.highest(EditorView.theme(Zt)),
    Bt = StateEffect.define({
        map: (e, t) => null == e ? null : t.mapPos(e)
    }),
    It = StateField.define({
        create: () => null,
        update: (e, t) => (null != e && (e = t.changes.mapPos(e)), t.effects.reduce(((e, t) => t.is(Bt) ? t.value : e), e))
    }),
    Xt = ViewPlugin.fromClass(class {
        constructor(e) {
            this.view = e, this.cursor = null, this.measureReq = {
                read: this.readPos.bind(this),
                write: this.drawCursor.bind(this)
            }
        }
        update(e) {
            var t;
            let n = e.state.field(It);
            null == n ? null != this.cursor && (null === (t = this.cursor) || void 0 === t || t.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (e.startState.field(It) != n || e.docChanged || e.geometryChanged) && this.view.requestMeasure(this.measureReq))
        }
        readPos() {
            let {
                view: e
            } = this, t = e.state.field(It), n = null != t && e.coordsAtPos(t);
            if (!n) return null;
            let o = e.scrollDOM.getBoundingClientRect();
            return {
                left: n.left - o.left + e.scrollDOM.scrollLeft * e.scaleX,
                top: n.top - o.top + e.scrollDOM.scrollTop * e.scaleY,
                height: n.bottom - n.top
            }
        }
        drawCursor(e) {
            if (this.cursor) {
                let {
                    scaleX: t,
                    scaleY: n
                } = this.view;
                e ? (this.cursor.style.left = e.left / t + "px", this.cursor.style.top = e.top / n + "px", this.cursor.style.height = e.height / n + "px") : this.cursor.style.left = "-100000px"
            }
        }
        destroy() {
            this.cursor && this.cursor.remove()
        }
        setDropPos(e) {
            this.view.state.field(It) != e && this.view.dispatch({
                effects: Bt.of(e)
            })
        }
    }, {
        eventObservers: {
            dragover(e) {
                this.setDropPos(this.view.posAtCoords({
                    x: e.clientX,
                    y: e.clientY
                }))
            },
            dragleave(e) {
                e.target != this.view.contentDOM && this.view.contentDOM.contains(e.relatedTarget) || this.setDropPos(null)
            },
            dragend() {
                this.setDropPos(null)
            },
            drop() {
                this.setDropPos(null)
            }
        }
    });

function dropCursor() {
    return [It, Xt]
}

function iterMatches(e, t, n, o, h) {
    t.lastIndex = 0;
    for (let p, f = e.iterRange(n, o), g = n; !f.next().done; g += f.value.length)
        if (!f.lineBreak)
            for (; p = t.exec(f.value);) h(g + p.index, p)
}
class MatchDecorator {
    constructor(e) {
        const {
            regexp: t,
            decoration: n,
            decorate: o,
            boundary: h,
            maxLength: p = 1e3
        } = e;
        if (!t.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
        if (this.regexp = t, o) this.addMatch = (e, t, n, h) => o(h, n, n + e[0].length, e, t);
        else if ("function" == typeof n) this.addMatch = (e, t, o, h) => {
            let p = n(e, t, o);
            p && h(o, o + e[0].length, p)
        };
        else {
            if (!n) throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
            this.addMatch = (e, t, o, h) => h(o, o + e[0].length, n)
        }
        this.boundary = h, this.maxLength = p
    }
    createDeco(e) {
        let t = new RangeSetBuilder,
            n = t.add.bind(t);
        for (let {
                from: t,
                to: o
            } of function(e, t) {
                let n = e.visibleRanges;
                if (1 == n.length && n[0].from == e.viewport.from && n[0].to == e.viewport.to) return n;
                let o = [];
                for (let {
                        from: h,
                        to: p
                    } of n) h = Math.max(e.state.doc.lineAt(h).from, h - t), p = Math.min(e.state.doc.lineAt(p).to, p + t), o.length && o[o.length - 1].to >= h ? o[o.length - 1].to = p : o.push({
                    from: h,
                    to: p
                });
                return o
            }(e, this.maxLength)) iterMatches(e.state.doc, this.regexp, t, o, ((t, o) => this.addMatch(o, e, t, n)));
        return t.finish()
    }
    updateDeco(e, t) {
        let n = 1e9,
            o = -1;
        return e.docChanged && e.changes.iterChanges(((t, h, p, f) => {
            f > e.view.viewport.from && p < e.view.viewport.to && (n = Math.min(p, n), o = Math.max(f, o))
        })), e.viewportChanged || o - n > 1e3 ? this.createDeco(e.view) : o > -1 ? this.updateRange(e.view, t.map(e.changes), n, o) : t
    }
    updateRange(e, t, n, o) {
        for (let h of e.visibleRanges) {
            let p = Math.max(h.from, n),
                f = Math.min(h.to, o);
            if (f > p) {
                let n = e.state.doc.lineAt(p),
                    o = n.to < f ? e.state.doc.lineAt(f) : n,
                    g = Math.max(h.from, n.from),
                    y = Math.min(h.to, o.to);
                if (this.boundary) {
                    for (; p > n.from; p--)
                        if (this.boundary.test(n.text[p - 1 - n.from])) {
                            g = p;
                            break
                        }
                    for (; f < o.to; f++)
                        if (this.boundary.test(o.text[f - o.from])) {
                            y = f;
                            break
                        }
                }
                let w, b = [],
                    add = (e, t, n) => b.push(n.range(e, t));
                if (n == o)
                    for (this.regexp.lastIndex = g - n.from;
                        (w = this.regexp.exec(n.text)) && w.index < y - n.from;) this.addMatch(w, e, w.index + n.from, add);
                else iterMatches(e.state.doc, this.regexp, g, y, ((t, n) => this.addMatch(n, e, t, add)));
                t = t.update({
                    filterFrom: g,
                    filterTo: y,
                    filter: (e, t) => e < g || t > y,
                    add: b
                })
            }
        }
        return t
    }
}
const qt = null != /x/.unicode ? "gu" : "g",
    zt = new RegExp("[\0-\b\n--ÂŸÂ­Øœâ€‹â€Žâ€\u2028\u2029â€­â€®â¦â§â©\ufeffï¿¹-ï¿¼]", qt),
    Nt = {
        0: "null",
        7: "bell",
        8: "backspace",
        10: "newline",
        11: "vertical tab",
        13: "carriage return",
        27: "escape",
        8203: "zero width space",
        8204: "zero width non-joiner",
        8205: "zero width joiner",
        8206: "left-to-right mark",
        8207: "right-to-left mark",
        8232: "line separator",
        8237: "left-to-right override",
        8238: "right-to-left override",
        8294: "left-to-right isolate",
        8295: "right-to-left isolate",
        8297: "pop directional isolate",
        8233: "paragraph separator",
        65279: "zero width no-break space",
        65532: "object replacement"
    };
let Yt = null;
const jt = Facet.define({
    combine(e) {
        let t = combineConfig(e, {
            render: null,
            specialChars: zt,
            addSpecialChars: null
        });
        return (t.replaceTabs = ! function() {
            var e;
            if (null == Yt && "undefined" != typeof document && document.body) {
                let t = document.body.style;
                Yt = null != (null !== (e = t.tabSize) && void 0 !== e ? e : t.MozTabSize)
            }
            return Yt || !1
        }()) && (t.specialChars = new RegExp("\t|" + t.specialChars.source, qt)), t.addSpecialChars && (t.specialChars = new RegExp(t.specialChars.source + "|" + t.addSpecialChars.source, qt)), t
    }
});

function highlightSpecialChars(e = {}) {
    return [jt.of(e), Wt || (Wt = ViewPlugin.fromClass(class {
        constructor(e) {
            this.view = e, this.decorations = Decoration.none, this.decorationCache = Object.create(null), this.decorator = this.makeDecorator(e.state.facet(jt)), this.decorations = this.decorator.createDeco(e)
        }
        makeDecorator(e) {
            return new MatchDecorator({
                regexp: e.specialChars,
                decoration: (t, n, o) => {
                    let {
                        doc: h
                    } = n.state, p = codePointAt(t[0], 0);
                    if (9 == p) {
                        let e = h.lineAt(o),
                            t = n.state.tabSize,
                            p = countColumn(e.text, t, o - e.from);
                        return Decoration.replace({
                            widget: new TabWidget((t - p % t) * this.view.defaultCharacterWidth / this.view.scaleX)
                        })
                    }
                    return this.decorationCache[p] || (this.decorationCache[p] = Decoration.replace({
                        widget: new SpecialCharWidget(e, p)
                    }))
                },
                boundary: e.replaceTabs ? void 0 : /[^]/
            })
        }
        update(e) {
            let t = e.state.facet(jt);
            e.startState.facet(jt) != t ? (this.decorator = this.makeDecorator(t), this.decorations = this.decorator.createDeco(e.view)) : this.decorations = this.decorator.updateDeco(e, this.decorations)
        }
    }, {
        decorations: e => e.decorations
    }))]
}
let Wt = null;
class SpecialCharWidget extends WidgetType {
    constructor(e, t) {
        super(), this.options = e, this.code = t
    }
    eq(e) {
        return e.code == this.code
    }
    toDOM(e) {
        let t = function(e) {
                return e >= 32 ? "â€¢" : 10 == e ? "â¤" : String.fromCharCode(9216 + e)
            }(this.code),
            n = e.state.phrase("Control character") + " " + (Nt[this.code] || "0x" + this.code.toString(16)),
            o = this.options.render && this.options.render(this.code, n, t);
        if (o) return o;
        let h = document.createElement("span");
        return h.textContent = t, h.title = n, h.setAttribute("aria-label", n), h.className = "cm-specialChar", h
    }
    ignoreEvent() {
        return !1
    }
}
class TabWidget extends WidgetType {
    constructor(e) {
        super(), this.width = e
    }
    eq(e) {
        return e.width == this.width
    }
    toDOM() {
        let e = document.createElement("span");
        return e.textContent = "\t", e.className = "cm-tab", e.style.width = this.width + "px", e
    }
    ignoreEvent() {
        return !1
    }
}
const Ut = ViewPlugin.fromClass(class {
    constructor() {
        this.height = 1e3, this.attrs = {
            style: "padding-bottom: 1000px"
        }
    }
    update(e) {
        let {
            view: t
        } = e, n = t.viewState.editorHeight - t.defaultLineHeight - t.documentPadding.top - .5;
        n >= 0 && n != this.height && (this.height = n, this.attrs = {
            style: `padding-bottom: ${n}px`
        })
    }
});

function highlightActiveLine() {
    return Gt
}
const Ft = Decoration.line({
        class: "cm-activeLine"
    }),
    Gt = ViewPlugin.fromClass(class {
        constructor(e) {
            this.decorations = this.getDeco(e)
        }
        update(e) {
            (e.docChanged || e.selectionSet) && (this.decorations = this.getDeco(e.view))
        }
        getDeco(e) {
            let t = -1,
                n = [];
            for (let o of e.state.selection.ranges) {
                let h = e.lineBlockAt(o.head);
                h.from > t && (n.push(Ft.range(h.from)), t = h.from)
            }
            return Decoration.set(n)
        }
    }, {
        decorations: e => e.decorations
    });
class Placeholder extends WidgetType {
    constructor(e) {
        super(), this.content = e
    }
    toDOM(e) {
        let t = document.createElement("span");
        return t.className = "cm-placeholder", t.style.pointerEvents = "none", t.appendChild("string" == typeof this.content ? document.createTextNode(this.content) : "function" == typeof this.content ? this.content(e) : this.content.cloneNode(!0)), "string" == typeof this.content ? t.setAttribute("aria-label", "placeholder " + this.content) : t.setAttribute("aria-hidden", "true"), t
    }
    coordsAt(e) {
        let t = e.firstChild ? clientRectsFor(e.firstChild) : [];
        if (!t.length) return null;
        let n = window.getComputedStyle(e.parentNode),
            o = flattenRect(t[0], "rtl" != n.direction),
            h = parseInt(n.lineHeight);
        return o.bottom - o.top > 1.5 * h ? {
            left: o.left,
            right: o.right,
            top: o.top,
            bottom: o.top + h
        } : o
    }
    ignoreEvent() {
        return !1
    }
}
const Ht = 2e3;

function getPos(e, t) {
    let n = e.posAtCoords({
            x: t.clientX,
            y: t.clientY
        }, !1),
        o = e.state.doc.lineAt(n),
        h = n - o.from,
        p = h > Ht ? -1 : h == o.length ? function(e, t) {
            let n = e.coordsAtPos(e.viewport.from);
            return n ? Math.round(Math.abs((n.left - t) / e.defaultCharacterWidth)) : -1
        }(e, t.clientX) : countColumn(o.text, e.state.tabSize, n - o.from);
    return {
        line: o.number,
        col: p,
        off: h
    }
}

function rectangleSelectionStyle(e, t) {
    let n = getPos(e, t),
        o = e.state.selection;
    return n ? {
        update(e) {
            if (e.docChanged) {
                let t = e.changes.mapPos(e.startState.doc.line(n.line).from),
                    h = e.state.doc.lineAt(t);
                n = {
                    line: h.number,
                    col: n.col,
                    off: Math.min(n.off, h.length)
                }, o = o.map(e.changes)
            }
        },
        get(t, h, p) {
            let f = getPos(e, t);
            if (!f) return o;
            let g = function(e, t, n) {
                let o = Math.min(t.line, n.line),
                    h = Math.max(t.line, n.line),
                    p = [];
                if (t.off > Ht || n.off > Ht || t.col < 0 || n.col < 0) {
                    let f = Math.min(t.off, n.off),
                        g = Math.max(t.off, n.off);
                    for (let t = o; t <= h; t++) {
                        let n = e.doc.line(t);
                        n.length <= g && p.push(EditorSelection.range(n.from + f, n.to + g))
                    }
                } else {
                    let f = Math.min(t.col, n.col),
                        g = Math.max(t.col, n.col);
                    for (let t = o; t <= h; t++) {
                        let n = e.doc.line(t),
                            o = findColumn(n.text, f, e.tabSize, !0);
                        if (o < 0) p.push(EditorSelection.cursor(n.to));
                        else {
                            let t = findColumn(n.text, g, e.tabSize);
                            p.push(EditorSelection.range(n.from + o, n.from + t))
                        }
                    }
                }
                return p
            }(e.state, n, f);
            return g.length ? p ? EditorSelection.create(g.concat(o.ranges)) : EditorSelection.create(g) : o
        }
    } : null
}
const Kt = {
        Alt: [18, e => !!e.altKey],
        Control: [17, e => !!e.ctrlKey],
        Shift: [16, e => !!e.shiftKey],
        Meta: [91, e => !!e.metaKey]
    },
    Jt = {
        style: "cursor: crosshair"
    };

function crosshairCursor(e = {}) {
    let [t, n] = Kt[e.key || "Alt"], o = ViewPlugin.fromClass(class {
        constructor(e) {
            this.view = e, this.isDown = !1
        }
        set(e) {
            this.isDown != e && (this.isDown = e, this.view.update([]))
        }
    }, {
        eventObservers: {
            keydown(e) {
                this.set(e.keyCode == t || n(e))
            },
            keyup(e) {
                e.keyCode != t && n(e) || this.set(!1)
            },
            mousemove(e) {
                this.set(n(e))
            }
        }
    });
    return [o, EditorView.contentAttributes.of((e => {
        var t;
        return (null === (t = e.plugin(o)) || void 0 === t ? void 0 : t.isDown) ? Jt : null
    }))]
}
const en = "-10000px";
class TooltipViewManager {
    constructor(e, t, n, o) {
        this.facet = t, this.createTooltipView = n, this.removeTooltipView = o, this.input = e.state.facet(t), this.tooltips = this.input.filter((e => e));
        let h = null;
        this.tooltipViews = this.tooltips.map((e => h = n(e, h)))
    }
    update(e, t) {
        var n;
        let o = e.state.facet(this.facet),
            h = o.filter((e => e));
        if (o === this.input) {
            for (let t of this.tooltipViews) t.update && t.update(e);
            return !1
        }
        let p = [],
            f = t ? [] : null;
        for (let n = 0; n < h.length; n++) {
            let o = h[n],
                g = -1;
            if (o) {
                for (let e = 0; e < this.tooltips.length; e++) {
                    let t = this.tooltips[e];
                    t && t.create == o.create && (g = e)
                }
                if (g < 0) p[n] = this.createTooltipView(o, n ? p[n - 1] : null), f && (f[n] = !!o.above);
                else {
                    let o = p[n] = this.tooltipViews[g];
                    f && (f[n] = t[g]), o.update && o.update(e)
                }
            }
        }
        for (let e of this.tooltipViews) p.indexOf(e) < 0 && (this.removeTooltipView(e), null === (n = e.destroy) || void 0 === n || n.call(e));
        return t && (f.forEach(((e, n) => t[n] = e)), t.length = f.length), this.input = o, this.tooltips = h, this.tooltipViews = p, !0
    }
}

function windowSpace(e) {
    let {
        win: t
    } = e;
    return {
        top: 0,
        left: 0,
        bottom: t.innerHeight,
        right: t.innerWidth
    }
}
const tn = Facet.define({
        combine: e => {
            var t, n, o;
            return {
                position: he.ios ? "absolute" : (null === (t = e.find((e => e.position))) || void 0 === t ? void 0 : t.position) || "fixed",
                parent: (null === (n = e.find((e => e.parent))) || void 0 === n ? void 0 : n.parent) || null,
                tooltipSpace: (null === (o = e.find((e => e.tooltipSpace))) || void 0 === o ? void 0 : o.tooltipSpace) || windowSpace
            }
        }
    }),
    nn = new WeakMap,
    rn = ViewPlugin.fromClass(class {
        constructor(e) {
            this.view = e, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
            let t = e.state.facet(tn);
            this.position = t.position, this.parent = t.parent, this.classes = e.themeClasses, this.createContainer(), this.measureReq = {
                read: this.readMeasure.bind(this),
                write: this.writeMeasure.bind(this),
                key: this
            }, this.resizeObserver = "function" == typeof ResizeObserver ? new ResizeObserver((() => this.measureSoon())) : null, this.manager = new TooltipViewManager(e, an, ((e, t) => this.createTooltip(e, t)), (e => {
                this.resizeObserver && this.resizeObserver.unobserve(e.dom), e.dom.remove()
            })), this.above = this.manager.tooltips.map((e => !!e.above)), this.intersectionObserver = "function" == typeof IntersectionObserver ? new IntersectionObserver((e => {
                Date.now() > this.lastTransaction - 50 && e.length > 0 && e[e.length - 1].intersectionRatio < 1 && this.measureSoon()
            }), {
                threshold: [1]
            }) : null, this.observeIntersection(), e.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure()
        }
        createContainer() {
            this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom
        }
        observeIntersection() {
            if (this.intersectionObserver) {
                this.intersectionObserver.disconnect();
                for (let e of this.manager.tooltipViews) this.intersectionObserver.observe(e.dom)
            }
        }
        measureSoon() {
            this.measureTimeout < 0 && (this.measureTimeout = setTimeout((() => {
                this.measureTimeout = -1, this.maybeMeasure()
            }), 50))
        }
        update(e) {
            e.transactions.length && (this.lastTransaction = Date.now());
            let t = this.manager.update(e, this.above);
            t && this.observeIntersection();
            let n = t || e.geometryChanged,
                o = e.state.facet(tn);
            if (o.position != this.position && !this.madeAbsolute) {
                this.position = o.position;
                for (let e of this.manager.tooltipViews) e.dom.style.position = this.position;
                n = !0
            }
            if (o.parent != this.parent) {
                this.parent && this.container.remove(), this.parent = o.parent, this.createContainer();
                for (let e of this.manager.tooltipViews) this.container.appendChild(e.dom);
                n = !0
            } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
            n && this.maybeMeasure()
        }
        createTooltip(e, t) {
            let n = e.create(this.view),
                o = t ? t.dom : null;
            if (n.dom.classList.add("cm-tooltip"), e.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
                let e = document.createElement("div");
                e.className = "cm-tooltip-arrow", n.dom.appendChild(e)
            }
            return n.dom.style.position = this.position, n.dom.style.top = en, n.dom.style.left = "0px", this.container.insertBefore(n.dom, o), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n
        }
        destroy() {
            var e, t, n;
            this.view.win.removeEventListener("resize", this.measureSoon);
            for (let t of this.manager.tooltipViews) t.dom.remove(), null === (e = t.destroy) || void 0 === e || e.call(t);
            this.parent && this.container.remove(), null === (t = this.resizeObserver) || void 0 === t || t.disconnect(), null === (n = this.intersectionObserver) || void 0 === n || n.disconnect(), clearTimeout(this.measureTimeout)
        }
        readMeasure() {
            let e = 1,
                t = 1,
                n = !1;
            if ("fixed" == this.position && this.manager.tooltipViews.length) {
                let {
                    dom: e
                } = this.manager.tooltipViews[0];
                if (he.gecko) n = e.offsetParent != this.container.ownerDocument.body;
                else if (e.style.top == en && "0px" == e.style.left) {
                    let t = e.getBoundingClientRect();
                    n = Math.abs(t.top + 1e4) > 1 || Math.abs(t.left) > 1
                }
            }
            if (n || "absolute" == this.position)
                if (this.parent) {
                    let n = this.parent.getBoundingClientRect();
                    n.width && n.height && (e = n.width / this.parent.offsetWidth, t = n.height / this.parent.offsetHeight)
                } else({
                    scaleX: e,
                    scaleY: t
                } = this.view.viewState);
            let o = this.view.scrollDOM.getBoundingClientRect(),
                h = getScrollMargins(this.view);
            return {
                visible: {
                    left: o.left + h.left,
                    top: o.top + h.top,
                    right: o.right - h.right,
                    bottom: o.bottom - h.bottom
                },
                parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
                pos: this.manager.tooltips.map(((e, t) => {
                    let n = this.manager.tooltipViews[t];
                    return n.getCoords ? n.getCoords(e.pos) : this.view.coordsAtPos(e.pos)
                })),
                size: this.manager.tooltipViews.map((({
                    dom: e
                }) => e.getBoundingClientRect())),
                space: this.view.state.facet(tn).tooltipSpace(this.view),
                scaleX: e,
                scaleY: t,
                makeAbsolute: n
            }
        }
        writeMeasure(e) {
            var t;
            if (e.makeAbsolute) {
                this.madeAbsolute = !0, this.position = "absolute";
                for (let e of this.manager.tooltipViews) e.dom.style.position = "absolute"
            }
            let {
                visible: n,
                space: o,
                scaleX: h,
                scaleY: p
            } = e, f = [];
            for (let g = 0; g < this.manager.tooltips.length; g++) {
                let y = this.manager.tooltips[g],
                    w = this.manager.tooltipViews[g],
                    {
                        dom: b
                    } = w,
                    S = e.pos[g],
                    k = e.size[g];
                if (!S || S.bottom <= Math.max(n.top, o.top) || S.top >= Math.min(n.bottom, o.bottom) || S.right < Math.max(n.left, o.left) - .1 || S.left > Math.min(n.right, o.right) + .1) {
                    b.style.top = en;
                    continue
                }
                let v = y.arrow ? w.dom.querySelector(".cm-tooltip-arrow") : null,
                    P = v ? 7 : 0,
                    C = k.right - k.left,
                    Q = null !== (t = nn.get(w)) && void 0 !== t ? t : k.bottom - k.top,
                    $ = w.offset || sn,
                    A = this.view.textDirection == pe.LTR,
                    M = k.width > o.right - o.left ? A ? o.left : o.right - k.width : A ? Math.max(o.left, Math.min(S.left - (v ? 14 : 0) + $.x, o.right - C)) : Math.min(Math.max(o.left, S.left - C + (v ? 14 : 0) - $.x), o.right - C),
                    R = this.above[g];
                !y.strictSide && (R ? S.top - Q - P - $.y < o.top : S.bottom + Q + P + $.y > o.bottom) && R == o.bottom - S.bottom > S.top - o.top && (R = this.above[g] = !R);
                let D = (R ? S.top - o.top : o.bottom - S.bottom) - P;
                if (D < Q && !1 !== w.resize) {
                    if (D < this.view.defaultLineHeight) {
                        b.style.top = en;
                        continue
                    }
                    nn.set(w, Q), b.style.height = (Q = D) / p + "px"
                } else b.style.height && (b.style.height = "");
                let L = R ? S.top - Q - P - $.y : S.bottom + P + $.y,
                    V = M + C;
                if (!0 !== w.overlap)
                    for (let e of f) e.left < V && e.right > M && e.top < L + Q && e.bottom > L && (L = R ? e.top - Q - 2 - P : e.bottom + P + 2);
                if ("absolute" == this.position ? (b.style.top = (L - e.parent.top) / p + "px", b.style.left = (M - e.parent.left) / h + "px") : (b.style.top = L / p + "px", b.style.left = M / h + "px"), v) {
                    let e = S.left + (A ? $.x : -$.x) - (M + 14 - 7);
                    v.style.left = e / h + "px"
                }!0 !== w.overlap && f.push({
                    left: M,
                    top: L,
                    right: V,
                    bottom: L + Q
                }), b.classList.toggle("cm-tooltip-above", R), b.classList.toggle("cm-tooltip-below", !R), w.positioned && w.positioned(e.space)
            }
        }
        maybeMeasure() {
            if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
                for (let e of this.manager.tooltipViews) e.dom.style.top = en
        }
    }, {
        eventObservers: {
            scroll() {
                this.maybeMeasure()
            }
        }
    }),
    on = EditorView.baseTheme({
        ".cm-tooltip": {
            zIndex: 500,
            boxSizing: "border-box"
        },
        "&light .cm-tooltip": {
            border: "1px solid #bbb",
            backgroundColor: "#f5f5f5"
        },
        "&light .cm-tooltip-section:not(:first-child)": {
            borderTop: "1px solid #bbb"
        },
        "&dark .cm-tooltip": {
            backgroundColor: "#333338",
            color: "white"
        },
        ".cm-tooltip-arrow": {
            height: "7px",
            width: "14px",
            position: "absolute",
            zIndex: -1,
            overflow: "hidden",
            "&:before, &:after": {
                content: "''",
                position: "absolute",
                width: 0,
                height: 0,
                borderLeft: "7px solid transparent",
                borderRight: "7px solid transparent"
            },
            ".cm-tooltip-above &": {
                bottom: "-7px",
                "&:before": {
                    borderTop: "7px solid #bbb"
                },
                "&:after": {
                    borderTop: "7px solid #f5f5f5",
                    bottom: "1px"
                }
            },
            ".cm-tooltip-below &": {
                top: "-7px",
                "&:before": {
                    borderBottom: "7px solid #bbb"
                },
                "&:after": {
                    borderBottom: "7px solid #f5f5f5",
                    top: "1px"
                }
            }
        },
        "&dark .cm-tooltip .cm-tooltip-arrow": {
            "&:before": {
                borderTopColor: "#333338",
                borderBottomColor: "#333338"
            },
            "&:after": {
                borderTopColor: "transparent",
                borderBottomColor: "transparent"
            }
        }
    }),
    sn = {
        x: 0,
        y: 0
    },
    an = Facet.define({
        enables: [rn, on]
    }),
    ln = Facet.define({
        combine: e => e.reduce(((e, t) => e.concat(t)), [])
    });
class HoverTooltipHost {
    static create(e) {
        return new HoverTooltipHost(e)
    }
    constructor(e) {
        this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new TooltipViewManager(e, ln, ((e, t) => this.createHostedView(e, t)), (e => e.dom.remove()))
    }
    createHostedView(e, t) {
        let n = e.create(this.view);
        return n.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(n.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && n.mount && n.mount(this.view), n
    }
    mount(e) {
        for (let t of this.manager.tooltipViews) t.mount && t.mount(e);
        this.mounted = !0
    }
    positioned(e) {
        for (let t of this.manager.tooltipViews) t.positioned && t.positioned(e)
    }
    update(e) {
        this.manager.update(e)
    }
    destroy() {
        var e;
        for (let t of this.manager.tooltipViews) null === (e = t.destroy) || void 0 === e || e.call(t)
    }
    passProp(e) {
        let t;
        for (let n of this.manager.tooltipViews) {
            let o = n[e];
            if (void 0 !== o)
                if (void 0 === t) t = o;
                else if (t !== o) return
        }
        return t
    }
    get offset() {
        return this.passProp("offset")
    }
    get getCoords() {
        return this.passProp("getCoords")
    }
    get overlap() {
        return this.passProp("overlap")
    }
    get resize() {
        return this.passProp("resize")
    }
}
const cn = an.compute([ln], (e => {
    let t = e.facet(ln);
    return 0 === t.length ? null : {
        pos: Math.min(...t.map((e => e.pos))),
        end: Math.max(...t.map((e => {
            var t;
            return null !== (t = e.end) && void 0 !== t ? t : e.pos
        }))),
        create: HoverTooltipHost.create,
        above: t[0].above,
        arrow: t.some((e => e.arrow))
    }
}));
class HoverPlugin {
    constructor(e, t, n, o, h) {
        this.view = e, this.source = t, this.field = n, this.setHover = o, this.hoverTime = h, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = {
            x: 0,
            y: 0,
            target: e.dom,
            time: 0
        }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this))
    }
    update() {
        this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout((() => this.startHover()), 20))
    }
    get active() {
        return this.view.state.field(this.field)
    }
    checkHover() {
        if (this.hoverTimeout = -1, this.active.length) return;
        let e = Date.now() - this.lastMove.time;
        e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover()
    }
    startHover() {
        clearTimeout(this.restartTimeout);
        let {
            view: e,
            lastMove: t
        } = this, n = e.docView.nearest(t.target);
        if (!n) return;
        let o, h = 1;
        if (n instanceof WidgetView) o = n.posAtStart;
        else {
            if (o = e.posAtCoords(t), null == o) return;
            let n = e.coordsAtPos(o);
            if (!n || t.y < n.top || t.y > n.bottom || t.x < n.left - e.defaultCharacterWidth || t.x > n.right + e.defaultCharacterWidth) return;
            let p = e.bidiSpans(e.state.doc.lineAt(o)).find((e => e.from <= o && e.to >= o)),
                f = p && p.dir == pe.RTL ? -1 : 1;
            h = t.x < n.left ? -f : f
        }
        let p = this.source(e, o, h);
        if (null == p ? void 0 : p.then) {
            let t = this.pending = {
                pos: o
            };
            p.then((n => {
                this.pending == t && (this.pending = null, !n || Array.isArray(n) && !n.length || e.dispatch({
                    effects: this.setHover.of(Array.isArray(n) ? n : [n])
                }))
            }), (t => logException(e.state, t, "hover tooltip")))
        } else !p || Array.isArray(p) && !p.length || e.dispatch({
            effects: this.setHover.of(Array.isArray(p) ? p : [p])
        })
    }
    get tooltip() {
        let e = this.view.plugin(rn),
            t = e ? e.manager.tooltips.findIndex((e => e.create == HoverTooltipHost.create)) : -1;
        return t > -1 ? e.manager.tooltipViews[t] : null
    }
    mousemove(e) {
        var t, n;
        this.lastMove = {
            x: e.clientX,
            y: e.clientY,
            target: e.target,
            time: Date.now()
        }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
        let {
            active: o,
            tooltip: h
        } = this;
        if (o.length && h && ! function(e, t) {
                let n, {
                    left: o,
                    right: h,
                    top: p,
                    bottom: f
                } = e.getBoundingClientRect();
                if (n = e.querySelector(".cm-tooltip-arrow")) {
                    let e = n.getBoundingClientRect();
                    p = Math.min(e.top, p), f = Math.max(e.bottom, f)
                }
                return t.clientX >= o - hn && t.clientX <= h + hn && t.clientY >= p - hn && t.clientY <= f + hn
            }(h.dom, e) || this.pending) {
            let {
                pos: h
            } = o[0] || this.pending, p = null !== (n = null === (t = o[0]) || void 0 === t ? void 0 : t.end) && void 0 !== n ? n : h;
            (h == p ? this.view.posAtCoords(this.lastMove) == h : function(e, t, n, o, h) {
                let p = e.scrollDOM.getBoundingClientRect(),
                    f = e.documentTop + e.documentPadding.top + e.contentHeight;
                if (p.left > o || p.right < o || p.top > h || Math.min(p.bottom, f) < h) return !1;
                let g = e.posAtCoords({
                    x: o,
                    y: h
                }, !1);
                return g >= t && g <= n
            }(this.view, h, p, e.clientX, e.clientY)) || (this.view.dispatch({
                effects: this.setHover.of([])
            }), this.pending = null)
        }
    }
    mouseleave(e) {
        clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
        let {
            active: t
        } = this;
        if (t.length) {
            let {
                tooltip: t
            } = this;
            t && t.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(t.dom) : this.view.dispatch({
                effects: this.setHover.of([])
            })
        }
    }
    watchTooltipLeave(e) {
        let watch = t => {
            e.removeEventListener("mouseleave", watch), this.active.length && !this.view.dom.contains(t.relatedTarget) && this.view.dispatch({
                effects: this.setHover.of([])
            })
        };
        e.addEventListener("mouseleave", watch)
    }
    destroy() {
        clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove)
    }
}
const hn = 4;

function hoverTooltip(e, t = {}) {
    let n = StateEffect.define(),
        h = StateField.define({
            create: () => [],
            update(e, h) {
                if (e.length && (t.hideOnChange && (h.docChanged || h.selection) ? e = [] : t.hideOn && (e = e.filter((e => !t.hideOn(h, e)))), h.docChanged)) {
                    let t = [];
                    for (let n of e) {
                        let e = h.changes.mapPos(n.pos, -1, o.TrackDel);
                        if (null != e) {
                            let o = Object.assign(Object.create(null), n);
                            o.pos = e, null != o.end && (o.end = h.changes.mapPos(o.end)), t.push(o)
                        }
                    }
                    e = t
                }
                for (let t of h.effects) t.is(n) && (e = t.value), t.is(dn) && (e = []);
                return e
            },
            provide: e => ln.from(e)
        });
    return {
        active: h,
        extension: [h, ViewPlugin.define((o => new HoverPlugin(o, e, h, n, t.hoverTime || 300))), cn]
    }
}

function getTooltip(e, t) {
    let n = e.plugin(rn);
    if (!n) return null;
    let o = n.manager.tooltips.indexOf(t);
    return o < 0 ? null : n.manager.tooltipViews[o]
}
const dn = StateEffect.define(),
    un = dn.of(null);
const pn = Facet.define({
    combine(e) {
        let t, n;
        for (let o of e) t = t || o.topContainer, n = n || o.bottomContainer;
        return {
            topContainer: t,
            bottomContainer: n
        }
    }
});

function getPanel(e, t) {
    let n = e.plugin(fn),
        o = n ? n.specs.indexOf(t) : -1;
    return o > -1 ? n.panels[o] : null
}
const fn = ViewPlugin.fromClass(class {
    constructor(e) {
        this.input = e.state.facet(gn), this.specs = this.input.filter((e => e)), this.panels = this.specs.map((t => t(e)));
        let t = e.state.facet(pn);
        this.top = new PanelGroup(e, !0, t.topContainer), this.bottom = new PanelGroup(e, !1, t.bottomContainer), this.top.sync(this.panels.filter((e => e.top))), this.bottom.sync(this.panels.filter((e => !e.top)));
        for (let e of this.panels) e.dom.classList.add("cm-panel"), e.mount && e.mount()
    }
    update(e) {
        let t = e.state.facet(pn);
        this.top.container != t.topContainer && (this.top.sync([]), this.top = new PanelGroup(e.view, !0, t.topContainer)), this.bottom.container != t.bottomContainer && (this.bottom.sync([]), this.bottom = new PanelGroup(e.view, !1, t.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
        let n = e.state.facet(gn);
        if (n != this.input) {
            let t = n.filter((e => e)),
                o = [],
                h = [],
                p = [],
                f = [];
            for (let n of t) {
                let t, g = this.specs.indexOf(n);
                g < 0 ? (t = n(e.view), f.push(t)) : (t = this.panels[g], t.update && t.update(e)), o.push(t), (t.top ? h : p).push(t)
            }
            this.specs = t, this.panels = o, this.top.sync(h), this.bottom.sync(p);
            for (let e of f) e.dom.classList.add("cm-panel"), e.mount && e.mount()
        } else
            for (let t of this.panels) t.update && t.update(e)
    }
    destroy() {
        this.top.sync([]), this.bottom.sync([])
    }
}, {
    provide: e => EditorView.scrollMargins.of((t => {
        let n = t.plugin(e);
        return n && {
            top: n.top.scrollMargin(),
            bottom: n.bottom.scrollMargin()
        }
    }))
});
class PanelGroup {
    constructor(e, t, n) {
        this.view = e, this.top = t, this.container = n, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses()
    }
    sync(e) {
        for (let t of this.panels) t.destroy && e.indexOf(t) < 0 && t.destroy();
        this.panels = e, this.syncDOM()
    }
    syncDOM() {
        if (0 == this.panels.length) return void(this.dom && (this.dom.remove(), this.dom = void 0));
        if (!this.dom) {
            this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
            let e = this.container || this.view.dom;
            e.insertBefore(this.dom, this.top ? e.firstChild : null)
        }
        let e = this.dom.firstChild;
        for (let t of this.panels)
            if (t.dom.parentNode == this.dom) {
                for (; e != t.dom;) e = rm(e);
                e = e.nextSibling
            } else this.dom.insertBefore(t.dom, e);
        for (; e;) e = rm(e)
    }
    scrollMargin() {
        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top)
    }
    syncClasses() {
        if (this.container && this.classes != this.view.themeClasses) {
            for (let e of this.classes.split(" ")) e && this.container.classList.remove(e);
            for (let e of (this.classes = this.view.themeClasses).split(" ")) e && this.container.classList.add(e)
        }
    }
}

function rm(e) {
    let t = e.nextSibling;
    return e.remove(), t
}
const gn = Facet.define({
    enables: fn
});
class GutterMarker extends RangeValue {
    compare(e) {
        return this == e || this.constructor == e.constructor && this.eq(e)
    }
    eq(e) {
        return !1
    }
    destroy(e) {}
}
GutterMarker.prototype.elementClass = "", GutterMarker.prototype.toDOM = void 0, GutterMarker.prototype.mapMode = o.TrackBefore, GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1, GutterMarker.prototype.point = !0;
const mn = Facet.define(),
    On = Facet.define(),
    yn = {
        class: "",
        renderEmptyElements: !1,
        elementStyle: "",
        markers: () => RangeSet.empty,
        lineMarker: () => null,
        widgetMarker: () => null,
        lineMarkerChange: null,
        initialSpacer: null,
        updateSpacer: null,
        domEventHandlers: {}
    },
    wn = Facet.define();

function gutter(e) {
    return [gutters(), wn.of(Object.assign(Object.assign({}, yn), e))]
}
const bn = Facet.define({
    combine: e => e.some((e => e))
});

function gutters(e) {
    let t = [Sn];
    return e && !1 === e.fixed && t.push(bn.of(!0)), t
}
const Sn = ViewPlugin.fromClass(class {
    constructor(e) {
        this.view = e, this.prevViewport = e.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = e.state.facet(wn).map((t => new SingleGutterView(e, t)));
        for (let e of this.gutters) this.dom.appendChild(e.dom);
        this.fixed = !e.state.facet(bn), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), e.scrollDOM.insertBefore(this.dom, e.contentDOM)
    }
    update(e) {
        if (this.updateGutters(e)) {
            let t = this.prevViewport,
                n = e.view.viewport,
                o = Math.min(t.to, n.to) - Math.max(t.from, n.from);
            this.syncGutters(o < .8 * (n.to - n.from))
        }
        e.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(bn) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = e.view.viewport
    }
    syncGutters(e) {
        let t = this.dom.nextSibling;
        e && this.dom.remove();
        let n = RangeSet.iter(this.view.state.facet(mn), this.view.viewport.from),
            o = [],
            h = this.gutters.map((e => new UpdateContext(e, this.view.viewport, -this.view.documentPadding.top)));
        for (let e of this.view.viewportLineBlocks)
            if (o.length && (o = []), Array.isArray(e.type)) {
                let t = !0;
                for (let p of e.type)
                    if (p.type == ue.Text && t) {
                        advanceCursor(n, o, p.from);
                        for (let e of h) e.line(this.view, p, o);
                        t = !1
                    } else if (p.widget)
                    for (let e of h) e.widget(this.view, p)
            } else if (e.type == ue.Text) {
            advanceCursor(n, o, e.from);
            for (let t of h) t.line(this.view, e, o)
        } else if (e.widget)
            for (let t of h) t.widget(this.view, e);
        for (let e of h) e.finish();
        e && this.view.scrollDOM.insertBefore(this.dom, t)
    }
    updateGutters(e) {
        let t = e.startState.facet(wn),
            n = e.state.facet(wn),
            o = e.docChanged || e.heightChanged || e.viewportChanged || !RangeSet.eq(e.startState.facet(mn), e.state.facet(mn), e.view.viewport.from, e.view.viewport.to);
        if (t == n)
            for (let t of this.gutters) t.update(e) && (o = !0);
        else {
            o = !0;
            let h = [];
            for (let o of n) {
                let n = t.indexOf(o);
                n < 0 ? h.push(new SingleGutterView(this.view, o)) : (this.gutters[n].update(e), h.push(this.gutters[n]))
            }
            for (let e of this.gutters) e.dom.remove(), h.indexOf(e) < 0 && e.destroy();
            for (let e of h) this.dom.appendChild(e.dom);
            this.gutters = h
        }
        return o
    }
    destroy() {
        for (let e of this.gutters) e.destroy();
        this.dom.remove()
    }
}, {
    provide: e => EditorView.scrollMargins.of((t => {
        let n = t.plugin(e);
        return n && 0 != n.gutters.length && n.fixed ? t.textDirection == pe.LTR ? {
            left: n.dom.offsetWidth * t.scaleX
        } : {
            right: n.dom.offsetWidth * t.scaleX
        } : null
    }))
});

function asArray(e) {
    return Array.isArray(e) ? e : [e]
}

function advanceCursor(e, t, n) {
    for (; e.value && e.from <= n;) e.from == n && t.push(e.value), e.next()
}
class UpdateContext {
    constructor(e, t, n) {
        this.gutter = e, this.height = n, this.i = 0, this.cursor = RangeSet.iter(e.markers, t.from)
    }
    addElement(e, t, n) {
        let {
            gutter: o
        } = this, h = (t.top - this.height) / e.scaleY, p = t.height / e.scaleY;
        if (this.i == o.elements.length) {
            let t = new GutterElement(e, p, h, n);
            o.elements.push(t), o.dom.appendChild(t.dom)
        } else o.elements[this.i].update(e, p, h, n);
        this.height = t.bottom, this.i++
    }
    line(e, t, n) {
        let o = [];
        advanceCursor(this.cursor, o, t.from), n.length && (o = o.concat(n));
        let h = this.gutter.config.lineMarker(e, t, o);
        h && o.unshift(h);
        let p = this.gutter;
        (0 != o.length || p.config.renderEmptyElements) && this.addElement(e, t, o)
    }
    widget(e, t) {
        let n = this.gutter.config.widgetMarker(e, t.widget, t),
            o = n ? [n] : null;
        for (let n of e.state.facet(On)) {
            let h = n(e, t.widget, t);
            h && (o || (o = [])).push(h)
        }
        o && this.addElement(e, t, o)
    }
    finish() {
        let e = this.gutter;
        for (; e.elements.length > this.i;) {
            let t = e.elements.pop();
            e.dom.removeChild(t.dom), t.destroy()
        }
    }
}
class SingleGutterView {
    constructor(e, t) {
        this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for (let n in t.domEventHandlers) this.dom.addEventListener(n, (o => {
            let h, p = o.target;
            if (p != this.dom && this.dom.contains(p)) {
                for (; p.parentNode != this.dom;) p = p.parentNode;
                let e = p.getBoundingClientRect();
                h = (e.top + e.bottom) / 2
            } else h = o.clientY;
            let f = e.lineBlockAtHeight(h - e.documentTop);
            t.domEventHandlers[n](e, f, o) && o.preventDefault()
        }));
        this.markers = asArray(t.markers(e)), t.initialSpacer && (this.spacer = new GutterElement(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none")
    }
    update(e) {
        let t = this.markers;
        if (this.markers = asArray(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
            let t = this.config.updateSpacer(this.spacer.markers[0], e);
            t != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [t])
        }
        let n = e.view.viewport;
        return !RangeSet.eq(this.markers, t, n.from, n.to) || !!this.config.lineMarkerChange && this.config.lineMarkerChange(e)
    }
    destroy() {
        for (let e of this.elements) e.destroy()
    }
}
class GutterElement {
    constructor(e, t, n, o) {
        this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, n, o)
    }
    update(e, t, n, o) {
        this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + "px" : ""),
            function(e, t) {
                if (e.length != t.length) return !1;
                for (let n = 0; n < e.length; n++)
                    if (!e[n].compare(t[n])) return !1;
                return !0
            }(this.markers, o) || this.setMarkers(e, o)
    }
    setMarkers(e, t) {
        let n = "cm-gutterElement",
            o = this.dom.firstChild;
        for (let h = 0, p = 0;;) {
            let f = p,
                g = h < t.length ? t[h++] : null,
                y = !1;
            if (g) {
                let e = g.elementClass;
                e && (n += " " + e);
                for (let e = p; e < this.markers.length; e++)
                    if (this.markers[e].compare(g)) {
                        f = e, y = !0;
                        break
                    }
            } else f = this.markers.length;
            for (; p < f;) {
                let e = this.markers[p++];
                if (e.toDOM) {
                    e.destroy(o);
                    let t = o.nextSibling;
                    o.remove(), o = t
                }
            }
            if (!g) break;
            g.toDOM && (y ? o = o.nextSibling : this.dom.insertBefore(g.toDOM(e), o)), y && p++
        }
        this.dom.className = n, this.markers = t
    }
    destroy() {
        this.setMarkers(null, [])
    }
}
const xn = Facet.define(),
    kn = Facet.define(),
    vn = Facet.define({
        combine: e => combineConfig(e, {
            formatNumber: String,
            domEventHandlers: {}
        }, {
            domEventHandlers(e, t) {
                let n = Object.assign({}, e);
                for (let e in t) {
                    let o = n[e],
                        h = t[e];
                    n[e] = o ? (e, t, n) => o(e, t, n) || h(e, t, n) : h
                }
                return n
            }
        })
    });
class NumberMarker extends GutterMarker {
    constructor(e) {
        super(), this.number = e
    }
    eq(e) {
        return this.number == e.number
    }
    toDOM() {
        return document.createTextNode(this.number)
    }
}

function formatNumber(e, t) {
    return e.state.facet(vn).formatNumber(t, e.state)
}
const Pn = wn.compute([vn], (e => ({
    class: "cm-lineNumbers",
    renderEmptyElements: !1,
    markers: e => e.state.facet(xn),
    lineMarker: (e, t, n) => n.some((e => e.toDOM)) ? null : new NumberMarker(formatNumber(e, e.state.doc.lineAt(t.from).number)),
    widgetMarker: (e, t, n) => {
        for (let o of e.state.facet(kn)) {
            let h = o(e, t, n);
            if (h) return h
        }
        return null
    },
    lineMarkerChange: e => e.startState.facet(vn) != e.state.facet(vn),
    initialSpacer: e => new NumberMarker(formatNumber(e, maxLineNumber(e.state.doc.lines))),
    updateSpacer(e, t) {
        let n = formatNumber(t.view, maxLineNumber(t.view.state.doc.lines));
        return n == e.number ? e : new NumberMarker(n)
    },
    domEventHandlers: e.facet(vn).domEventHandlers
})));

function lineNumbers(e = {}) {
    return [vn.of(e), gutters(), Pn]
}

function maxLineNumber(e) {
    let t = 9;
    for (; t < e;) t = 10 * t + 9;
    return t
}
const Cn = new class extends GutterMarker {
        constructor() {
            super(...arguments), this.elementClass = "cm-activeLineGutter"
        }
    },
    Qn = mn.compute(["selection"], (e => {
        let t = [],
            n = -1;
        for (let o of e.selection.ranges) {
            let h = e.doc.lineAt(o.head).from;
            h > n && (n = h, t.push(Cn.range(h)))
        }
        return RangeSet.of(t)
    }));

function highlightActiveLineGutter() {
    return Qn
}

function matcher(e) {
    return ViewPlugin.define((t => ({
        decorations: e.createDeco(t),
        update(t) {
            this.decorations = e.updateDeco(t, this.decorations)
        }
    })), {
        decorations: e => e.decorations
    })
}
const Tn = Decoration.mark({
        class: "cm-highlightTab"
    }),
    $n = Decoration.mark({
        class: "cm-highlightSpace"
    }),
    En = matcher(new MatchDecorator({
        regexp: /\t| /g,
        decoration: e => "\t" == e[0] ? Tn : $n,
        boundary: /\S/
    }));
const An = matcher(new MatchDecorator({
    regexp: /\s+$/g,
    decoration: Decoration.mark({
        class: "cm-trailingSpace"
    }),
    boundary: /\S/
}));
const Mn = {
    HeightMap: HeightMap,
    HeightOracle: HeightOracle,
    MeasuredHeights: MeasuredHeights,
    QueryType: dt,
    ChangedRange: ChangedRange,
    computeOrder: computeOrder,
    moveVisually: moveVisually,
    clearHeightChangeFlag: clearHeightChangeFlag,
    getHeightChangeFlag: () => ht
};
var Rn = Object.freeze({
    __proto__: null,
    BidiSpan: BidiSpan,
    BlockInfo: BlockInfo,
    get BlockType() {
        return ue
    },
    Decoration: Decoration,
    get Direction() {
        return pe
    },
    EditorView: EditorView,
    GutterMarker: GutterMarker,
    MatchDecorator: MatchDecorator,
    RectangleMarker: RectangleMarker,
    ViewPlugin: ViewPlugin,
    ViewUpdate: ViewUpdate,
    WidgetType: WidgetType,
    __test: Mn,
    closeHoverTooltips: un,
    crosshairCursor: crosshairCursor,
    drawSelection: drawSelection,
    dropCursor: dropCursor,
    getDrawSelectionConfig: function(e) {
        return e.facet(Dt)
    },
    getPanel: getPanel,
    getTooltip: getTooltip,
    gutter: gutter,
    gutterLineClass: mn,
    gutterWidgetClass: On,
    gutters: gutters,
    hasHoverTooltips: function(e) {
        return e.facet(ln).some((e => e))
    },
    highlightActiveLine: highlightActiveLine,
    highlightActiveLineGutter: highlightActiveLineGutter,
    highlightSpecialChars: highlightSpecialChars,
    highlightTrailingWhitespace: function() {
        return An
    },
    highlightWhitespace: function() {
        return En
    },
    hoverTooltip: hoverTooltip,
    keymap: Qt,
    layer: layer,
    lineNumberMarkers: xn,
    lineNumberWidgetMarker: kn,
    lineNumbers: lineNumbers,
    logException: logException,
    panels: function(e) {
        return e ? [pn.of(e)] : []
    },
    placeholder: function(e) {
        return ViewPlugin.fromClass(class {
            constructor(t) {
                this.view = t, this.placeholder = e ? Decoration.set([Decoration.widget({
                    widget: new Placeholder(e),
                    side: 1
                }).range(0)]) : Decoration.none
            }
            get decorations() {
                return this.view.state.doc.length ? Decoration.none : this.placeholder
            }
        }, {
            decorations: e => e.decorations
        })
    },
    rectangularSelection: function(e) {
        let t = (null == e ? void 0 : e.eventFilter) || (e => e.altKey && 0 == e.button);
        return EditorView.mouseSelectionStyle.of(((e, n) => t(n) ? rectangleSelectionStyle(e, n) : null))
    },
    repositionTooltips: function(e) {
        let t = e.plugin(rn);
        t && t.maybeMeasure()
    },
    runScopeHandlers: runScopeHandlers,
    scrollPastEnd: function() {
        return [Ut, Xe.of((e => {
            var t;
            return (null === (t = e.plugin(Ut)) || void 0 === t ? void 0 : t.attrs) || null
        }))]
    },
    showPanel: gn,
    showTooltip: an,
    tooltips: function(e = {}) {
        return tn.of(e)
    }
});
const Dn = 1024;
let Ln = 0;
class Range {
    constructor(e, t) {
        this.from = e, this.to = t
    }
}
class NodeProp {
    constructor(e = {}) {
        this.id = Ln++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function")
        }), this.combine = e.combine || null
    }
    add(e) {
        if (this.perNode) throw new RangeError("Can't add per-node props to node types");
        return "function" != typeof e && (e = NodeType.match(e)), t => {
            let n = e(t);
            return void 0 === n ? null : [this, n]
        }
    }
}
NodeProp.closedBy = new NodeProp({
    deserialize: e => e.split(" ")
}), NodeProp.openedBy = new NodeProp({
    deserialize: e => e.split(" ")
}), NodeProp.group = new NodeProp({
    deserialize: e => e.split(" ")
}), NodeProp.isolate = new NodeProp({
    deserialize: e => {
        if (e && "rtl" != e && "ltr" != e && "auto" != e) throw new RangeError("Invalid value for isolate: " + e);
        return e || "auto"
    }
}), NodeProp.contextHash = new NodeProp({
    perNode: !0
}), NodeProp.lookAhead = new NodeProp({
    perNode: !0
}), NodeProp.mounted = new NodeProp({
    perNode: !0
});
class MountedTree {
    constructor(e, t, n, o = !1) {
        this.tree = e, this.overlay = t, this.parser = n, this.bracketed = o
    }
    static get(e) {
        return e && e.props && e.props[NodeProp.mounted.id]
    }
}
const Vn = Object.create(null);
class NodeType {
    constructor(e, t, n, o = 0) {
        this.name = e, this.props = t, this.id = n, this.flags = o
    }
    static define(e) {
        let t = e.props && e.props.length ? Object.create(null) : Vn,
            n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (null == e.name ? 8 : 0),
            o = new NodeType(e.name || "", t, e.id, n);
        if (e.props)
            for (let n of e.props)
                if (Array.isArray(n) || (n = n(o)), n) {
                    if (n[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
                    t[n[0].id] = n[1]
                }
        return o
    }
    prop(e) {
        return this.props[e.id]
    }
    get isTop() {
        return (1 & this.flags) > 0
    }
    get isSkipped() {
        return (2 & this.flags) > 0
    }
    get isError() {
        return (4 & this.flags) > 0
    }
    get isAnonymous() {
        return (8 & this.flags) > 0
    }
    is(e) {
        if ("string" == typeof e) {
            if (this.name == e) return !0;
            let t = this.prop(NodeProp.group);
            return !!t && t.indexOf(e) > -1
        }
        return this.id == e
    }
    static match(e) {
        let t = Object.create(null);
        for (let n in e)
            for (let o of n.split(" ")) t[o] = e[n];
        return e => {
            for (let n = e.prop(NodeProp.group), o = -1; o < (n ? n.length : 0); o++) {
                let h = t[o < 0 ? e.name : n[o]];
                if (h) return h
            }
        }
    }
}
NodeType.none = new NodeType("", Object.create(null), 0, 8);
class NodeSet {
    constructor(e) {
        this.types = e;
        for (let t = 0; t < e.length; t++)
            if (e[t].id != t) throw new RangeError("Node type ids should correspond to array positions when creating a node set")
    }
    extend(...e) {
        let t = [];
        for (let n of this.types) {
            let o = null;
            for (let t of e) {
                let e = t(n);
                if (e) {
                    o || (o = Object.assign({}, n.props));
                    let t = e[1],
                        h = e[0];
                    h.combine && h.id in o && (t = h.combine(o[h.id], t)), o[h.id] = t
                }
            }
            t.push(o ? new NodeType(n.name, o, n.id, n.flags) : n)
        }
        return new NodeSet(t)
    }
}
const Zn = new WeakMap,
    _n = new WeakMap;
var Bn;
! function(e) {
    e[e.ExcludeBuffers = 1] = "ExcludeBuffers", e[e.IncludeAnonymous = 2] = "IncludeAnonymous", e[e.IgnoreMounts = 4] = "IgnoreMounts", e[e.IgnoreOverlays = 8] = "IgnoreOverlays", e[e.EnterBracketed = 16] = "EnterBracketed"
}(Bn || (Bn = {}));
class Tree {
    constructor(e, t, n, o, h) {
        if (this.type = e, this.children = t, this.positions = n, this.length = o, this.props = null, h && h.length) {
            this.props = Object.create(null);
            for (let [e, t] of h) this.props["number" == typeof e ? e : e.id] = t
        }
    }
    toString() {
        let e = MountedTree.get(this);
        if (e && !e.overlay) return e.tree.toString();
        let t = "";
        for (let e of this.children) {
            let n = e.toString();
            n && (t && (t += ","), t += n)
        }
        return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t
    }
    cursor(e = 0) {
        return new TreeCursor(this.topNode, e)
    }
    cursorAt(e, t = 0, n = 0) {
        let o = Zn.get(this) || this.topNode,
            h = new TreeCursor(o);
        return h.moveTo(e, t), Zn.set(this, h._tree), h
    }
    get topNode() {
        return new TreeNode(this, 0, 0, null)
    }
    resolve(e, t = 0) {
        let n = resolveNode(Zn.get(this) || this.topNode, e, t, !1);
        return Zn.set(this, n), n
    }
    resolveInner(e, t = 0) {
        let n = resolveNode(_n.get(this) || this.topNode, e, t, !0);
        return _n.set(this, n), n
    }
    resolveStack(e, t = 0) {
        return function(e, t, n) {
            let o = e.resolveInner(t, n),
                h = null;
            for (let e = o instanceof TreeNode ? o : o.context.parent; e; e = e.parent)
                if (e.index < 0) {
                    let p = e.parent;
                    (h || (h = [o])).push(p.resolve(t, n)), e = p
                } else {
                    let p = MountedTree.get(e.tree);
                    if (p && p.overlay && p.overlay[0].from <= t && p.overlay[p.overlay.length - 1].to >= t) {
                        let f = new TreeNode(p.tree, p.overlay[0].from + e.from, -1, e);
                        (h || (h = [o])).push(resolveNode(f, t, n, !1))
                    }
                }
            return h ? iterStack(h) : o
        }(this, e, t)
    }
    iterate(e) {
        let {
            enter: t,
            leave: n,
            from: o = 0,
            to: h = this.length
        } = e, p = e.mode || 0, f = (p & Bn.IncludeAnonymous) > 0;
        for (let e = this.cursor(p | Bn.IncludeAnonymous);;) {
            let p = !1;
            if (e.from <= h && e.to >= o && (!f && e.type.isAnonymous || !1 !== t(e))) {
                if (e.firstChild()) continue;
                p = !0
            }
            for (; p && n && (f || !e.type.isAnonymous) && n(e), !e.nextSibling();) {
                if (!e.parent()) return;
                p = !0
            }
        }
    }
    prop(e) {
        return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e)
    }
    get propValues() {
        let e = [];
        if (this.props)
            for (let t in this.props) e.push([+t, this.props[t]]);
        return e
    }
    balance(e = {}) {
        return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, ((e, t, n) => new Tree(this.type, e, t, n, this.propValues)), e.makeTree || ((e, t, n) => new Tree(NodeType.none, e, t, n)))
    }
    static build(e) {
        return function(e) {
            var t;
            let {
                buffer: n,
                nodeSet: o,
                maxBufferLength: h = Dn,
                reused: p = [],
                minRepeatType: f = o.types.length
            } = e, g = Array.isArray(n) ? new FlatBufferCursor(n, n.length) : n, y = o.types, w = 0, b = 0;

            function takeNode(e, t, n, S, k, v) {
                let {
                    id: P,
                    start: C,
                    end: Q,
                    size: $
                } = g, A = b, M = w;
                if ($ < 0) {
                    if (g.next(), -1 == $) {
                        let t = p[P];
                        return n.push(t), void S.push(C - e)
                    }
                    if (-3 == $) return void(w = P);
                    if (-4 == $) return void(b = P);
                    throw new RangeError(`Unrecognized record size: ${$}`)
                }
                let R, D, L = y[P],
                    V = C - e;
                if (Q - C <= h && (D = findBufferSize(g.pos - t, k))) {
                    let t = new Uint16Array(D.size - D.skip),
                        n = g.pos - D.size,
                        h = t.length;
                    for (; g.pos > n;) h = copyToBuffer(D.start, t, h);
                    R = new TreeBuffer(t, Q - D.start, o), V = D.start - e
                } else {
                    let e = g.pos - $;
                    g.next();
                    let t = [],
                        n = [],
                        o = P >= f ? P : -1,
                        p = 0,
                        y = Q;
                    for (; g.pos > e;) o >= 0 && g.id == o && g.size >= 0 ? (g.end <= y - h && (makeRepeatLeaf(t, n, C, p, g.end, y, o, A, M), p = t.length, y = g.end), g.next()) : v > 2500 ? takeFlatNode(C, e, t, n) : takeNode(C, e, t, n, o, v + 1);
                    if (o >= 0 && p > 0 && p < t.length && makeRepeatLeaf(t, n, C, p, C, y, o, A, M), t.reverse(), n.reverse(), o > -1 && p > 0) {
                        let e = makeBalanced(L, M);
                        R = balanceRange(L, t, n, 0, t.length, 0, Q - C, e, e)
                    } else R = makeTree(L, t, n, Q - C, A - Q, M)
                }
                n.push(R), S.push(V)
            }

            function takeFlatNode(e, t, n, p) {
                let f = [],
                    y = 0,
                    w = -1;
                for (; g.pos > t;) {
                    let {
                        id: e,
                        start: t,
                        end: n,
                        size: o
                    } = g;
                    if (o > 4) g.next();
                    else {
                        if (w > -1 && t < w) break;
                        w < 0 && (w = n - h), f.push(e, t, n), y++, g.next()
                    }
                }
                if (y) {
                    let t = new Uint16Array(4 * y),
                        h = f[f.length - 2];
                    for (let e = f.length - 3, n = 0; e >= 0; e -= 3) t[n++] = f[e], t[n++] = f[e + 1] - h, t[n++] = f[e + 2] - h, t[n++] = n;
                    n.push(new TreeBuffer(t, f[2] - h, o)), p.push(h - e)
                }
            }

            function makeBalanced(e, t) {
                return (n, o, h) => {
                    let p, f, g = 0,
                        y = n.length - 1;
                    if (y >= 0 && (p = n[y]) instanceof Tree) {
                        if (!y && p.type == e && p.length == h) return p;
                        (f = p.prop(NodeProp.lookAhead)) && (g = o[y] + p.length + f)
                    }
                    return makeTree(e, n, o, h, g, t)
                }
            }

            function makeRepeatLeaf(e, t, n, h, p, f, g, y, w) {
                let b = [],
                    S = [];
                for (; e.length > h;) b.push(e.pop()), S.push(t.pop() + n - p);
                e.push(makeTree(o.types[g], b, S, f - p, y - f, w)), t.push(p - n)
            }

            function makeTree(e, t, n, o, h, p, f) {
                if (p) {
                    let e = [NodeProp.contextHash, p];
                    f = f ? [e].concat(f) : [e]
                }
                if (h > 25) {
                    let e = [NodeProp.lookAhead, h];
                    f = f ? [e].concat(f) : [e]
                }
                return new Tree(e, t, n, o, f)
            }

            function findBufferSize(e, t) {
                let n = g.fork(),
                    o = 0,
                    p = 0,
                    y = 0,
                    w = n.end - h,
                    b = {
                        size: 0,
                        start: 0,
                        skip: 0
                    };
                e: for (let h = n.pos - e; n.pos > h;) {
                    let e = n.size;
                    if (n.id == t && e >= 0) {
                        b.size = o, b.start = p, b.skip = y, y += 4, o += 4, n.next();
                        continue
                    }
                    let g = n.pos - e;
                    if (e < 0 || g < h || n.start < w) break;
                    let S = n.id >= f ? 4 : 0,
                        k = n.start;
                    for (n.next(); n.pos > g;) {
                        if (n.size < 0) {
                            if (-3 != n.size && -4 != n.size) break e;
                            S += 4
                        } else n.id >= f && (S += 4);
                        n.next()
                    }
                    p = k, o += e, y += S
                }
                return (t < 0 || o == e) && (b.size = o, b.start = p, b.skip = y), b.size > 4 ? b : void 0
            }

            function copyToBuffer(e, t, n) {
                let {
                    id: o,
                    start: h,
                    end: p,
                    size: y
                } = g;
                if (g.next(), y >= 0 && o < f) {
                    let f = n;
                    if (y > 4) {
                        let o = g.pos - (y - 4);
                        for (; g.pos > o;) n = copyToBuffer(e, t, n)
                    }
                    t[--n] = f, t[--n] = p - e, t[--n] = h - e, t[--n] = o
                } else -3 == y ? w = o : -4 == y && (b = o);
                return n
            }
            let S = [],
                k = [];
            for (; g.pos > 0;) takeNode(e.start || 0, e.bufferStart || 0, S, k, -1, 0);
            let v = null !== (t = e.length) && void 0 !== t ? t : S.length ? k[0] + S[0].length : 0;
            return new Tree(y[e.topID], S.reverse(), k.reverse(), v)
        }(e)
    }
}
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(e, t) {
        this.buffer = e, this.index = t
    }
    get id() {
        return this.buffer[this.index - 4]
    }
    get start() {
        return this.buffer[this.index - 3]
    }
    get end() {
        return this.buffer[this.index - 2]
    }
    get size() {
        return this.buffer[this.index - 1]
    }
    get pos() {
        return this.index
    }
    next() {
        this.index -= 4
    }
    fork() {
        return new FlatBufferCursor(this.buffer, this.index)
    }
}
class TreeBuffer {
    constructor(e, t, n) {
        this.buffer = e, this.length = t, this.set = n
    }
    get type() {
        return NodeType.none
    }
    toString() {
        let e = [];
        for (let t = 0; t < this.buffer.length;) e.push(this.childString(t)), t = this.buffer[t + 3];
        return e.join(",")
    }
    childString(e) {
        let t = this.buffer[e],
            n = this.buffer[e + 3],
            o = this.set.types[t],
            h = o.name;
        if (/\W/.test(h) && !o.isError && (h = JSON.stringify(h)), n == (e += 4)) return h;
        let p = [];
        for (; e < n;) p.push(this.childString(e)), e = this.buffer[e + 3];
        return h + "(" + p.join(",") + ")"
    }
    findChild(e, t, n, o, h) {
        let {
            buffer: p
        } = this, f = -1;
        for (let g = e; g != t && !(checkSide(h, o, p[g + 1], p[g + 2]) && (f = g, n > 0)); g = p[g + 3]);
        return f
    }
    slice(e, t, n) {
        let o = this.buffer,
            h = new Uint16Array(t - e),
            p = 0;
        for (let f = e, g = 0; f < t;) {
            h[g++] = o[f++], h[g++] = o[f++] - n;
            let t = h[g++] = o[f++] - n;
            h[g++] = o[f++] - e, p = Math.max(p, t)
        }
        return new TreeBuffer(h, p, this.set)
    }
}

function checkSide(e, t, n, o) {
    switch (e) {
        case -2:
            return n < t;
        case -1:
            return o >= t && n < t;
        case 0:
            return n < t && o > t;
        case 1:
            return n <= t && o > t;
        case 2:
            return o > t;
        case 4:
            return !0
    }
}

function resolveNode(e, t, n, o) {
    for (var h; e.from == e.to || (n < 1 ? e.from >= t : e.from > t) || (n > -1 ? e.to <= t : e.to < t);) {
        let t = !o && e instanceof TreeNode && e.index < 0 ? null : e.parent;
        if (!t) return e;
        e = t
    }
    let p = o ? 0 : Bn.IgnoreOverlays;
    if (o)
        for (let o = e, f = o.parent; f; o = f, f = o.parent) o instanceof TreeNode && o.index < 0 && (null === (h = f.enter(t, n, p)) || void 0 === h ? void 0 : h.from) != o.from && (e = f);
    for (;;) {
        let o = e.enter(t, n, p);
        if (!o) return e;
        e = o
    }
}
class BaseNode {
    cursor(e = 0) {
        return new TreeCursor(this, e)
    }
    getChild(e, t = null, n = null) {
        let o = getChildren(this, e, t, n);
        return o.length ? o[0] : null
    }
    getChildren(e, t = null, n = null) {
        return getChildren(this, e, t, n)
    }
    resolve(e, t = 0) {
        return resolveNode(this, e, t, !1)
    }
    resolveInner(e, t = 0) {
        return resolveNode(this, e, t, !0)
    }
    matchContext(e) {
        return matchNodeContext(this.parent, e)
    }
    enterUnfinishedNodesBefore(e) {
        let t = this.childBefore(e),
            n = this;
        for (; t;) {
            let e = t.lastChild;
            if (!e || e.to != t.to) break;
            e.type.isError && e.from == e.to ? (n = t, t = e.prevSibling) : t = e
        }
        return n
    }
    get node() {
        return this
    }
    get next() {
        return this.parent
    }
}
class TreeNode extends BaseNode {
    constructor(e, t, n, o) {
        super(), this._tree = e, this.from = t, this.index = n, this._parent = o
    }
    get type() {
        return this._tree.type
    }
    get name() {
        return this._tree.type.name
    }
    get to() {
        return this.from + this._tree.length
    }
    nextChild(e, t, n, o, h = 0) {
        var p;
        for (let f = this;;) {
            for (let {
                    children: g,
                    positions: y
                } = f._tree, w = t > 0 ? g.length : -1; e != w; e += t) {
                let w = g[e],
                    b = y[e] + f.from;
                if (h & Bn.EnterBracketed && w instanceof Tree && null === (null === (p = MountedTree.get(w)) || void 0 === p ? void 0 : p.overlay) && (b >= n || b + w.length <= n) || checkSide(o, n, b, b + w.length))
                    if (w instanceof TreeBuffer) {
                        if (h & Bn.ExcludeBuffers) continue;
                        let p = w.findChild(0, w.buffer.length, t, n - b, o);
                        if (p > -1) return new BufferNode(new BufferContext(f, w, e, b), null, p)
                    } else if (h & Bn.IncludeAnonymous || !w.type.isAnonymous || hasChild(w)) {
                    let p;
                    if (!(h & Bn.IgnoreMounts) && (p = MountedTree.get(w)) && !p.overlay) return new TreeNode(p.tree, b, e, f);
                    let g = new TreeNode(w, b, e, f);
                    return h & Bn.IncludeAnonymous || !g.type.isAnonymous ? g : g.nextChild(t < 0 ? w.children.length - 1 : 0, t, n, o, h)
                }
            }
            if (h & Bn.IncludeAnonymous || !f.type.isAnonymous) return null;
            if (e = f.index >= 0 ? f.index + t : t < 0 ? -1 : f._parent._tree.children.length, f = f._parent, !f) return null
        }
    }
    get firstChild() {
        return this.nextChild(0, 1, 0, 4)
    }
    get lastChild() {
        return this.nextChild(this._tree.children.length - 1, -1, 0, 4)
    }
    childAfter(e) {
        return this.nextChild(0, 1, e, 2)
    }
    childBefore(e) {
        return this.nextChild(this._tree.children.length - 1, -1, e, -2)
    }
    prop(e) {
        return this._tree.prop(e)
    }
    enter(e, t, n = 0) {
        let o;
        if (!(n & Bn.IgnoreOverlays) && (o = MountedTree.get(this._tree)) && o.overlay) {
            let h = e - this.from,
                p = n & Bn.EnterBracketed && o.bracketed;
            for (let {
                    from: e,
                    to: n
                } of o.overlay)
                if ((t > 0 || p ? e <= h : e < h) && (t < 0 || p ? n >= h : n > h)) return new TreeNode(o.tree, o.overlay[0].from + this.from, -1, this)
        }
        return this.nextChild(0, 1, e, t, n)
    }
    nextSignificantParent() {
        let e = this;
        for (; e.type.isAnonymous && e._parent;) e = e._parent;
        return e
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null
    }
    get tree() {
        return this._tree
    }
    toTree() {
        return this._tree
    }
    toString() {
        return this._tree.toString()
    }
}

function getChildren(e, t, n, o) {
    let h = e.cursor(),
        p = [];
    if (!h.firstChild()) return p;
    if (null != n)
        for (let e = !1; !e;)
            if (e = h.type.is(n), !h.nextSibling()) return p;
    for (;;) {
        if (null != o && h.type.is(o)) return p;
        if (h.type.is(t) && p.push(h.node), !h.nextSibling()) return null == o ? p : []
    }
}

function matchNodeContext(e, t, n = t.length - 1) {
    for (let o = e; n >= 0; o = o.parent) {
        if (!o) return !1;
        if (!o.type.isAnonymous) {
            if (t[n] && t[n] != o.name) return !1;
            n--
        }
    }
    return !0
}
class BufferContext {
    constructor(e, t, n, o) {
        this.parent = e, this.buffer = t, this.index = n, this.start = o
    }
}
class BufferNode extends BaseNode {
    get name() {
        return this.type.name
    }
    get from() {
        return this.context.start + this.context.buffer.buffer[this.index + 1]
    }
    get to() {
        return this.context.start + this.context.buffer.buffer[this.index + 2]
    }
    constructor(e, t, n) {
        super(), this.context = e, this._parent = t, this.index = n, this.type = e.buffer.set.types[e.buffer.buffer[n]]
    }
    child(e, t, n) {
        let {
            buffer: o
        } = this.context, h = o.findChild(this.index + 4, o.buffer[this.index + 3], e, t - this.context.start, n);
        return h < 0 ? null : new BufferNode(this.context, this, h)
    }
    get firstChild() {
        return this.child(1, 0, 4)
    }
    get lastChild() {
        return this.child(-1, 0, 4)
    }
    childAfter(e) {
        return this.child(1, e, 2)
    }
    childBefore(e) {
        return this.child(-1, e, -2)
    }
    prop(e) {
        return this.type.prop(e)
    }
    enter(e, t, n = 0) {
        if (n & Bn.ExcludeBuffers) return null;
        let {
            buffer: o
        } = this.context, h = o.findChild(this.index + 4, o.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
        return h < 0 ? null : new BufferNode(this.context, this, h)
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent()
    }
    externalSibling(e) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4)
    }
    get nextSibling() {
        let {
            buffer: e
        } = this.context, t = e.buffer[this.index + 3];
        return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new BufferNode(this.context, this._parent, t) : this.externalSibling(1)
    }
    get prevSibling() {
        let {
            buffer: e
        } = this.context, t = this._parent ? this._parent.index + 4 : 0;
        return this.index == t ? this.externalSibling(-1) : new BufferNode(this.context, this._parent, e.findChild(t, this.index, -1, 0, 4))
    }
    get tree() {
        return null
    }
    toTree() {
        let e = [],
            t = [],
            {
                buffer: n
            } = this.context,
            o = this.index + 4,
            h = n.buffer[this.index + 3];
        if (h > o) {
            let p = n.buffer[this.index + 1];
            e.push(n.slice(o, h, p)), t.push(0)
        }
        return new Tree(this.type, e, t, this.to - this.from)
    }
    toString() {
        return this.context.buffer.childString(this.index)
    }
}

function iterStack(e) {
    if (!e.length) return null;
    let t = 0,
        n = e[0];
    for (let o = 1; o < e.length; o++) {
        let h = e[o];
        (h.from > n.from || h.to < n.to) && (n = h, t = o)
    }
    let o = n instanceof TreeNode && n.index < 0 ? null : n.parent,
        h = e.slice();
    return o ? h[t] = o : h.splice(t, 1), new StackIterator(h, n)
}
class StackIterator {
    constructor(e, t) {
        this.heads = e, this.node = t
    }
    get next() {
        return iterStack(this.heads)
    }
}
class TreeCursor {
    get name() {
        return this.type.name
    }
    constructor(e, t = 0) {
        if (this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, this.mode = t & ~Bn.EnterBracketed, e instanceof TreeNode) this.yieldNode(e);
        else {
            this._tree = e.context.parent, this.buffer = e.context;
            for (let t = e._parent; t; t = t._parent) this.stack.unshift(t.index);
            this.bufferNode = e, this.yieldBuf(e.index)
        }
    }
    yieldNode(e) {
        return !!e && (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0)
    }
    yieldBuf(e, t) {
        this.index = e;
        let {
            start: n,
            buffer: o
        } = this.buffer;
        return this.type = t || o.set.types[o.buffer[e]], this.from = n + o.buffer[e + 1], this.to = n + o.buffer[e + 2], !0
    }
    yield(e) {
        return !!e && (e instanceof TreeNode ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)))
    }
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()
    }
    enterChild(e, t, n) {
        if (!this.buffer) return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, n, this.mode));
        let {
            buffer: o
        } = this.buffer, h = o.findChild(this.index + 4, o.buffer[this.index + 3], e, t - this.buffer.start, n);
        return !(h < 0) && (this.stack.push(this.index), this.yieldBuf(h))
    }
    firstChild() {
        return this.enterChild(1, 0, 4)
    }
    lastChild() {
        return this.enterChild(-1, 0, 4)
    }
    childAfter(e) {
        return this.enterChild(1, e, 2)
    }
    childBefore(e) {
        return this.enterChild(-1, e, -2)
    }
    enter(e, t, n = this.mode) {
        return this.buffer ? !(n & Bn.ExcludeBuffers) && this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, n))
    }
    parent() {
        if (!this.buffer) return this.yieldNode(this.mode & Bn.IncludeAnonymous ? this._tree._parent : this._tree.parent);
        if (this.stack.length) return this.yieldBuf(this.stack.pop());
        let e = this.mode & Bn.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        return this.buffer = null, this.yieldNode(e)
    }
    sibling(e) {
        if (!this.buffer) return !!this._tree._parent && this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode));
        let {
            buffer: t
        } = this.buffer, n = this.stack.length - 1;
        if (e < 0) {
            let e = n < 0 ? 0 : this.stack[n] + 4;
            if (this.index != e) return this.yieldBuf(t.findChild(e, this.index, -1, 0, 4))
        } else {
            let e = t.buffer[this.index + 3];
            if (e < (n < 0 ? t.buffer.length : t.buffer[this.stack[n] + 3])) return this.yieldBuf(e)
        }
        return n < 0 && this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode))
    }
    nextSibling() {
        return this.sibling(1)
    }
    prevSibling() {
        return this.sibling(-1)
    }
    atLastNode(e) {
        let t, n, {
            buffer: o
        } = this;
        if (o) {
            if (e > 0) {
                if (this.index < o.buffer.buffer.length) return !1
            } else
                for (let e = 0; e < this.index; e++)
                    if (o.buffer.buffer[e + 3] < this.index) return !1;
            ({
                index: t,
                parent: n
            } = o)
        } else({
            index: t,
            _parent: n
        } = this._tree);
        for (; n;
            ({
                index: t,
                _parent: n
            } = n))
            if (t > -1)
                for (let o = t + e, h = e < 0 ? -1 : n._tree.children.length; o != h; o += e) {
                    let e = n._tree.children[o];
                    if (this.mode & Bn.IncludeAnonymous || e instanceof TreeBuffer || !e.type.isAnonymous || hasChild(e)) return !1
                }
        return !0
    }
    move(e, t) {
        if (t && this.enterChild(e, 0, 4)) return !0;
        for (;;) {
            if (this.sibling(e)) return !0;
            if (this.atLastNode(e) || !this.parent()) return !1
        }
    }
    next(e = !0) {
        return this.move(1, e)
    }
    prev(e = !0) {
        return this.move(-1, e)
    }
    moveTo(e, t = 0) {
        for (;
            (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(););
        for (; this.enterChild(1, e, t););
        return this
    }
    get node() {
        if (!this.buffer) return this._tree;
        let e = this.bufferNode,
            t = null,
            n = 0;
        if (e && e.context == this.buffer) e: for (let o = this.index, h = this.stack.length; h >= 0;) {
            for (let p = e; p; p = p._parent)
                if (p.index == o) {
                    if (o == this.index) return p;
                    t = p, n = h + 1;
                    break e
                }
            o = this.stack[--h]
        }
        for (let e = n; e < this.stack.length; e++) t = new BufferNode(this.buffer, t, this.stack[e]);
        return this.bufferNode = new BufferNode(this.buffer, t, this.index)
    }
    get tree() {
        return this.buffer ? null : this._tree._tree
    }
    iterate(e, t) {
        for (let n = 0;;) {
            let o = !1;
            if (this.type.isAnonymous || !1 !== e(this)) {
                if (this.firstChild()) {
                    n++;
                    continue
                }
                this.type.isAnonymous || (o = !0)
            }
            for (;;) {
                if (o && t && t(this), o = this.type.isAnonymous, !n) return;
                if (this.nextSibling()) break;
                this.parent(), n--, o = !0
            }
        }
    }
    matchContext(e) {
        if (!this.buffer) return matchNodeContext(this.node.parent, e);
        let {
            buffer: t
        } = this.buffer, {
            types: n
        } = t.set;
        for (let o = e.length - 1, h = this.stack.length - 1; o >= 0; h--) {
            if (h < 0) return matchNodeContext(this._tree, e, o);
            let p = n[t.buffer[this.stack[h]]];
            if (!p.isAnonymous) {
                if (e[o] && e[o] != p.name) return !1;
                o--
            }
        }
        return !0
    }
}

function hasChild(e) {
    return e.children.some((e => e instanceof TreeBuffer || !e.type.isAnonymous || hasChild(e)))
}
const In = new WeakMap;

function nodeSize(e, t) {
    if (!e.isAnonymous || t instanceof TreeBuffer || t.type != e) return 1;
    let n = In.get(t);
    if (null == n) {
        n = 1;
        for (let o of t.children) {
            if (o.type != e || !(o instanceof Tree)) {
                n = 1;
                break
            }
            n += nodeSize(e, o)
        }
        In.set(t, n)
    }
    return n
}

function balanceRange(e, t, n, o, h, p, f, g, y) {
    let w = 0;
    for (let n = o; n < h; n++) w += nodeSize(e, t[n]);
    let b = Math.ceil(1.5 * w / 8),
        S = [],
        k = [];
    return function divide(t, n, o, h, f) {
        for (let g = o; g < h;) {
            let o = g,
                w = n[g],
                v = nodeSize(e, t[g]);
            for (g++; g < h; g++) {
                let n = nodeSize(e, t[g]);
                if (v + n >= b) break;
                v += n
            }
            if (g == o + 1) {
                if (v > b) {
                    let e = t[o];
                    divide(e.children, e.positions, 0, e.children.length, n[o] + f);
                    continue
                }
                S.push(t[o])
            } else {
                let h = n[g - 1] + t[g - 1].length - w;
                S.push(balanceRange(e, t, n, o, g, w, h, null, y))
            }
            k.push(w + f - p)
        }
    }(t, n, o, h, 0), (g || y)(S, k, f)
}
class NodeWeakMap {
    constructor() {
        this.map = new WeakMap
    }
    setBuffer(e, t, n) {
        let o = this.map.get(e);
        o || this.map.set(e, o = new Map), o.set(t, n)
    }
    getBuffer(e, t) {
        let n = this.map.get(e);
        return n && n.get(t)
    }
    set(e, t) {
        e instanceof BufferNode ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof TreeNode && this.map.set(e.tree, t)
    }
    get(e) {
        return e instanceof BufferNode ? this.getBuffer(e.context.buffer, e.index) : e instanceof TreeNode ? this.map.get(e.tree) : void 0
    }
    cursorSet(e, t) {
        e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t)
    }
    cursorGet(e) {
        return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree)
    }
}
class TreeFragment {
    constructor(e, t, n, o, h = !1, p = !1) {
        this.from = e, this.to = t, this.tree = n, this.offset = o, this.open = (h ? 1 : 0) | (p ? 2 : 0)
    }
    get openStart() {
        return (1 & this.open) > 0
    }
    get openEnd() {
        return (2 & this.open) > 0
    }
    static addTree(e, t = [], n = !1) {
        let o = [new TreeFragment(0, e.length, e, 0, !1, n)];
        for (let n of t) n.to > e.length && o.push(n);
        return o
    }
    static applyChanges(e, t, n = 128) {
        if (!t.length) return e;
        let o = [],
            h = 1,
            p = e.length ? e[0] : null;
        for (let f = 0, g = 0, y = 0;; f++) {
            let w = f < t.length ? t[f] : null,
                b = w ? w.fromA : 1e9;
            if (b - g >= n)
                for (; p && p.from < b;) {
                    let t = p;
                    if (g >= t.from || b <= t.to || y) {
                        let e = Math.max(t.from, g) - y,
                            n = Math.min(t.to, b) - y;
                        t = e >= n ? null : new TreeFragment(e, n, t.tree, t.offset + y, f > 0, !!w)
                    }
                    if (t && o.push(t), p.to > b) break;
                    p = h < e.length ? e[h++] : null
                }
            if (!w) break;
            g = w.toA, y = w.toA - w.toB
        }
        return o
    }
}
class Parser {
    startParse(e, t, n) {
        return "string" == typeof e && (e = new StringInput(e)), n = n ? n.length ? n.map((e => new Range(e.from, e.to))) : [new Range(0, 0)] : [new Range(0, e.length)], this.createParse(e, t || [], n)
    }
    parse(e, t, n) {
        let o = this.startParse(e, t, n);
        for (;;) {
            let e = o.advance();
            if (e) return e
        }
    }
}
class StringInput {
    constructor(e) {
        this.string = e
    }
    get length() {
        return this.string.length
    }
    chunk(e) {
        return this.string.slice(e)
    }
    get lineChunks() {
        return !1
    }
    read(e, t) {
        return this.string.slice(e, t)
    }
}

function parseMixed(e) {
    return (t, n, o, h) => new MixedParse(t, e, n, o, h)
}
class InnerParse {
    constructor(e, t, n, o, h, p) {
        this.parser = e, this.parse = t, this.overlay = n, this.bracketed = o, this.target = h, this.from = p
    }
}

function checkRanges(e) {
    if (!e.length || e.some((e => e.from >= e.to))) throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(e))
}
class ActiveOverlay {
    constructor(e, t, n, o, h, p, f, g) {
        this.parser = e, this.predicate = t, this.mounts = n, this.index = o, this.start = h, this.bracketed = p, this.target = f, this.prev = g, this.depth = 0, this.ranges = []
    }
}
const Xn = new NodeProp({
    perNode: !0
});
class MixedParse {
    constructor(e, t, n, o, h) {
        this.nest = t, this.input = n, this.fragments = o, this.ranges = h, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e
    }
    advance() {
        if (this.baseParse) {
            let e = this.baseParse.advance();
            if (!e) return null;
            if (this.baseParse = null, this.baseTree = e, this.startInner(), null != this.stoppedAt)
                for (let e of this.inner) e.parse.stopAt(this.stoppedAt)
        }
        if (this.innerDone == this.inner.length) {
            let e = this.baseTree;
            return null != this.stoppedAt && (e = new Tree(e.type, e.children, e.positions, e.length, e.propValues.concat([
                [Xn, this.stoppedAt]
            ]))), e
        }
        let e = this.inner[this.innerDone],
            t = e.parse.advance();
        if (t) {
            this.innerDone++;
            let n = Object.assign(Object.create(null), e.target.props);
            n[NodeProp.mounted.id] = new MountedTree(t, e.overlay, e.parser, e.bracketed), e.target.props = n
        }
        return null
    }
    get parsedPos() {
        if (this.baseParse) return 0;
        let e = this.input.length;
        for (let t = this.innerDone; t < this.inner.length; t++) this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
        return e
    }
    stopAt(e) {
        if (this.stoppedAt = e, this.baseParse) this.baseParse.stopAt(e);
        else
            for (let t = this.innerDone; t < this.inner.length; t++) this.inner[t].parse.stopAt(e)
    }
    startInner() {
        let e = new qn(this.fragments),
            t = null,
            n = null,
            o = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), Bn.IncludeAnonymous | Bn.IgnoreMounts);
        e: for (let h, p;;) {
            let f, g = !0;
            if (null != this.stoppedAt && o.from >= this.stoppedAt) g = !1;
            else if (e.hasNode(o)) {
                if (t) {
                    let e = t.mounts.find((e => e.frag.from <= o.from && e.frag.to >= o.to && e.mount.overlay));
                    if (e)
                        for (let n of e.mount.overlay) {
                            let h = n.from + e.pos,
                                p = n.to + e.pos;
                            h >= o.from && p <= o.to && !t.ranges.some((e => e.from < p && e.to > h)) && t.ranges.push({
                                from: h,
                                to: p
                            })
                        }
                }
                g = !1
            } else if (n && (p = checkCover(n.ranges, o.from, o.to))) g = 2 != p;
            else if (!o.type.isAnonymous && (h = this.nest(o, this.input)) && (o.from < o.to || !h.overlay)) {
                o.tree || (materialize(o), t && t.depth++, n && n.depth++);
                let p = e.findMounts(o.from, h.parser);
                if ("function" == typeof h.overlay) t = new ActiveOverlay(h.parser, h.overlay, p, this.inner.length, o.from, !!h.bracketed, o.tree, t);
                else {
                    let e = punchRanges(this.ranges, h.overlay || (o.from < o.to ? [new Range(o.from, o.to)] : []));
                    e.length && checkRanges(e), !e.length && h.overlay || this.inner.push(new InnerParse(h.parser, e.length ? h.parser.startParse(this.input, enterFragments(p, e), e) : h.parser.startParse(""), h.overlay ? h.overlay.map((e => new Range(e.from - o.from, e.to - o.from))) : null, !!h.bracketed, o.tree, e.length ? e[0].from : o.from)), h.overlay ? e.length && (n = {
                        ranges: e,
                        depth: 0,
                        prev: n
                    }) : g = !1
                }
            } else if (t && (f = t.predicate(o)) && (!0 === f && (f = new Range(o.from, o.to)), f.from < f.to)) {
                let e = t.ranges.length - 1;
                e >= 0 && t.ranges[e].to == f.from ? t.ranges[e] = {
                    from: t.ranges[e].from,
                    to: f.to
                } : t.ranges.push(f)
            }
            if (g && o.firstChild()) t && t.depth++, n && n.depth++;
            else
                for (; !o.nextSibling();) {
                    if (!o.parent()) break e;
                    if (t && !--t.depth) {
                        let e = punchRanges(this.ranges, t.ranges);
                        e.length && (checkRanges(e), this.inner.splice(t.index, 0, new InnerParse(t.parser, t.parser.startParse(this.input, enterFragments(t.mounts, e), e), t.ranges.map((e => new Range(e.from - t.start, e.to - t.start))), t.bracketed, t.target, e[0].from))), t = t.prev
                    }
                    n && !--n.depth && (n = n.prev)
                }
        }
    }
}

function checkCover(e, t, n) {
    for (let o of e) {
        if (o.from >= n) break;
        if (o.to > t) return o.from <= t && o.to >= n ? 2 : 1
    }
    return 0
}

function sliceBuf(e, t, n, o, h, p) {
    if (t < n) {
        let f = e.buffer[t + 1];
        o.push(e.slice(t, n, f)), h.push(f - p)
    }
}

function materialize(e) {
    let {
        node: t
    } = e, n = [], o = t.context.buffer;
    do {
        n.push(e.index), e.parent()
    } while (!e.tree);
    let h = e.tree,
        p = h.children.indexOf(o),
        f = h.children[p],
        g = f.buffer,
        y = [p];
    h.children[p] = function split(e, o, h, p, w, b) {
        let S = n[b],
            k = [],
            v = [];
        sliceBuf(f, e, S, k, v, p);
        let P = g[S + 1],
            C = g[S + 2];
        y.push(k.length);
        let Q = b ? split(S + 4, g[S + 3], f.set.types[g[S]], P, C - P, b - 1) : t.toTree();
        return k.push(Q), v.push(P - p), sliceBuf(f, g[S + 3], o, k, v, p), new Tree(h, k, v, w)
    }(0, g.length, NodeType.none, 0, f.length, n.length - 1);
    for (let t of y) {
        let n = e.tree.children[t],
            o = e.tree.positions[t];
        e.yield(new TreeNode(n, o + e.from, t, e._tree))
    }
}
class StructureCursor {
    constructor(e, t) {
        this.offset = t, this.done = !1, this.cursor = e.cursor(Bn.IncludeAnonymous | Bn.IgnoreMounts)
    }
    moveTo(e) {
        let {
            cursor: t
        } = this, n = e - this.offset;
        for (; !this.done && t.from < n;) t.to >= e && t.enter(n, 1, Bn.IgnoreOverlays | Bn.ExcludeBuffers) || t.next(!1) || (this.done = !0)
    }
    hasNode(e) {
        if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
            for (let t = this.cursor.tree;;) {
                if (t == e.tree) return !0;
                if (!(t.children.length && 0 == t.positions[0] && t.children[0] instanceof Tree)) break;
                t = t.children[0]
            }
        return !1
    }
}
let qn = class {
    constructor(e) {
        var t;
        if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
            let n = this.curFrag = e[0];
            this.curTo = null !== (t = n.tree.prop(Xn)) && void 0 !== t ? t : n.to, this.inner = new StructureCursor(n.tree, -n.offset)
        } else this.curFrag = this.inner = null
    }
    hasNode(e) {
        for (; this.curFrag && e.from >= this.curTo;) this.nextFrag();
        return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e)
    }
    nextFrag() {
        var e;
        if (this.fragI++, this.fragI == this.fragments.length) this.curFrag = this.inner = null;
        else {
            let t = this.curFrag = this.fragments[this.fragI];
            this.curTo = null !== (e = t.tree.prop(Xn)) && void 0 !== e ? e : t.to, this.inner = new StructureCursor(t.tree, -t.offset)
        }
    }
    findMounts(e, t) {
        var n;
        let o = [];
        if (this.inner) {
            this.inner.cursor.moveTo(e, 1);
            for (let e = this.inner.cursor.node; e; e = e.parent) {
                let h = null === (n = e.tree) || void 0 === n ? void 0 : n.prop(NodeProp.mounted);
                if (h && h.parser == t)
                    for (let t = this.fragI; t < this.fragments.length; t++) {
                        let n = this.fragments[t];
                        if (n.from >= e.to) break;
                        n.tree == this.curFrag.tree && o.push({
                            frag: n,
                            pos: e.from - n.offset,
                            mount: h
                        })
                    }
            }
        }
        return o
    }
};

function punchRanges(e, t) {
    let n = null,
        o = t;
    for (let h = 1, p = 0; h < e.length; h++) {
        let f = e[h - 1].to,
            g = e[h].from;
        for (; p < o.length; p++) {
            let e = o[p];
            if (e.from >= g) break;
            e.to <= f || (n || (o = n = t.slice()), e.from < f ? (n[p] = new Range(e.from, f), e.to > g && n.splice(p + 1, 0, new Range(g, e.to))) : e.to > g ? n[p--] = new Range(g, e.to) : n.splice(p--, 1))
        }
    }
    return o
}

function findCoverChanges(e, t, n, o) {
    let h = 0,
        p = 0,
        f = !1,
        g = !1,
        y = -1e9,
        w = [];
    for (;;) {
        let b = h == e.length ? 1e9 : f ? e[h].to : e[h].from,
            S = p == t.length ? 1e9 : g ? t[p].to : t[p].from;
        if (f != g) {
            let e = Math.max(y, n),
                t = Math.min(b, S, o);
            e < t && w.push(new Range(e, t))
        }
        if (y = Math.min(b, S), 1e9 == y) break;
        b == y && (f ? (f = !1, h++) : f = !0), S == y && (g ? (g = !1, p++) : g = !0)
    }
    return w
}

function enterFragments(e, t) {
    let n = [];
    for (let {
            pos: o,
            mount: h,
            frag: p
        } of e) {
        let e = o + (h.overlay ? h.overlay[0].from : 0),
            f = e + h.tree.length,
            g = Math.max(p.from, e),
            y = Math.min(p.to, f);
        if (h.overlay) {
            let f = findCoverChanges(t, h.overlay.map((e => new Range(e.from + o, e.to + o))), g, y);
            for (let t = 0, o = g;; t++) {
                let g = t == f.length,
                    w = g ? y : f[t].from;
                if (w > o && n.push(new TreeFragment(o, w, h.tree, -e, p.from >= o || p.openStart, p.to <= w || p.openEnd)), g) break;
                o = f[t].to
            }
        } else n.push(new TreeFragment(g, y, h.tree, -e, p.from >= e || p.openStart, p.to <= f || p.openEnd))
    }
    return n
}
let zn = 0;
class Tag {
    constructor(e, t, n, o) {
        this.name = e, this.set = t, this.base = n, this.modified = o, this.id = zn++
    }
    toString() {
        let {
            name: e
        } = this;
        for (let t of this.modified) t.name && (e = `${t.name}(${e})`);
        return e
    }
    static define(e, t) {
        let n = "string" == typeof e ? e : "?";
        if (e instanceof Tag && (t = e), null == t ? void 0 : t.base) throw new Error("Can not derive from a modified tag");
        let o = new Tag(n, [], null, []);
        if (o.set.push(o), t)
            for (let e of t.set) o.set.push(e);
        return o
    }
    static defineModifier(e) {
        let t = new Modifier(e);
        return e => e.modified.indexOf(t) > -1 ? e : Modifier.get(e.base || e, e.modified.concat(t).sort(((e, t) => e.id - t.id)))
    }
}
let Nn = 0;
class Modifier {
    constructor(e) {
        this.name = e, this.instances = [], this.id = Nn++
    }
    static get(e, t) {
        if (!t.length) return e;
        let n = t[0].instances.find((n => {
            return n.base == e && (o = t, h = n.modified, o.length == h.length && o.every(((e, t) => e == h[t])));
            var o, h
        }));
        if (n) return n;
        let o = [],
            h = new Tag(e.name, o, e, t);
        for (let e of t) e.instances.push(h);
        let p = function(e) {
            let t = [
                []
            ];
            for (let n = 0; n < e.length; n++)
                for (let o = 0, h = t.length; o < h; o++) t.push(t[o].concat(e[n]));
            return t.sort(((e, t) => t.length - e.length))
        }(t);
        for (let t of e.set)
            if (!t.modified.length)
                for (let e of p) o.push(Modifier.get(t, e));
        return h
    }
}

function styleTags(e) {
    let t = Object.create(null);
    for (let n in e) {
        let o = e[n];
        Array.isArray(o) || (o = [o]);
        for (let e of n.split(" "))
            if (e) {
                let n = [],
                    h = 2,
                    p = e;
                for (let t = 0;;) {
                    if ("..." == p && t > 0 && t + 3 == e.length) {
                        h = 1;
                        break
                    }
                    let o = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(p);
                    if (!o) throw new RangeError("Invalid path: " + e);
                    if (n.push("*" == o[0] ? "" : '"' == o[0][0] ? JSON.parse(o[0]) : o[0]), t += o[0].length, t == e.length) break;
                    let f = e[t++];
                    if (t == e.length && "!" == f) {
                        h = 0;
                        break
                    }
                    if ("/" != f) throw new RangeError("Invalid path: " + e);
                    p = e.slice(t)
                }
                let f = n.length - 1,
                    g = n[f];
                if (!g) throw new RangeError("Invalid path: " + e);
                let y = new Rule(o, h, f > 0 ? n.slice(0, f) : null);
                t[g] = y.sort(t[g])
            }
    }
    return Yn.add(t)
}
const Yn = new NodeProp;
class Rule {
    constructor(e, t, n, o) {
        this.tags = e, this.mode = t, this.context = n, this.next = o
    }
    get opaque() {
        return 0 == this.mode
    }
    get inherit() {
        return 1 == this.mode
    }
    sort(e) {
        return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e)
    }
    get depth() {
        return this.context ? this.context.length : 0
    }
}

function tagHighlighter(e, t) {
    let n = Object.create(null);
    for (let t of e)
        if (Array.isArray(t.tag))
            for (let e of t.tag) n[e.id] = t.class;
        else n[t.tag.id] = t.class;
    let {
        scope: o,
        all: h = null
    } = t || {};
    return {
        style: e => {
            let t = h;
            for (let o of e)
                for (let e of o.set) {
                    let o = n[e.id];
                    if (o) {
                        t = t ? t + " " + o : o;
                        break
                    }
                }
            return t
        },
        scope: o
    }
}

function highlightTree(e, t, n, o = 0, h = e.length) {
    let p = new HighlightBuilder(o, Array.isArray(t) ? t : [t], n);
    p.highlightRange(e.cursor(), o, h, "", p.highlighters), p.flush(h)
}
Rule.empty = new Rule([], 2, null);
class HighlightBuilder {
    constructor(e, t, n) {
        this.at = e, this.highlighters = t, this.span = n, this.class = ""
    }
    startSpan(e, t) {
        t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t)
    }
    flush(e) {
        e > this.at && this.class && this.span(this.at, e, this.class)
    }
    highlightRange(e, t, n, o, h) {
        let {
            type: p,
            from: f,
            to: g
        } = e;
        if (f >= n || g <= t) return;
        p.isTop && (h = this.highlighters.filter((e => !e.scope || e.scope(p))));
        let y = o,
            w = function(e) {
                let t = e.type.prop(Yn);
                for (; t && t.context && !e.matchContext(t.context);) t = t.next;
                return t || null
            }(e) || Rule.empty,
            b = function(e, t) {
                let n = null;
                for (let o of e) {
                    let e = o.style(t);
                    e && (n = n ? n + " " + e : e)
                }
                return n
            }(h, w.tags);
        if (b && (y && (y += " "), y += b, 1 == w.mode && (o += (o ? " " : "") + b)), this.startSpan(Math.max(t, f), y), w.opaque) return;
        let S = e.tree && e.tree.prop(NodeProp.mounted);
        if (S && S.overlay) {
            let p = e.node.enter(S.overlay[0].from + f, 1),
                w = this.highlighters.filter((e => !e.scope || e.scope(S.tree.type))),
                b = e.firstChild();
            for (let k = 0, v = f;; k++) {
                let P = k < S.overlay.length ? S.overlay[k] : null,
                    C = P ? P.from + f : g,
                    Q = Math.max(t, v),
                    $ = Math.min(n, C);
                if (Q < $ && b)
                    for (; e.from < $ && (this.highlightRange(e, Q, $, o, h), this.startSpan(Math.min($, e.to), y), !(e.to >= C) && e.nextSibling()););
                if (!P || C > n) break;
                v = P.to + f, v > t && (this.highlightRange(p.cursor(), Math.max(t, P.from + f), Math.min(n, v), "", w), this.startSpan(Math.min(n, v), y))
            }
            b && e.parent()
        } else if (e.firstChild()) {
            S && (o = "");
            do {
                if (!(e.to <= t)) {
                    if (e.from >= n) break;
                    this.highlightRange(e, t, n, o, h), this.startSpan(Math.min(n, e.to), y)
                }
            } while (e.nextSibling());
            e.parent()
        }
    }
}
const jn = Tag.define,
    Wn = jn(),
    Un = jn(),
    Fn = jn(Un),
    Gn = jn(Un),
    Hn = jn(),
    Kn = jn(Hn),
    Jn = jn(Hn),
    ei = jn(),
    ti = jn(ei),
    ni = jn(),
    ii = jn(),
    ri = jn(),
    oi = jn(ri),
    si = jn(),
    ai = {
        comment: Wn,
        lineComment: jn(Wn),
        blockComment: jn(Wn),
        docComment: jn(Wn),
        name: Un,
        variableName: jn(Un),
        typeName: Fn,
        tagName: jn(Fn),
        propertyName: Gn,
        attributeName: jn(Gn),
        className: jn(Un),
        labelName: jn(Un),
        namespace: jn(Un),
        macroName: jn(Un),
        literal: Hn,
        string: Kn,
        docString: jn(Kn),
        character: jn(Kn),
        attributeValue: jn(Kn),
        number: Jn,
        integer: jn(Jn),
        float: jn(Jn),
        bool: jn(Hn),
        regexp: jn(Hn),
        escape: jn(Hn),
        color: jn(Hn),
        url: jn(Hn),
        keyword: ni,
        self: jn(ni),
        null: jn(ni),
        atom: jn(ni),
        unit: jn(ni),
        modifier: jn(ni),
        operatorKeyword: jn(ni),
        controlKeyword: jn(ni),
        definitionKeyword: jn(ni),
        moduleKeyword: jn(ni),
        operator: ii,
        derefOperator: jn(ii),
        arithmeticOperator: jn(ii),
        logicOperator: jn(ii),
        bitwiseOperator: jn(ii),
        compareOperator: jn(ii),
        updateOperator: jn(ii),
        definitionOperator: jn(ii),
        typeOperator: jn(ii),
        controlOperator: jn(ii),
        punctuation: ri,
        separator: jn(ri),
        bracket: oi,
        angleBracket: jn(oi),
        squareBracket: jn(oi),
        paren: jn(oi),
        brace: jn(oi),
        content: ei,
        heading: ti,
        heading1: jn(ti),
        heading2: jn(ti),
        heading3: jn(ti),
        heading4: jn(ti),
        heading5: jn(ti),
        heading6: jn(ti),
        contentSeparator: jn(ei),
        list: jn(ei),
        quote: jn(ei),
        emphasis: jn(ei),
        strong: jn(ei),
        link: jn(ei),
        monospace: jn(ei),
        strikethrough: jn(ei),
        inserted: jn(),
        deleted: jn(),
        changed: jn(),
        invalid: jn(),
        meta: si,
        documentMeta: jn(si),
        annotation: jn(si),
        processingInstruction: jn(si),
        definition: Tag.defineModifier("definition"),
        constant: Tag.defineModifier("constant"),
        function: Tag.defineModifier("function"),
        standard: Tag.defineModifier("standard"),
        local: Tag.defineModifier("local"),
        special: Tag.defineModifier("special")
    };
for (let oh in ai) {
    let sh = ai[oh];
    sh instanceof Tag && (sh.name = oh)
}
var li;
tagHighlighter([{
    tag: ai.link,
    class: "tok-link"
}, {
    tag: ai.heading,
    class: "tok-heading"
}, {
    tag: ai.emphasis,
    class: "tok-emphasis"
}, {
    tag: ai.strong,
    class: "tok-strong"
}, {
    tag: ai.keyword,
    class: "tok-keyword"
}, {
    tag: ai.atom,
    class: "tok-atom"
}, {
    tag: ai.bool,
    class: "tok-bool"
}, {
    tag: ai.url,
    class: "tok-url"
}, {
    tag: ai.labelName,
    class: "tok-labelName"
}, {
    tag: ai.inserted,
    class: "tok-inserted"
}, {
    tag: ai.deleted,
    class: "tok-deleted"
}, {
    tag: ai.literal,
    class: "tok-literal"
}, {
    tag: ai.string,
    class: "tok-string"
}, {
    tag: ai.number,
    class: "tok-number"
}, {
    tag: [ai.regexp, ai.escape, ai.special(ai.string)],
    class: "tok-string2"
}, {
    tag: ai.variableName,
    class: "tok-variableName"
}, {
    tag: ai.local(ai.variableName),
    class: "tok-variableName tok-local"
}, {
    tag: ai.definition(ai.variableName),
    class: "tok-variableName tok-definition"
}, {
    tag: ai.special(ai.variableName),
    class: "tok-variableName2"
}, {
    tag: ai.definition(ai.propertyName),
    class: "tok-propertyName tok-definition"
}, {
    tag: ai.typeName,
    class: "tok-typeName"
}, {
    tag: ai.namespace,
    class: "tok-namespace"
}, {
    tag: ai.className,
    class: "tok-className"
}, {
    tag: ai.macroName,
    class: "tok-macroName"
}, {
    tag: ai.propertyName,
    class: "tok-propertyName"
}, {
    tag: ai.operator,
    class: "tok-operator"
}, {
    tag: ai.comment,
    class: "tok-comment"
}, {
    tag: ai.meta,
    class: "tok-meta"
}, {
    tag: ai.invalid,
    class: "tok-invalid"
}, {
    tag: ai.punctuation,
    class: "tok-punctuation"
}]);
const ci = new NodeProp;

function defineLanguageFacet(e) {
    return Facet.define({
        combine: e ? t => t.concat(e) : void 0
    })
}
const hi = new NodeProp;
class Language {
    constructor(e, t, n = [], o = "") {
        this.data = e, this.name = o, EditorState.prototype.hasOwnProperty("tree") || Object.defineProperty(EditorState.prototype, "tree", {
            get() {
                return syntaxTree(this)
            }
        }), this.parser = t, this.extension = [fi.of(this), EditorState.languageData.of(((e, t, n) => {
            let o = topNodeAt(e, t, n),
                h = o.type.prop(ci);
            if (!h) return [];
            let p = e.facet(h),
                f = o.type.prop(hi);
            if (f) {
                let h = o.resolve(t - o.from, n);
                for (let t of f)
                    if (t.test(h, e)) {
                        let n = e.facet(t.facet);
                        return "replace" == t.type ? n : n.concat(p)
                    }
            }
            return p
        }))].concat(n)
    }
    isActiveAt(e, t, n = -1) {
        return topNodeAt(e, t, n).type.prop(ci) == this.data
    }
    findRegions(e) {
        let t = e.facet(fi);
        if ((null == t ? void 0 : t.data) == this.data) return [{
            from: 0,
            to: e.doc.length
        }];
        if (!t || !t.allowsNesting) return [];
        let n = [],
            explore = (e, t) => {
                if (e.prop(ci) == this.data) return void n.push({
                    from: t,
                    to: t + e.length
                });
                let o = e.prop(NodeProp.mounted);
                if (o) {
                    if (o.tree.prop(ci) == this.data) {
                        if (o.overlay)
                            for (let e of o.overlay) n.push({
                                from: e.from + t,
                                to: e.to + t
                            });
                        else n.push({
                            from: t,
                            to: t + e.length
                        });
                        return
                    }
                    if (o.overlay) {
                        let e = n.length;
                        if (explore(o.tree, o.overlay[0].from + t), n.length > e) return
                    }
                }
                for (let n = 0; n < e.children.length; n++) {
                    let o = e.children[n];
                    o instanceof Tree && explore(o, e.positions[n] + t)
                }
            };
        return explore(syntaxTree(e), 0), n
    }
    get allowsNesting() {
        return !0
    }
}

function topNodeAt(e, t, n) {
    let o = e.facet(fi),
        h = syntaxTree(e).topNode;
    if (!o || o.allowsNesting)
        for (let e = h; e; e = e.enter(t, n, Bn.ExcludeBuffers)) e.type.isTop && (h = e);
    return h
}
Language.setState = StateEffect.define();
class LRLanguage extends Language {
    constructor(e, t, n) {
        super(e, t, [], n), this.parser = t
    }
    static define(e) {
        let t = defineLanguageFacet(e.languageData);
        return new LRLanguage(t, e.parser.configure({
            props: [ci.add((e => e.isTop ? t : void 0))]
        }), e.name)
    }
    configure(e, t) {
        return new LRLanguage(this.data, this.parser.configure(e), t || this.name)
    }
    get allowsNesting() {
        return this.parser.hasWrappers()
    }
}

function syntaxTree(e) {
    let t = e.field(Language.state, !1);
    return t ? t.tree : Tree.empty
}
class DocInput {
    constructor(e) {
        this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter()
    }
    get length() {
        return this.doc.length
    }
    syncTo(e) {
        return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length
    }
    chunk(e) {
        return this.syncTo(e), this.string
    }
    get lineChunks() {
        return !0
    }
    read(e, t) {
        let n = this.cursorPos - this.string.length;
        return e < n || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - n, t - n)
    }
}
let di = null;
class ParseContext {
    constructor(e, t, n = [], o, h, p, f, g) {
        this.parser = e, this.state = t, this.fragments = n, this.tree = o, this.treeLen = h, this.viewport = p, this.skipped = f, this.scheduleOn = g, this.parse = null, this.tempSkipped = []
    }
    static create(e, t, n) {
        return new ParseContext(e, t, [], Tree.empty, 0, n, [], null)
    }
    startParse() {
        return this.parser.startParse(new DocInput(this.state.doc), this.fragments)
    }
    work(e, t) {
        return null != t && t >= this.state.doc.length && (t = void 0), this.tree != Tree.empty && this.isDone(null != t ? t : this.state.doc.length) ? (this.takeTree(), !0) : this.withContext((() => {
            var n;
            if ("number" == typeof e) {
                let t = Date.now() + e;
                e = () => Date.now() > t
            }
            for (this.parse || (this.parse = this.startParse()), null != t && (null == this.parse.stoppedAt || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t);;) {
                let o = this.parse.advance();
                if (o) {
                    if (this.fragments = this.withoutTempSkipped(TreeFragment.addTree(o, this.fragments, null != this.parse.stoppedAt)), this.treeLen = null !== (n = this.parse.stoppedAt) && void 0 !== n ? n : this.state.doc.length, this.tree = o, this.parse = null, !(this.treeLen < (null != t ? t : this.state.doc.length))) return !0;
                    this.parse = this.startParse()
                }
                if (e()) return !1
            }
        }))
    }
    takeTree() {
        let e, t;
        this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((null == this.parse.stoppedAt || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext((() => {
            for (; !(t = this.parse.advance()););
        })), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, !0)), this.parse = null)
    }
    withContext(e) {
        let t = di;
        di = this;
        try {
            return e()
        } finally {
            di = t
        }
    }
    withoutTempSkipped(e) {
        for (let t; t = this.tempSkipped.pop();) e = cutFragments(e, t.from, t.to);
        return e
    }
    changes(e, t) {
        let {
            fragments: n,
            tree: o,
            treeLen: h,
            viewport: p,
            skipped: f
        } = this;
        if (this.takeTree(), !e.empty) {
            let t = [];
            if (e.iterChangedRanges(((e, n, o, h) => t.push({
                    fromA: e,
                    toA: n,
                    fromB: o,
                    toB: h
                }))), n = TreeFragment.applyChanges(n, t), o = Tree.empty, h = 0, p = {
                    from: e.mapPos(p.from, -1),
                    to: e.mapPos(p.to, 1)
                }, this.skipped.length) {
                f = [];
                for (let t of this.skipped) {
                    let n = e.mapPos(t.from, 1),
                        o = e.mapPos(t.to, -1);
                    n < o && f.push({
                        from: n,
                        to: o
                    })
                }
            }
        }
        return new ParseContext(this.parser, t, n, o, h, p, f, this.scheduleOn)
    }
    updateViewport(e) {
        if (this.viewport.from == e.from && this.viewport.to == e.to) return !1;
        this.viewport = e;
        let t = this.skipped.length;
        for (let t = 0; t < this.skipped.length; t++) {
            let {
                from: n,
                to: o
            } = this.skipped[t];
            n < e.to && o > e.from && (this.fragments = cutFragments(this.fragments, n, o), this.skipped.splice(t--, 1))
        }
        return !(this.skipped.length >= t) && (this.reset(), !0)
    }
    reset() {
        this.parse && (this.takeTree(), this.parse = null)
    }
    skipUntilInView(e, t) {
        this.skipped.push({
            from: e,
            to: t
        })
    }
    static getSkippingParser(e) {
        return new class extends Parser {
            createParse(t, n, o) {
                let h = o[0].from,
                    p = o[o.length - 1].to;
                return {
                    parsedPos: h,
                    advance() {
                        let t = di;
                        if (t) {
                            for (let e of o) t.tempSkipped.push(e);
                            e && (t.scheduleOn = t.scheduleOn ? Promise.all([t.scheduleOn, e]) : e)
                        }
                        return this.parsedPos = p, new Tree(NodeType.none, [], [], p - h)
                    },
                    stoppedAt: null,
                    stopAt() {}
                }
            }
        }
    }
    isDone(e) {
        e = Math.min(e, this.state.doc.length);
        let t = this.fragments;
        return this.treeLen >= e && t.length && 0 == t[0].from && t[0].to >= e
    }
    static get() {
        return di
    }
}

function cutFragments(e, t, n) {
    return TreeFragment.applyChanges(e, [{
        fromA: t,
        toA: n,
        fromB: t,
        toB: n
    }])
}
class LanguageState {
    constructor(e) {
        this.context = e, this.tree = e.tree
    }
    apply(e) {
        if (!e.docChanged && this.tree == this.context.tree) return this;
        let t = this.context.changes(e.changes, e.state),
            n = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
        return t.work(20, n) || t.takeTree(), new LanguageState(t)
    }
    static init(e) {
        let t = Math.min(3e3, e.doc.length),
            n = ParseContext.create(e.facet(fi).parser, e, {
                from: 0,
                to: t
            });
        return n.work(20, t) || n.takeTree(), new LanguageState(n)
    }
}
Language.state = StateField.define({
    create: LanguageState.init,
    update(e, t) {
        for (let e of t.effects)
            if (e.is(Language.setState)) return e.value;
        return t.startState.facet(fi) != t.state.facet(fi) ? LanguageState.init(t.state) : e.apply(t)
    }
});
let requestIdle = e => {
    let t = setTimeout((() => e()), 500);
    return () => clearTimeout(t)
};
"undefined" != typeof requestIdleCallback && (requestIdle = e => {
    let t = -1,
        n = setTimeout((() => {
            t = requestIdleCallback(e, {
                timeout: 400
            })
        }), 100);
    return () => t < 0 ? clearTimeout(n) : cancelIdleCallback(t)
});
const ui = "undefined" != typeof navigator && (null === (li = navigator.scheduling) || void 0 === li ? void 0 : li.isInputPending) ? () => navigator.scheduling.isInputPending() : null,
    pi = ViewPlugin.fromClass(class {
        constructor(e) {
            this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork()
        }
        update(e) {
            let t = this.view.state.field(Language.state).context;
            (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t)
        }
        scheduleWork() {
            if (this.working) return;
            let {
                state: e
            } = this.view, t = e.field(Language.state);
            t.tree == t.context.tree && t.context.isDone(e.doc.length) || (this.working = requestIdle(this.work))
        }
        work(e) {
            this.working = null;
            let t = Date.now();
            if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0) return;
            let {
                state: n,
                viewport: {
                    to: o
                }
            } = this.view, h = n.field(Language.state);
            if (h.tree == h.context.tree && h.context.isDone(o + 1e5)) return;
            let p = Date.now() + Math.min(this.chunkBudget, 100, e && !ui ? Math.max(25, e.timeRemaining() - 5) : 1e9),
                f = h.context.treeLen < o && n.doc.length > o + 1e3,
                g = h.context.work((() => ui && ui() || Date.now() > p), o + (f ? 0 : 1e5));
            this.chunkBudget -= Date.now() - t, (g || this.chunkBudget <= 0) && (h.context.takeTree(), this.view.dispatch({
                effects: Language.setState.of(new LanguageState(h.context))
            })), this.chunkBudget > 0 && (!g || f) && this.scheduleWork(), this.checkAsyncSchedule(h.context)
        }
        checkAsyncSchedule(e) {
            e.scheduleOn && (this.workScheduled++, e.scheduleOn.then((() => this.scheduleWork())).catch((e => logException(this.view.state, e))).then((() => this.workScheduled--)), e.scheduleOn = null)
        }
        destroy() {
            this.working && this.working()
        }
        isWorking() {
            return !!(this.working || this.workScheduled > 0)
        }
    }, {
        eventHandlers: {
            focus() {
                this.scheduleWork()
            }
        }
    }),
    fi = Facet.define({
        combine: e => e.length ? e[0] : null,
        enables: e => [Language.state, pi, EditorView.contentAttributes.compute([e], (t => {
            let n = t.facet(e);
            return n && n.name ? {
                "data-language": n.name
            } : {}
        }))]
    });
class LanguageSupport {
    constructor(e, t = []) {
        this.language = e, this.support = t, this.extension = [e, t]
    }
}
class LanguageDescription {
    constructor(e, t, n, o, h, p = void 0) {
        this.name = e, this.alias = t, this.extensions = n, this.filename = o, this.loadFunc = h, this.support = p, this.loading = null
    }
    load() {
        return this.loading || (this.loading = this.loadFunc().then((e => this.support = e), (e => {
            throw this.loading = null, e
        })))
    }
    static of (e) {
        let {
            load: t,
            support: n
        } = e;
        if (!t) {
            if (!n) throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
            t = () => Promise.resolve(n)
        }
        return new LanguageDescription(e.name, (e.alias || []).concat(e.name).map((e => e.toLowerCase())), e.extensions || [], e.filename, t, n)
    }
    static matchFilename(e, t) {
        for (let n of e)
            if (n.filename && n.filename.test(t)) return n;
        let n = /\.([^.]+)$/.exec(t);
        if (n)
            for (let t of e)
                if (t.extensions.indexOf(n[1]) > -1) return t;
        return null
    }
    static matchLanguageName(e, t, n = !0) {
        t = t.toLowerCase();
        for (let n of e)
            if (n.alias.some((e => e == t))) return n;
        if (n)
            for (let n of e)
                for (let e of n.alias) {
                    let o = t.indexOf(e);
                    if (o > -1 && (e.length > 2 || !/\w/.test(t[o - 1]) && !/\w/.test(t[o + e.length]))) return n
                }
        return null
    }
}
const gi = Facet.define(),
    mi = Facet.define({
        combine: e => {
            if (!e.length) return "  ";
            let t = e[0];
            if (!t || /\S/.test(t) || Array.from(t).some((e => e != t[0]))) throw new Error("Invalid indent unit: " + JSON.stringify(e[0]));
            return t
        }
    });

function getIndentUnit(e) {
    let t = e.facet(mi);
    return 9 == t.charCodeAt(0) ? e.tabSize * t.length : t.length
}

function indentString(e, t) {
    let n = "",
        o = e.tabSize,
        h = e.facet(mi)[0];
    if ("\t" == h) {
        for (; t >= o;) n += "\t", t -= o;
        h = " "
    }
    for (let e = 0; e < t; e++) n += h;
    return n
}

function getIndentation(e, t) {
    e instanceof EditorState && (e = new IndentContext(e));
    for (let n of e.state.facet(gi)) {
        let o = n(e, t);
        if (void 0 !== o) return o
    }
    let n = syntaxTree(e.state);
    return n.length >= t ? function(e, t, n) {
        let o = t.resolveStack(n),
            h = t.resolveInner(n, -1).resolve(n, 0).enterUnfinishedNodesBefore(n);
        if (h != o.node) {
            let e = [];
            for (let t = h; t && (t.from != o.node.from || t.type != o.node.type); t = t.parent) e.push(t);
            for (let t = e.length - 1; t >= 0; t--) o = {
                node: e[t],
                next: o
            }
        }
        return indentFor(o, e, n)
    }(e, n, t) : null
}
class IndentContext {
    constructor(e, t = {}) {
        this.state = e, this.options = t, this.unit = getIndentUnit(e)
    }
    lineAt(e, t = 1) {
        let n = this.state.doc.lineAt(e),
            {
                simulateBreak: o,
                simulateDoubleBreak: h
            } = this.options;
        return null != o && o >= n.from && o <= n.to ? h && o == e ? {
            text: "",
            from: e
        } : (t < 0 ? o < e : o <= e) ? {
            text: n.text.slice(o - n.from),
            from: o
        } : {
            text: n.text.slice(0, o - n.from),
            from: n.from
        } : n
    }
    textAfterPos(e, t = 1) {
        if (this.options.simulateDoubleBreak && e == this.options.simulateBreak) return "";
        let {
            text: n,
            from: o
        } = this.lineAt(e, t);
        return n.slice(e - o, Math.min(n.length, e + 100 - o))
    }
    column(e, t = 1) {
        let {
            text: n,
            from: o
        } = this.lineAt(e, t), h = this.countColumn(n, e - o), p = this.options.overrideIndentation ? this.options.overrideIndentation(o) : -1;
        return p > -1 && (h += p - this.countColumn(n, n.search(/\S|$/))), h
    }
    countColumn(e, t = e.length) {
        return countColumn(e, this.state.tabSize, t)
    }
    lineIndent(e, t = 1) {
        let {
            text: n,
            from: o
        } = this.lineAt(e, t), h = this.options.overrideIndentation;
        if (h) {
            let e = h(o);
            if (e > -1) return e
        }
        return this.countColumn(n, n.search(/\S|$/))
    }
    get simulatedBreak() {
        return this.options.simulateBreak || null
    }
}
const Oi = new NodeProp;

function indentFor(e, t, n) {
    for (let o = e; o; o = o.next) {
        let e = indentStrategy(o.node);
        if (e) return e(TreeIndentContext.create(t, n, o))
    }
    return 0
}

function indentStrategy(e) {
    let t = e.type.prop(Oi);
    if (t) return t;
    let n, o = e.firstChild;
    if (o && (n = o.type.prop(NodeProp.closedBy))) {
        let t = e.lastChild,
            o = t && n.indexOf(t.name) > -1;
        return e => delimitedStrategy(e, !0, 1, void 0, o && ! function(e) {
            return e.pos == e.options.simulateBreak && e.options.simulateDoubleBreak
        }(e) ? t.from : void 0)
    }
    return null == e.parent ? topIndent : null
}

function topIndent() {
    return 0
}
class TreeIndentContext extends IndentContext {
    constructor(e, t, n) {
        super(e.state, e.options), this.base = e, this.pos = t, this.context = n
    }
    get node() {
        return this.context.node
    }
    static create(e, t, n) {
        return new TreeIndentContext(e, t, n)
    }
    get textAfter() {
        return this.textAfterPos(this.pos)
    }
    get baseIndent() {
        return this.baseIndentFor(this.node)
    }
    baseIndentFor(e) {
        let t = this.state.doc.lineAt(e.from);
        for (;;) {
            let n = e.resolve(t.from);
            for (; n.parent && n.parent.from == n.from;) n = n.parent;
            if (isParent(n, e)) break;
            t = this.state.doc.lineAt(n.from)
        }
        return this.lineIndent(t.from)
    }
    continue () {
        return indentFor(this.context.next, this.base, this.pos)
    }
}

function isParent(e, t) {
    for (let n = t; n; n = n.parent)
        if (e == n) return !0;
    return !1
}

function delimitedIndent({
    closing: e,
    align: t = !0,
    units: n = 1
}) {
    return o => delimitedStrategy(o, t, n, e)
}

function delimitedStrategy(e, t, n, o, h) {
    let p = e.textAfter,
        f = p.match(/^\s*/)[0].length,
        g = o && p.slice(f, f + o.length) == o || h == e.pos + f,
        y = t ? function(e) {
            let t = e.node,
                n = t.childAfter(t.from),
                o = t.lastChild;
            if (!n) return null;
            let h = e.options.simulateBreak,
                p = e.state.doc.lineAt(n.from),
                f = null == h || h <= p.from ? p.to : Math.min(p.to, h);
            for (let e = n.to;;) {
                let h = t.childAfter(e);
                if (!h || h == o) return null;
                if (!h.type.isSkipped) {
                    if (h.from >= f) return null;
                    let e = /^ */.exec(p.text.slice(n.to - p.from))[0].length;
                    return {
                        from: n.from,
                        to: n.to + e
                    }
                }
                e = h.to
            }
        }(e) : null;
    return y ? g ? e.column(y.from) : e.column(y.to) : e.baseIndent + (g ? 0 : e.unit * n)
}

function continuedIndent({
    except: e,
    units: t = 1
} = {}) {
    return n => {
        let o = e && e.test(n.textAfter);
        return n.baseIndent + (o ? 0 : t * n.unit)
    }
}
const yi = Facet.define(),
    wi = new NodeProp;

function foldInside(e) {
    let t = e.firstChild,
        n = e.lastChild;
    return t && t.to < n.from ? {
        from: t.to,
        to: n.type.isError ? e.to : n.from
    } : null
}

function isUnfinished(e) {
    let t = e.lastChild;
    return t && t.to == e.to && t.type.isError
}

function foldable(e, t, n) {
    for (let o of e.facet(yi)) {
        let h = o(e, t, n);
        if (h) return h
    }
    return function(e, t, n) {
        let o = syntaxTree(e);
        if (o.length < n) return null;
        let h = null;
        for (let p = o.resolveStack(n, 1); p; p = p.next) {
            let f = p.node;
            if (f.to <= n || f.from > n) continue;
            if (h && f.from < t) break;
            let g = f.type.prop(wi);
            if (g && (f.to < o.length - 50 || o.length == e.doc.length || !isUnfinished(f))) {
                let o = g(f, e);
                o && o.from <= n && o.from >= t && o.to > n && (h = o)
            }
        }
        return h
    }(e, t, n)
}

function mapRange(e, t) {
    let n = t.mapPos(e.from, 1),
        o = t.mapPos(e.to, -1);
    return n >= o ? void 0 : {
        from: n,
        to: o
    }
}
const bi = StateEffect.define({
        map: mapRange
    }),
    Si = StateEffect.define({
        map: mapRange
    });

function selectedLines(e) {
    let t = [];
    for (let {
            head: n
        } of e.state.selection.ranges) t.some((e => e.from <= n && e.to >= n)) || t.push(e.lineBlockAt(n));
    return t
}
const xi = StateField.define({
    create: () => Decoration.none,
    update(e, t) {
        e = e.map(t.changes);
        for (let n of t.effects)
            if (n.is(bi) && !foldExists(e, n.value.from, n.value.to)) {
                let {
                    preparePlaceholder: o
                } = t.state.facet(Pi), h = o ? Decoration.replace({
                    widget: new PreparedFoldWidget(o(t.state, n.value))
                }) : Ci;
                e = e.update({
                    add: [h.range(n.value.from, n.value.to)]
                })
            } else n.is(Si) && (e = e.update({
                filter: (e, t) => n.value.from != e || n.value.to != t,
                filterFrom: n.value.from,
                filterTo: n.value.to
            }));
        if (t.selection) {
            let n = !1,
                {
                    head: o
                } = t.selection.main;
            e.between(o, o, ((e, t) => {
                e < o && t > o && (n = !0)
            })), n && (e = e.update({
                filterFrom: o,
                filterTo: o,
                filter: (e, t) => t <= o || e >= o
            }))
        }
        return e
    },
    provide: e => EditorView.decorations.from(e),
    toJSON(e, t) {
        let n = [];
        return e.between(0, t.doc.length, ((e, t) => {
            n.push(e, t)
        })), n
    },
    fromJSON(e) {
        if (!Array.isArray(e) || e.length % 2) throw new RangeError("Invalid JSON for fold state");
        let t = [];
        for (let n = 0; n < e.length;) {
            let o = e[n++],
                h = e[n++];
            if ("number" != typeof o || "number" != typeof h) throw new RangeError("Invalid JSON for fold state");
            t.push(Ci.range(o, h))
        }
        return Decoration.set(t, !0)
    }
});

function findFold(e, t, n) {
    var o;
    let h = null;
    return null === (o = e.field(xi, !1)) || void 0 === o || o.between(t, n, ((e, t) => {
        (!h || h.from > e) && (h = {
            from: e,
            to: t
        })
    })), h
}

function foldExists(e, t, n) {
    let o = !1;
    return e.between(t, t, ((e, h) => {
        e == t && h == n && (o = !0)
    })), o
}

function maybeEnable(e, t) {
    return e.field(xi, !1) ? t : t.concat(StateEffect.appendConfig.of(codeFolding()))
}

function announceFold(e, t, n = !0) {
    let o = e.state.doc.lineAt(t.from).number,
        h = e.state.doc.lineAt(t.to).number;
    return EditorView.announce.of(`${e.state.phrase(n?"Folded lines":"Unfolded lines")} ${o} ${e.state.phrase("to")} ${h}.`)
}
const foldAll = e => {
        let {
            state: t
        } = e, n = [];
        for (let o = 0; o < t.doc.length;) {
            let h = e.lineBlockAt(o),
                p = foldable(t, h.from, h.to);
            p && n.push(bi.of(p)), o = (p ? e.lineBlockAt(p.to) : h).to + 1
        }
        return n.length && e.dispatch({
            effects: maybeEnable(e.state, n)
        }), !!n.length
    },
    unfoldAll = e => {
        let t = e.state.field(xi, !1);
        if (!t || !t.size) return !1;
        let n = [];
        return t.between(0, e.state.doc.length, ((e, t) => {
            n.push(Si.of({
                from: e,
                to: t
            }))
        })), e.dispatch({
            effects: n
        }), !0
    },
    ki = [{
        key: "Ctrl-Shift-[",
        mac: "Cmd-Alt-[",
        run: e => {
            for (let t of selectedLines(e)) {
                let n = foldable(e.state, t.from, t.to);
                if (n) return e.dispatch({
                    effects: maybeEnable(e.state, [bi.of(n), announceFold(e, n)])
                }), !0
            }
            return !1
        }
    }, {
        key: "Ctrl-Shift-]",
        mac: "Cmd-Alt-]",
        run: e => {
            if (!e.state.field(xi, !1)) return !1;
            let t = [];
            for (let n of selectedLines(e)) {
                let o = findFold(e.state, n.from, n.to);
                o && t.push(Si.of(o), announceFold(e, o, !1))
            }
            return t.length && e.dispatch({
                effects: t
            }), t.length > 0
        }
    }, {
        key: "Ctrl-Alt-[",
        run: foldAll
    }, {
        key: "Ctrl-Alt-]",
        run: unfoldAll
    }],
    vi = {
        placeholderDOM: null,
        preparePlaceholder: null,
        placeholderText: "â€¦"
    },
    Pi = Facet.define({
        combine: e => combineConfig(e, vi)
    });

function codeFolding(e) {
    let t = [xi, Ti];
    return e && t.push(Pi.of(e)), t
}

function widgetToDOM(e, t) {
    let {
        state: n
    } = e, o = n.facet(Pi), onclick = t => {
        let n = e.lineBlockAt(e.posAtDOM(t.target)),
            o = findFold(e.state, n.from, n.to);
        o && e.dispatch({
            effects: Si.of(o)
        }), t.preventDefault()
    };
    if (o.placeholderDOM) return o.placeholderDOM(e, onclick, t);
    let h = document.createElement("span");
    return h.textContent = o.placeholderText, h.setAttribute("aria-label", n.phrase("folded code")), h.title = n.phrase("unfold"), h.className = "cm-foldPlaceholder", h.onclick = onclick, h
}
const Ci = Decoration.replace({
    widget: new class extends WidgetType {
        toDOM(e) {
            return widgetToDOM(e, null)
        }
    }
});
class PreparedFoldWidget extends WidgetType {
    constructor(e) {
        super(), this.value = e
    }
    eq(e) {
        return this.value == e.value
    }
    toDOM(e) {
        return widgetToDOM(e, this.value)
    }
}
const Qi = {
    openText: "âŒ„",
    closedText: "â€º",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => !1
};
class FoldMarker extends GutterMarker {
    constructor(e, t) {
        super(), this.config = e, this.open = t
    }
    eq(e) {
        return this.config == e.config && this.open == e.open
    }
    toDOM(e) {
        if (this.config.markerDOM) return this.config.markerDOM(this.open);
        let t = document.createElement("span");
        return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t
    }
}

function foldGutter(e = {}) {
    let t = Object.assign(Object.assign({}, Qi), e),
        n = new FoldMarker(t, !0),
        o = new FoldMarker(t, !1),
        h = ViewPlugin.fromClass(class {
            constructor(e) {
                this.from = e.viewport.from, this.markers = this.buildMarkers(e)
            }
            update(e) {
                (e.docChanged || e.viewportChanged || e.startState.facet(fi) != e.state.facet(fi) || e.startState.field(xi, !1) != e.state.field(xi, !1) || syntaxTree(e.startState) != syntaxTree(e.state) || t.foldingChanged(e)) && (this.markers = this.buildMarkers(e.view))
            }
            buildMarkers(e) {
                let t = new RangeSetBuilder;
                for (let h of e.viewportLineBlocks) {
                    let p = findFold(e.state, h.from, h.to) ? o : foldable(e.state, h.from, h.to) ? n : null;
                    p && t.add(h.from, h.from, p)
                }
                return t.finish()
            }
        }),
        {
            domEventHandlers: p
        } = t;
    return [h, gutter({
        class: "cm-foldGutter",
        markers(e) {
            var t;
            return (null === (t = e.plugin(h)) || void 0 === t ? void 0 : t.markers) || RangeSet.empty
        },
        initialSpacer: () => new FoldMarker(t, !1),
        domEventHandlers: Object.assign(Object.assign({}, p), {
            click: (e, t, n) => {
                if (p.click && p.click(e, t, n)) return !0;
                let o = findFold(e.state, t.from, t.to);
                if (o) return e.dispatch({
                    effects: Si.of(o)
                }), !0;
                let h = foldable(e.state, t.from, t.to);
                return !!h && (e.dispatch({
                    effects: bi.of(h)
                }), !0)
            }
        })
    }), codeFolding()]
}
const Ti = EditorView.baseTheme({
    ".cm-foldPlaceholder": {
        backgroundColor: "#eee",
        border: "1px solid #ddd",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
    },
    ".cm-foldGutter span": {
        padding: "0 1px",
        cursor: "pointer"
    }
});
class HighlightStyle {
    constructor(e, t) {
        let n;

        function def(e) {
            let t = StyleModule.newName();
            return (n || (n = Object.create(null)))["." + t] = e, t
        }
        this.specs = e;
        const o = "string" == typeof t.all ? t.all : t.all ? def(t.all) : void 0,
            h = t.scope;
        this.scope = h instanceof Language ? e => e.prop(ci) == h.data : h ? e => e == h : void 0, this.style = tagHighlighter(e.map((e => ({
            tag: e.tag,
            class: e.class || def(Object.assign({}, e, {
                tag: null
            }))
        }))), {
            all: o
        }).style, this.module = n ? new StyleModule(n) : null, this.themeType = t.themeType
    }
    static define(e, t) {
        return new HighlightStyle(e, t || {})
    }
}
const $i = Facet.define(),
    Ei = Facet.define({
        combine: e => e.length ? [e[0]] : null
    });

function getHighlighters(e) {
    let t = e.facet($i);
    return t.length ? t : e.facet(Ei)
}

function syntaxHighlighting(e, t) {
    let n, o = [Ai];
    return e instanceof HighlightStyle && (e.module && o.push(EditorView.styleModule.of(e.module)), n = e.themeType), (null == t ? void 0 : t.fallback) ? o.push(Ei.of(e)) : n ? o.push($i.computeN([EditorView.darkTheme], (t => t.facet(EditorView.darkTheme) == ("dark" == n) ? [e] : []))) : o.push($i.of(e)), o
}
class TreeHighlighter {
    constructor(e) {
        this.markCache = Object.create(null), this.tree = syntaxTree(e.state), this.decorations = this.buildDeco(e, getHighlighters(e.state)), this.decoratedTo = e.viewport.to
    }
    update(e) {
        let t = syntaxTree(e.state),
            n = getHighlighters(e.state),
            o = n != getHighlighters(e.startState),
            {
                viewport: h
            } = e.view,
            p = e.changes.mapPos(this.decoratedTo, 1);
        t.length < h.to && !o && t.type == this.tree.type && p >= h.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = p) : (t != this.tree || e.viewportChanged || o) && (this.tree = t, this.decorations = this.buildDeco(e.view, n), this.decoratedTo = h.to)
    }
    buildDeco(e, t) {
        if (!t || !this.tree.length) return Decoration.none;
        let n = new RangeSetBuilder;
        for (let {
                from: o,
                to: h
            } of e.visibleRanges) highlightTree(this.tree, t, ((e, t, o) => {
            n.add(e, t, this.markCache[o] || (this.markCache[o] = Decoration.mark({
                class: o
            })))
        }), o, h);
        return n.finish()
    }
}
const Ai = b.high(ViewPlugin.fromClass(TreeHighlighter, {
    decorations: e => e.decorations
}));
ai.meta, ai.link, ai.heading, ai.emphasis, ai.strong, ai.strikethrough, ai.keyword, ai.atom, ai.bool, ai.url, ai.contentSeparator, ai.labelName, ai.literal, ai.inserted, ai.string, ai.deleted, ai.regexp, ai.escape, ai.string, ai.variableName, ai.variableName, ai.typeName, ai.namespace, ai.className, ai.variableName, ai.macroName, ai.propertyName, ai.comment, ai.invalid;
const Mi = EditorView.baseTheme({
        "&.cm-focused .cm-matchingBracket": {
            backgroundColor: "#328c8252"
        },
        "&.cm-focused .cm-nonmatchingBracket": {
            backgroundColor: "#bb555544"
        }
    }),
    Ri = "()[]{}",
    Di = Facet.define({
        combine: e => combineConfig(e, {
            afterCursor: !0,
            brackets: Ri,
            maxScanDistance: 1e4,
            renderMatch: defaultRenderMatch
        })
    }),
    Li = Decoration.mark({
        class: "cm-matchingBracket"
    }),
    Vi = Decoration.mark({
        class: "cm-nonmatchingBracket"
    });

function defaultRenderMatch(e) {
    let t = [],
        n = e.matched ? Li : Vi;
    return t.push(n.range(e.start.from, e.start.to)), e.end && t.push(n.range(e.end.from, e.end.to)), t
}
const Zi = StateField.define({
        create: () => Decoration.none,
        update(e, t) {
            if (!t.docChanged && !t.selection) return e;
            let n = [],
                o = t.state.facet(Di);
            for (let e of t.state.selection.ranges) {
                if (!e.empty) continue;
                let h = matchBrackets(t.state, e.head, -1, o) || e.head > 0 && matchBrackets(t.state, e.head - 1, 1, o) || o.afterCursor && (matchBrackets(t.state, e.head, 1, o) || e.head < t.state.doc.length && matchBrackets(t.state, e.head + 1, -1, o));
                h && (n = n.concat(o.renderMatch(h, t.state)))
            }
            return Decoration.set(n, !0)
        },
        provide: e => EditorView.decorations.from(e)
    }),
    _i = [Zi, Mi];

function bracketMatching(e = {}) {
    return [Di.of(e), _i]
}
const Bi = new NodeProp;

function matchingNodes(e, t, n) {
    let o = e.prop(t < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (o) return o;
    if (1 == e.name.length) {
        let o = n.indexOf(e.name);
        if (o > -1 && o % 2 == (t < 0 ? 1 : 0)) return [n[o + t]]
    }
    return null
}

function findHandle(e) {
    let t = e.type.prop(Bi);
    return t ? t(e.node) : e
}

function matchBrackets(e, t, n, o = {}) {
    let h = o.maxScanDistance || 1e4,
        p = o.brackets || Ri,
        f = syntaxTree(e),
        g = f.resolveInner(t, n);
    for (let o = g; o; o = o.parent) {
        let h = matchingNodes(o.type, n, p);
        if (h && o.from < o.to) {
            let f = findHandle(o);
            if (f && (n > 0 ? t >= f.from && t < f.to : t > f.from && t <= f.to)) return matchMarkedBrackets(e, t, n, o, f, h, p)
        }
    }
    return function(e, t, n, o, h, p, f) {
        let g = n < 0 ? e.sliceDoc(t - 1, t) : e.sliceDoc(t, t + 1),
            y = f.indexOf(g);
        if (y < 0 || y % 2 == 0 != n > 0) return null;
        let w = {
                from: n < 0 ? t - 1 : t,
                to: n > 0 ? t + 1 : t
            },
            b = e.doc.iterRange(t, n > 0 ? e.doc.length : 0),
            S = 0;
        for (let e = 0; !b.next().done && e <= p;) {
            let p = b.value;
            n < 0 && (e += p.length);
            let g = t + e * n;
            for (let e = n > 0 ? 0 : p.length - 1, t = n > 0 ? p.length : -1; e != t; e += n) {
                let t = f.indexOf(p[e]);
                if (!(t < 0 || o.resolveInner(g + e, 1).type != h))
                    if (t % 2 == 0 == n > 0) S++;
                    else {
                        if (1 == S) return {
                            start: w,
                            end: {
                                from: g + e,
                                to: g + e + 1
                            },
                            matched: t >> 1 == y >> 1
                        };
                        S--
                    }
            }
            n > 0 && (e += p.length)
        }
        return b.done ? {
            start: w,
            matched: !1
        } : null
    }(e, t, n, f, g.type, h, p)
}

function matchMarkedBrackets(e, t, n, o, h, p, f) {
    let g = o.parent,
        y = {
            from: h.from,
            to: h.to
        },
        w = 0,
        b = null == g ? void 0 : g.cursor();
    if (b && (n < 0 ? b.childBefore(o.from) : b.childAfter(o.to)))
        do {
            if (n < 0 ? b.to <= o.from : b.from >= o.to) {
                if (0 == w && p.indexOf(b.type.name) > -1 && b.from < b.to) {
                    let e = findHandle(b);
                    return {
                        start: y,
                        end: e ? {
                            from: e.from,
                            to: e.to
                        } : void 0,
                        matched: !0
                    }
                }
                if (matchingNodes(b.type, n, f)) w++;
                else if (matchingNodes(b.type, -n, f)) {
                    if (0 == w) {
                        let e = findHandle(b);
                        return {
                            start: y,
                            end: e && e.from < e.to ? {
                                from: e.from,
                                to: e.to
                            } : void 0,
                            matched: !1
                        }
                    }
                    w--
                }
            }
        } while (n < 0 ? b.prevSibling() : b.nextSibling());
    return {
        start: y,
        matched: !1
    }
}

function countCol(e, t, n, o = 0, h = 0) {
    null == t && -1 == (t = e.search(/[^\s\u00a0]/)) && (t = e.length);
    let p = h;
    for (let h = o; h < t; h++) 9 == e.charCodeAt(h) ? p += n - p % n : p++;
    return p
}
class StringStream {
    constructor(e, t, n, o) {
        this.string = e, this.tabSize = t, this.indentUnit = n, this.overrideIndent = o, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0
    }
    eol() {
        return this.pos >= this.string.length
    }
    sol() {
        return 0 == this.pos
    }
    peek() {
        return this.string.charAt(this.pos) || void 0
    }
    next() {
        if (this.pos < this.string.length) return this.string.charAt(this.pos++)
    }
    eat(e) {
        let t, n = this.string.charAt(this.pos);
        if (t = "string" == typeof e ? n == e : n && (e instanceof RegExp ? e.test(n) : e(n)), t) return ++this.pos, n
    }
    eatWhile(e) {
        let t = this.pos;
        for (; this.eat(e););
        return this.pos > t
    }
    eatSpace() {
        let e = this.pos;
        for (;
            /[\s\u00a0]/.test(this.string.charAt(this.pos));) ++this.pos;
        return this.pos > e
    }
    skipToEnd() {
        this.pos = this.string.length
    }
    skipTo(e) {
        let t = this.string.indexOf(e, this.pos);
        if (t > -1) return this.pos = t, !0
    }
    backUp(e) {
        this.pos -= e
    }
    column() {
        return this.lastColumnPos < this.start && (this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue
    }
    indentation() {
        var e;
        return null !== (e = this.overrideIndent) && void 0 !== e ? e : countCol(this.string, null, this.tabSize)
    }
    match(e, t, n) {
        if ("string" == typeof e) {
            let cased = e => n ? e.toLowerCase() : e;
            return cased(this.string.substr(this.pos, e.length)) == cased(e) ? (!1 !== t && (this.pos += e.length), !0) : null
        } {
            let n = this.string.slice(this.pos).match(e);
            return n && n.index > 0 ? null : (n && !1 !== t && (this.pos += n[0].length), n)
        }
    }
    current() {
        return this.string.slice(this.start, this.pos)
    }
}

function defaultCopyState(e) {
    if ("object" != typeof e) return e;
    let t = {};
    for (let n in e) {
        let o = e[n];
        t[n] = o instanceof Array ? o.slice() : o
    }
    return t
}
const Ii = new WeakMap;
class StreamLanguage extends Language {
    constructor(e) {
        let t, n = defineLanguageFacet(e.languageData),
            o = {
                name: (h = e).name || "",
                token: h.token,
                blankLine: h.blankLine || (() => {}),
                startState: h.startState || (() => !0),
                copyState: h.copyState || defaultCopyState,
                indent: h.indent || (() => null),
                languageData: h.languageData || {},
                tokenTable: h.tokenTable || qi
            };
        var h;
        super(n, new class extends Parser {
            createParse(e, n, o) {
                return new Xi(t, e, n, o)
            }
        }, [], e.name), this.topNode = function(e, t) {
            let n = NodeType.define({
                id: zi.length,
                name: "Document",
                props: [ci.add((() => e)), Oi.add((() => e => t.getIndent(e)))],
                top: !0
            });
            return zi.push(n), n
        }(n, this), t = this, this.streamParser = o, this.stateAfter = new NodeProp({
            perNode: !0
        }), this.tokenTable = e.tokenTable ? new TokenTable(o.tokenTable) : Ui
    }
    static define(e) {
        return new StreamLanguage(e)
    }
    getIndent(e) {
        let t, {
            overrideIndentation: n
        } = e.options;
        n && (t = Ii.get(e.state), null != t && t < e.pos - 1e4 && (t = void 0));
        let o, h, p = findState(this, e.node.tree, e.node.from, e.node.from, null != t ? t : e.pos);
        if (p ? (h = p.state, o = p.pos + 1) : (h = this.streamParser.startState(e.unit), o = e.node.from), e.pos - o > 1e4) return null;
        for (; o < e.pos;) {
            let t = e.state.doc.lineAt(o),
                p = Math.min(e.pos, t.to);
            if (t.length) {
                let o = n ? n(t.from) : -1,
                    f = new StringStream(t.text, e.state.tabSize, e.unit, o < 0 ? void 0 : o);
                for (; f.pos < p - t.from;) readToken$1(this.streamParser.token, f, h)
            } else this.streamParser.blankLine(h, e.unit);
            if (p == e.pos) break;
            o = t.to + 1
        }
        let f = e.lineAt(e.pos);
        return n && null == t && Ii.set(e.state, f.from), this.streamParser.indent(h, /^\s*(.*)/.exec(f.text)[1], e)
    }
    get allowsNesting() {
        return !1
    }
}

function findState(e, t, n, o, h) {
    let p = n >= o && n + t.length <= h && t.prop(e.stateAfter);
    if (p) return {
        state: e.streamParser.copyState(p),
        pos: n + t.length
    };
    for (let p = t.children.length - 1; p >= 0; p--) {
        let f = t.children[p],
            g = n + t.positions[p],
            y = f instanceof Tree && g < h && findState(e, f, g, o, h);
        if (y) return y
    }
    return null
}

function cutTree(e, t, n, o, h) {
    if (h && n <= 0 && o >= t.length) return t;
    h || 0 != n || t.type != e.topNode || (h = !0);
    for (let p = t.children.length - 1; p >= 0; p--) {
        let f, g = t.positions[p],
            y = t.children[p];
        if (g < o && y instanceof Tree) {
            if (!(f = cutTree(e, y, n - g, o - g, h))) break;
            return h ? new Tree(t.type, t.children.slice(0, p).concat(f), t.positions.slice(0, p + 1), g + f.length) : f
        }
    }
    return null
}
let Xi = class {
    constructor(e, t, n, o) {
        this.lang = e, this.input = t, this.fragments = n, this.ranges = o, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = o[o.length - 1].to;
        let h = ParseContext.get(),
            p = o[0].from,
            {
                state: f,
                tree: g
            } = function(e, t, n, o, h) {
                for (let h of t) {
                    let t, p = h.from + (h.openStart ? 25 : 0),
                        f = h.to - (h.openEnd ? 25 : 0),
                        g = p <= n && f > n && findState(e, h.tree, 0 - h.offset, n, f);
                    if (g && g.pos <= o && (t = cutTree(e, h.tree, n + h.offset, g.pos + h.offset, !1))) return {
                        state: g.state,
                        tree: t
                    }
                }
                return {
                    state: e.streamParser.startState(h ? getIndentUnit(h) : 4),
                    tree: Tree.empty
                }
            }(e, n, p, this.to, null == h ? void 0 : h.state);
        this.state = f, this.parsedPos = this.chunkStart = p + g.length;
        for (let e = 0; e < g.children.length; e++) this.chunks.push(g.children[e]), this.chunkPos.push(g.positions[e]);
        h && this.parsedPos < h.viewport.from - 1e5 && o.some((e => e.from <= h.viewport.from && e.to >= h.viewport.from)) && (this.state = this.lang.streamParser.startState(getIndentUnit(h.state)), h.skipUntilInView(this.parsedPos, h.viewport.from), this.parsedPos = h.viewport.from), this.moveRangeIndex()
    }
    advance() {
        let e = ParseContext.get(),
            t = null == this.stoppedAt ? this.to : Math.min(this.to, this.stoppedAt),
            n = Math.min(t, this.chunkStart + 2048);
        for (e && (n = Math.min(n, e.viewport.to)); this.parsedPos < n;) this.parseLine(e);
        return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= t ? this.finish() : e && this.parsedPos >= e.viewport.to ? (e.skipUntilInView(this.parsedPos, t), this.finish()) : null
    }
    stopAt(e) {
        this.stoppedAt = e
    }
    lineAfter(e) {
        let t = this.input.chunk(e);
        if (this.input.lineChunks) "\n" == t && (t = "");
        else {
            let e = t.indexOf("\n");
            e > -1 && (t = t.slice(0, e))
        }
        return e + t.length <= this.to ? t : t.slice(0, this.to - e)
    }
    nextLine() {
        let e = this.parsedPos,
            t = this.lineAfter(e),
            n = e + t.length;
        for (let e = this.rangeIndex;;) {
            let o = this.ranges[e].to;
            if (o >= n) break;
            if (t = t.slice(0, o - (n - t.length)), e++, e == this.ranges.length) break;
            let h = this.ranges[e].from,
                p = this.lineAfter(h);
            t += p, n = h + p.length
        }
        return {
            line: t,
            end: n
        }
    }
    skipGapsTo(e, t, n) {
        for (;;) {
            let o = this.ranges[this.rangeIndex].to,
                h = e + t;
            if (n > 0 ? o > h : o >= h) break;
            t += this.ranges[++this.rangeIndex].from - o
        }
        return t
    }
    moveRangeIndex() {
        for (; this.ranges[this.rangeIndex].to < this.parsedPos;) this.rangeIndex++
    }
    emitToken(e, t, n, o) {
        let h = 4;
        if (this.ranges.length > 1) {
            t += o = this.skipGapsTo(t, o, 1);
            let e = this.chunk.length;
            n += o = this.skipGapsTo(n, o, -1), h += this.chunk.length - e
        }
        let p = this.chunk.length - 4;
        return 4 == h && p >= 0 && this.chunk[p] == e && this.chunk[p + 2] == t ? this.chunk[p + 2] = n : this.chunk.push(e, t, n, h), o
    }
    parseLine(e) {
        let {
            line: t,
            end: n
        } = this.nextLine(), o = 0, {
            streamParser: h
        } = this.lang, p = new StringStream(t, e ? e.state.tabSize : 4, e ? getIndentUnit(e.state) : 2);
        if (p.eol()) h.blankLine(this.state, p.indentUnit);
        else
            for (; !p.eol();) {
                let e = readToken$1(h.token, p, this.state);
                if (e && (o = this.emitToken(this.lang.tokenTable.resolve(e), this.parsedPos + p.start, this.parsedPos + p.pos, o)), p.start > 1e4) break
            }
        this.parsedPos = n, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++
    }
    finishChunk() {
        let e = Tree.build({
            buffer: this.chunk,
            start: this.chunkStart,
            length: this.parsedPos - this.chunkStart,
            nodeSet: Ni,
            topID: 0,
            maxBufferLength: 2048,
            reused: this.chunkReused
        });
        e = new Tree(e.type, e.children, e.positions, e.length, [
            [this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]
        ]), this.chunks.push(e), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos
    }
    finish() {
        return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance()
    }
};

function readToken$1(e, t, n) {
    t.start = t.pos;
    for (let o = 0; o < 10; o++) {
        let o = e(t, n);
        if (t.pos > t.start) return o
    }
    throw new Error("Stream parser failed to advance stream.")
}
const qi = Object.create(null),
    zi = [NodeType.none],
    Ni = new NodeSet(zi),
    Yi = [],
    ji = Object.create(null),
    Wi = Object.create(null);
for (let [ah, lh] of [
        ["variable", "variableName"],
        ["variable-2", "variableName.special"],
        ["string-2", "string.special"],
        ["def", "variableName.definition"],
        ["tag", "tagName"],
        ["attribute", "attributeName"],
        ["type", "typeName"],
        ["builtin", "variableName.standard"],
        ["qualifier", "modifier"],
        ["error", "invalid"],
        ["header", "heading"],
        ["property", "propertyName"]
    ]) Wi[ah] = createTokenType(qi, lh);
class TokenTable {
    constructor(e) {
        this.extra = e, this.table = Object.assign(Object.create(null), Wi)
    }
    resolve(e) {
        return e ? this.table[e] || (this.table[e] = createTokenType(this.extra, e)) : 0
    }
}
const Ui = new TokenTable(qi);

function warnForPart(e, t) {
    Yi.indexOf(e) > -1 || (Yi.push(e), console.warn(t))
}

function createTokenType(e, t) {
    let n = [];
    for (let o of t.split(" ")) {
        let t = [];
        for (let n of o.split(".")) {
            let o = e[n] || ai[n];
            o ? "function" == typeof o ? t.length ? t = t.map(o) : warnForPart(n, `Modifier ${n} used at start of tag`) : t.length ? warnForPart(n, `Tag ${n} used as modifier`) : t = Array.isArray(o) ? o : [o] : warnForPart(n, `Unknown highlighting tag ${n}`)
        }
        for (let e of t) n.push(e)
    }
    if (!n.length) return 0;
    let o = t.replace(/ /g, "_"),
        h = o + " " + n.map((e => e.id)),
        p = ji[h];
    if (p) return p.id;
    let f = ji[h] = NodeType.define({
        id: zi.length,
        name: o,
        props: [styleTags({
            [o]: n
        })]
    });
    return zi.push(f), f.id
}
pe.RTL, pe.LTR;

function command(e, t) {
    return ({
        state: n,
        dispatch: o
    }) => {
        if (n.readOnly) return !1;
        let h = e(t, n);
        return !!h && (o(n.update(h)), !0)
    }
}
const Fi = command(changeLineComment, 0),
    Gi = command(changeBlockComment, 0),
    Hi = command(((e, t) => changeBlockComment(e, t, function(e) {
        let t = [];
        for (let n of e.selection.ranges) {
            let o = e.doc.lineAt(n.from),
                h = n.to <= o.to ? o : e.doc.lineAt(n.to);
            h.from > o.from && h.from == n.to && (h = n.to == o.to + 1 ? o : e.doc.lineAt(n.to - 1));
            let p = t.length - 1;
            p >= 0 && t[p].to > o.from ? t[p].to = h.to : t.push({
                from: o.from + /^\s*/.exec(o.text)[0].length,
                to: h.to
            })
        }
        return t
    }(t))), 0);

function getConfig(e, t) {
    let n = e.languageDataAt("commentTokens", t);
    return n.length ? n[0] : {}
}
const Ki = 50;

function changeBlockComment(e, t, n = t.selection.ranges) {
    let o = n.map((e => getConfig(t, e.from).block));
    if (!o.every((e => e))) return null;
    let h = n.map(((e, n) => function(e, {
        open: t,
        close: n
    }, o, h) {
        let p, f, g = e.sliceDoc(o - Ki, o),
            y = e.sliceDoc(h, h + Ki),
            w = /\s*$/.exec(g)[0].length,
            b = /^\s*/.exec(y)[0].length,
            S = g.length - w;
        if (g.slice(S - t.length, S) == t && y.slice(b, b + n.length) == n) return {
            open: {
                pos: o - w,
                margin: w && 1
            },
            close: {
                pos: h + b,
                margin: b && 1
            }
        };
        h - o <= 2 * Ki ? p = f = e.sliceDoc(o, h) : (p = e.sliceDoc(o, o + Ki), f = e.sliceDoc(h - Ki, h));
        let k = /^\s*/.exec(p)[0].length,
            v = /\s*$/.exec(f)[0].length,
            P = f.length - v - n.length;
        return p.slice(k, k + t.length) == t && f.slice(P, P + n.length) == n ? {
            open: {
                pos: o + k + t.length,
                margin: /\s/.test(p.charAt(k + t.length)) ? 1 : 0
            },
            close: {
                pos: h - v - n.length,
                margin: /\s/.test(f.charAt(P - 1)) ? 1 : 0
            }
        } : null
    }(t, o[n], e.from, e.to)));
    if (2 != e && !h.every((e => e))) return {
        changes: t.changes(n.map(((e, t) => h[t] ? [] : [{
            from: e.from,
            insert: o[t].open + " "
        }, {
            from: e.to,
            insert: " " + o[t].close
        }])))
    };
    if (1 != e && h.some((e => e))) {
        let e = [];
        for (let t, n = 0; n < h.length; n++)
            if (t = h[n]) {
                let h = o[n],
                    {
                        open: p,
                        close: f
                    } = t;
                e.push({
                    from: p.pos - h.open.length,
                    to: p.pos + p.margin
                }, {
                    from: f.pos - f.margin,
                    to: f.pos + h.close.length
                })
            }
        return {
            changes: e
        }
    }
    return null
}

function changeLineComment(e, t, n = t.selection.ranges) {
    let o = [],
        h = -1;
    for (let {
            from: e,
            to: p
        } of n) {
        let n = o.length,
            f = 1e9,
            g = getConfig(t, e).line;
        if (g) {
            for (let n = e; n <= p;) {
                let y = t.doc.lineAt(n);
                if (y.from > h && (e == p || p > y.from)) {
                    h = y.from;
                    let e = /^\s*/.exec(y.text)[0].length,
                        t = e == y.length,
                        n = y.text.slice(e, e + g.length) == g ? e : -1;
                    e < y.text.length && e < f && (f = e), o.push({
                        line: y,
                        comment: n,
                        token: g,
                        indent: e,
                        empty: t,
                        single: !1
                    })
                }
                n = y.to + 1
            }
            if (f < 1e9)
                for (let e = n; e < o.length; e++) o[e].indent < o[e].line.text.length && (o[e].indent = f);
            o.length == n + 1 && (o[n].single = !0)
        }
    }
    if (2 != e && o.some((e => e.comment < 0 && (!e.empty || e.single)))) {
        let e = [];
        for (let {
                line: t,
                token: n,
                indent: h,
                empty: p,
                single: f
            } of o) !f && p || e.push({
            from: t.from + h,
            insert: n + " "
        });
        let n = t.changes(e);
        return {
            changes: n,
            selection: t.selection.map(n, 1)
        }
    }
    if (1 != e && o.some((e => e.comment >= 0))) {
        let e = [];
        for (let {
                line: t,
                comment: n,
                token: h
            } of o)
            if (n >= 0) {
                let o = t.from + n,
                    p = o + h.length;
                " " == t.text[p - t.from] && p++, e.push({
                    from: o,
                    to: p
                })
            }
        return {
            changes: e
        }
    }
    return null
}
const Ji = Annotation.define(),
    er = Annotation.define(),
    tr = Facet.define(),
    nr = Facet.define({
        combine: e => combineConfig(e, {
            minDepth: 100,
            newGroupDelay: 500,
            joinToEvent: (e, t) => t
        }, {
            minDepth: Math.max,
            newGroupDelay: Math.min,
            joinToEvent: (e, t) => (n, o) => e(n, o) || t(n, o)
        })
    }),
    ir = StateField.define({
        create: () => HistoryState.empty,
        update(e, t) {
            let n = t.state.facet(nr),
                o = t.annotation(Ji);
            if (o) {
                let h = HistEvent.fromTransaction(t, o.selection),
                    p = o.side,
                    f = 0 == p ? e.undone : e.done;
                return f = h ? updateBranch(f, f.length, n.minDepth, h) : addSelection(f, t.startState.selection), new HistoryState(0 == p ? o.rest : f, 0 == p ? f : o.rest)
            }
            let h = t.annotation(er);
            if ("full" != h && "before" != h || (e = e.isolate()), !1 === t.annotation(A.addToHistory)) return t.changes.empty ? e : e.addMapping(t.changes.desc);
            let p = HistEvent.fromTransaction(t),
                f = t.annotation(A.time),
                g = t.annotation(A.userEvent);
            return p ? e = e.addChanges(p, f, g, n, t) : t.selection && (e = e.addSelection(t.startState.selection, f, g, n.newGroupDelay)), "full" != h && "after" != h || (e = e.isolate()), e
        },
        toJSON: e => ({
            done: e.done.map((e => e.toJSON())),
            undone: e.undone.map((e => e.toJSON()))
        }),
        fromJSON: e => new HistoryState(e.done.map(HistEvent.fromJSON), e.undone.map(HistEvent.fromJSON))
    });

function history(e = {}) {
    return [ir, nr.of(e), EditorView.domEventHandlers({
        beforeinput(e, t) {
            let n = "historyUndo" == e.inputType ? rr : "historyRedo" == e.inputType ? or : null;
            return !!n && (e.preventDefault(), n(t))
        }
    })]
}

function cmd(e, t) {
    return function({
        state: n,
        dispatch: o
    }) {
        if (!t && n.readOnly) return !1;
        let h = n.field(ir, !1);
        if (!h) return !1;
        let p = h.pop(e, n, t);
        return !!p && (o(p), !0)
    }
}
const rr = cmd(0, !1),
    or = cmd(1, !1),
    sr = cmd(0, !0),
    ar = cmd(1, !0);
class HistEvent {
    constructor(e, t, n, o, h) {
        this.changes = e, this.effects = t, this.mapped = n, this.startSelection = o, this.selectionsAfter = h
    }
    setSelAfter(e) {
        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, e)
    }
    toJSON() {
        var e, t, n;
        return {
            changes: null === (e = this.changes) || void 0 === e ? void 0 : e.toJSON(),
            mapped: null === (t = this.mapped) || void 0 === t ? void 0 : t.toJSON(),
            startSelection: null === (n = this.startSelection) || void 0 === n ? void 0 : n.toJSON(),
            selectionsAfter: this.selectionsAfter.map((e => e.toJSON()))
        }
    }
    static fromJSON(e) {
        return new HistEvent(e.changes && ChangeSet.fromJSON(e.changes), [], e.mapped && ChangeDesc.fromJSON(e.mapped), e.startSelection && EditorSelection.fromJSON(e.startSelection), e.selectionsAfter.map(EditorSelection.fromJSON))
    }
    static fromTransaction(e, t) {
        let n = lr;
        for (let t of e.startState.facet(tr)) {
            let o = t(e);
            o.length && (n = n.concat(o))
        }
        return !n.length && e.changes.empty ? null : new HistEvent(e.changes.invert(e.startState.doc), n, void 0, t || e.startState.selection, lr)
    }
    static selection(e) {
        return new HistEvent(void 0, lr, void 0, void 0, e)
    }
}

function updateBranch(e, t, n, o) {
    let h = t + 1 > n + 20 ? t - n - 1 : 0,
        p = e.slice(h, t);
    return p.push(o), p
}

function conc(e, t) {
    return e.length ? t.length ? e.concat(t) : e : t
}
const lr = [],
    cr = 200;

function addSelection(e, t) {
    if (e.length) {
        let n = e[e.length - 1],
            o = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - cr));
        return o.length && o[o.length - 1].eq(t) ? e : (o.push(t), updateBranch(e, e.length - 1, 1e9, n.setSelAfter(o)))
    }
    return [HistEvent.selection([t])]
}

function popSelection(e) {
    let t = e[e.length - 1],
        n = e.slice();
    return n[e.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), n
}

function addMappingToBranch(e, t) {
    if (!e.length) return e;
    let n = e.length,
        o = lr;
    for (; n;) {
        let h = mapEvent(e[n - 1], t, o);
        if (h.changes && !h.changes.empty || h.effects.length) {
            let t = e.slice(0, n);
            return t[n - 1] = h, t
        }
        t = h.mapped, n--, o = h.selectionsAfter
    }
    return o.length ? [HistEvent.selection(o)] : lr
}

function mapEvent(e, t, n) {
    let o = conc(e.selectionsAfter.length ? e.selectionsAfter.map((e => e.map(t))) : lr, n);
    if (!e.changes) return HistEvent.selection(o);
    let h = e.changes.map(t),
        p = t.mapDesc(e.changes, !0),
        f = e.mapped ? e.mapped.composeDesc(p) : p;
    return new HistEvent(h, StateEffect.mapEffects(e.effects, t), f, e.startSelection.map(p), o)
}
const hr = /^(input\.type|delete)($|\.)/;
class HistoryState {
    constructor(e, t, n = 0, o = void 0) {
        this.done = e, this.undone = t, this.prevTime = n, this.prevUserEvent = o
    }
    isolate() {
        return this.prevTime ? new HistoryState(this.done, this.undone) : this
    }
    addChanges(e, t, n, o, h) {
        let p = this.done,
            f = p[p.length - 1];
        return p = f && f.changes && !f.changes.empty && e.changes && (!n || hr.test(n)) && (!f.selectionsAfter.length && t - this.prevTime < o.newGroupDelay && o.joinToEvent(h, function(e, t) {
            let n = [],
                o = !1;
            return e.iterChangedRanges(((e, t) => n.push(e, t))), t.iterChangedRanges(((e, t, h, p) => {
                for (let e = 0; e < n.length;) {
                    let t = n[e++],
                        f = n[e++];
                    p >= t && h <= f && (o = !0)
                }
            })), o
        }(f.changes, e.changes)) || "input.type.compose" == n) ? updateBranch(p, p.length - 1, o.minDepth, new HistEvent(e.changes.compose(f.changes), conc(StateEffect.mapEffects(e.effects, f.changes), f.effects), f.mapped, f.startSelection, lr)) : updateBranch(p, p.length, o.minDepth, e), new HistoryState(p, lr, t, n)
    }
    addSelection(e, t, n, o) {
        let h = this.done.length ? this.done[this.done.length - 1].selectionsAfter : lr;
        return h.length > 0 && t - this.prevTime < o && n == this.prevUserEvent && n && /^select($|\.)/.test(n) && (p = h[h.length - 1], f = e, p.ranges.length == f.ranges.length && 0 === p.ranges.filter(((e, t) => e.empty != f.ranges[t].empty)).length) ? this : new HistoryState(addSelection(this.done, e), this.undone, t, n);
        var p, f
    }
    addMapping(e) {
        return new HistoryState(addMappingToBranch(this.done, e), addMappingToBranch(this.undone, e), this.prevTime, this.prevUserEvent)
    }
    pop(e, t, n) {
        let o = 0 == e ? this.done : this.undone;
        if (0 == o.length) return null;
        let h = o[o.length - 1],
            p = h.selectionsAfter[0] || t.selection;
        if (n && h.selectionsAfter.length) return t.update({
            selection: h.selectionsAfter[h.selectionsAfter.length - 1],
            annotations: Ji.of({
                side: e,
                rest: popSelection(o),
                selection: p
            }),
            userEvent: 0 == e ? "select.undo" : "select.redo",
            scrollIntoView: !0
        });
        if (h.changes) {
            let n = 1 == o.length ? lr : o.slice(0, o.length - 1);
            return h.mapped && (n = addMappingToBranch(n, h.mapped)), t.update({
                changes: h.changes,
                selection: h.startSelection,
                effects: h.effects,
                annotations: Ji.of({
                    side: e,
                    rest: n,
                    selection: p
                }),
                filter: !1,
                userEvent: 0 == e ? "undo" : "redo",
                scrollIntoView: !0
            })
        }
        return null
    }
}
HistoryState.empty = new HistoryState(lr, lr);
const dr = [{
    key: "Mod-z",
    run: rr,
    preventDefault: !0
}, {
    key: "Mod-y",
    mac: "Mod-Shift-z",
    run: or,
    preventDefault: !0
}, {
    linux: "Ctrl-Shift-z",
    run: or,
    preventDefault: !0
}, {
    key: "Mod-u",
    run: sr,
    preventDefault: !0
}, {
    key: "Alt-u",
    mac: "Mod-Shift-u",
    run: ar,
    preventDefault: !0
}];

function updateSel(e, t) {
    return EditorSelection.create(e.ranges.map(t), e.mainIndex)
}

function setSel(e, t) {
    return e.update({
        selection: t,
        scrollIntoView: !0,
        userEvent: "select"
    })
}

function moveSel({
    state: e,
    dispatch: t
}, n) {
    let o = updateSel(e.selection, n);
    return !o.eq(e.selection, !0) && (t(setSel(e, o)), !0)
}

function rangeEnd(e, t) {
    return EditorSelection.cursor(t ? e.to : e.from)
}

function cursorByChar(e, t) {
    return moveSel(e, (n => n.empty ? e.moveByChar(n, t) : rangeEnd(n, t)))
}

function ltrAtCursor(e) {
    return e.textDirectionAt(e.state.selection.main.head) == pe.LTR
}
const cursorCharLeft = e => cursorByChar(e, !ltrAtCursor(e)),
    cursorCharRight = e => cursorByChar(e, ltrAtCursor(e));

function cursorByGroup(e, t) {
    return moveSel(e, (n => n.empty ? e.moveByGroup(n, t) : rangeEnd(n, t)))
}

function interestingNode(e, t, n) {
    if (t.type.prop(n)) return !0;
    let o = t.to - t.from;
    return o && (o > 2 || /[^\s,.;:]/.test(e.sliceDoc(t.from, t.to))) || t.firstChild
}

function moveBySyntax(e, t, n) {
    let o, h, p = syntaxTree(e).resolveInner(t.head),
        f = n ? NodeProp.closedBy : NodeProp.openedBy;
    for (let o = t.head;;) {
        let t = n ? p.childAfter(o) : p.childBefore(o);
        if (!t) break;
        interestingNode(e, t, f) ? p = t : o = n ? t.to : t.from
    }
    return h = p.type.prop(f) && (o = n ? matchBrackets(e, p.from, 1) : matchBrackets(e, p.to, -1)) && o.matched ? n ? o.end.to : o.end.from : n ? p.to : p.from, EditorSelection.cursor(h, n ? -1 : 1)
}

function cursorByLine(e, t) {
    return moveSel(e, (n => {
        if (!n.empty) return rangeEnd(n, t);
        let o = e.moveVertically(n, t);
        return o.head != n.head ? o : e.moveToLineBoundary(n, t)
    }))
}
const cursorLineUp = e => cursorByLine(e, !1),
    cursorLineDown = e => cursorByLine(e, !0);

function pageInfo(e) {
    let t, n = e.scrollDOM.clientHeight < e.scrollDOM.scrollHeight - 2,
        o = 0,
        h = 0;
    if (n) {
        for (let t of e.state.facet(EditorView.scrollMargins)) {
            let n = t(e);
            (null == n ? void 0 : n.top) && (o = Math.max(null == n ? void 0 : n.top, o)), (null == n ? void 0 : n.bottom) && (h = Math.max(null == n ? void 0 : n.bottom, h))
        }
        t = e.scrollDOM.clientHeight - o - h
    } else t = (e.dom.ownerDocument.defaultView || window).innerHeight;
    return {
        marginTop: o,
        marginBottom: h,
        selfScroll: n,
        height: Math.max(e.defaultLineHeight, t - 5)
    }
}

function cursorByPage(e, t) {
    let n, o = pageInfo(e),
        {
            state: h
        } = e,
        p = updateSel(h.selection, (n => n.empty ? e.moveVertically(n, t, o.height) : rangeEnd(n, t)));
    if (p.eq(h.selection)) return !1;
    if (o.selfScroll) {
        let t = e.coordsAtPos(h.selection.main.head),
            f = e.scrollDOM.getBoundingClientRect(),
            g = f.top + o.marginTop,
            y = f.bottom - o.marginBottom;
        t && t.top > g && t.bottom < y && (n = EditorView.scrollIntoView(p.main.head, {
            y: "start",
            yMargin: t.top - g
        }))
    }
    return e.dispatch(setSel(h, p), {
        effects: n
    }), !0
}
const cursorPageUp = e => cursorByPage(e, !1),
    cursorPageDown = e => cursorByPage(e, !0);

function moveByLineBoundary(e, t, n) {
    let o = e.lineBlockAt(t.head),
        h = e.moveToLineBoundary(t, n);
    if (h.head == t.head && h.head != (n ? o.to : o.from) && (h = e.moveToLineBoundary(t, n, !1)), !n && h.head == o.from && o.length) {
        let n = /^\s*/.exec(e.state.sliceDoc(o.from, Math.min(o.from + 100, o.to)))[0].length;
        n && t.head != o.from + n && (h = EditorSelection.cursor(o.from + n))
    }
    return h
}

function extendSel(e, t) {
    let n = updateSel(e.state.selection, (e => {
        let n = t(e);
        return EditorSelection.range(e.anchor, n.head, n.goalColumn, n.bidiLevel || void 0)
    }));
    return !n.eq(e.state.selection) && (e.dispatch(setSel(e.state, n)), !0)
}

function selectByChar(e, t) {
    return extendSel(e, (n => e.moveByChar(n, t)))
}
const selectCharLeft = e => selectByChar(e, !ltrAtCursor(e)),
    selectCharRight = e => selectByChar(e, ltrAtCursor(e));

function selectByGroup(e, t) {
    return extendSel(e, (n => e.moveByGroup(n, t)))
}

function selectByLine(e, t) {
    return extendSel(e, (n => e.moveVertically(n, t)))
}
const selectLineUp = e => selectByLine(e, !1),
    selectLineDown = e => selectByLine(e, !0);

function selectByPage(e, t) {
    return extendSel(e, (n => e.moveVertically(n, t, pageInfo(e).height)))
}
const selectPageUp = e => selectByPage(e, !1),
    selectPageDown = e => selectByPage(e, !0),
    cursorDocStart = ({
        state: e,
        dispatch: t
    }) => (t(setSel(e, {
        anchor: 0
    })), !0),
    cursorDocEnd = ({
        state: e,
        dispatch: t
    }) => (t(setSel(e, {
        anchor: e.doc.length
    })), !0),
    selectDocStart = ({
        state: e,
        dispatch: t
    }) => (t(setSel(e, {
        anchor: e.selection.main.anchor,
        head: 0
    })), !0),
    selectDocEnd = ({
        state: e,
        dispatch: t
    }) => (t(setSel(e, {
        anchor: e.selection.main.anchor,
        head: e.doc.length
    })), !0);

function deleteBy(e, t) {
    if (e.state.readOnly) return !1;
    let n = "delete.selection",
        {
            state: o
        } = e,
        h = o.changeByRange((o => {
            let {
                from: h,
                to: p
            } = o;
            if (h == p) {
                let f = t(o);
                f < h ? (n = "delete.backward", f = skipAtomic(e, f, !1)) : f > h && (n = "delete.forward", f = skipAtomic(e, f, !0)), h = Math.min(h, f), p = Math.max(p, f)
            } else h = skipAtomic(e, h, !1), p = skipAtomic(e, p, !0);
            return h == p ? {
                range: o
            } : {
                changes: {
                    from: h,
                    to: p
                },
                range: EditorSelection.cursor(h, h < o.head ? -1 : 1)
            }
        }));
    return !h.changes.empty && (e.dispatch(o.update(h, {
        scrollIntoView: !0,
        userEvent: n,
        effects: "delete.selection" == n ? EditorView.announce.of(o.phrase("Selection deleted")) : void 0
    })), !0)
}

function skipAtomic(e, t, n) {
    if (e instanceof EditorView)
        for (let o of e.state.facet(EditorView.atomicRanges).map((t => t(e)))) o.between(t, t, ((e, o) => {
            e < t && o > t && (t = n ? o : e)
        }));
    return t
}
const deleteByChar = (e, t, n) => deleteBy(e, (o => {
        let h, p, f = o.from,
            {
                state: g
            } = e,
            y = g.doc.lineAt(f);
        if (n && !t && f > y.from && f < y.from + 200 && !/[^ \t]/.test(h = y.text.slice(0, f - y.from))) {
            if ("\t" == h[h.length - 1]) return f - 1;
            let e = countColumn(h, g.tabSize) % getIndentUnit(g) || getIndentUnit(g);
            for (let t = 0; t < e && " " == h[h.length - 1 - t]; t++) f--;
            p = f
        } else p = findClusterBreak(y.text, f - y.from, t, t) + y.from, p == f && y.number != (t ? g.doc.lines : 1) ? p += t ? 1 : -1 : !t && /[\ufe00-\ufe0f]/.test(y.text.slice(p - y.from, f - y.from)) && (p = findClusterBreak(y.text, p - y.from, !1, !1) + y.from);
        return p
    })),
    deleteCharBackward = e => deleteByChar(e, !1, !0),
    deleteCharForward = e => deleteByChar(e, !0, !1),
    deleteByGroup = (e, t) => deleteBy(e, (n => {
        let o = n.head,
            {
                state: h
            } = e,
            p = h.doc.lineAt(o),
            f = h.charCategorizer(o);
        for (let e = null;;) {
            if (o == (t ? p.to : p.from)) {
                o == n.head && p.number != (t ? h.doc.lines : 1) && (o += t ? 1 : -1);
                break
            }
            let g = findClusterBreak(p.text, o - p.from, t) + p.from,
                y = p.text.slice(Math.min(o, g) - p.from, Math.max(o, g) - p.from),
                w = f(y);
            if (null != e && w != e) break;
            " " == y && o == n.head || (e = w), o = g
        }
        return o
    })),
    deleteGroupBackward = e => deleteByGroup(e, !1);

function selectedLineBlocks(e) {
    let t = [],
        n = -1;
    for (let o of e.selection.ranges) {
        let h = e.doc.lineAt(o.from),
            p = e.doc.lineAt(o.to);
        if (o.empty || o.to != p.from || (p = e.doc.lineAt(o.to - 1)), n >= h.number) {
            let e = t[t.length - 1];
            e.to = p.to, e.ranges.push(o)
        } else t.push({
            from: h.from,
            to: p.to,
            ranges: [o]
        });
        n = p.number + 1
    }
    return t
}

function moveLine(e, t, n) {
    if (e.readOnly) return !1;
    let o = [],
        h = [];
    for (let t of selectedLineBlocks(e)) {
        if (n ? t.to == e.doc.length : 0 == t.from) continue;
        let p = e.doc.lineAt(n ? t.to + 1 : t.from - 1),
            f = p.length + 1;
        if (n) {
            o.push({
                from: t.to,
                to: p.to
            }, {
                from: t.from,
                insert: p.text + e.lineBreak
            });
            for (let n of t.ranges) h.push(EditorSelection.range(Math.min(e.doc.length, n.anchor + f), Math.min(e.doc.length, n.head + f)))
        } else {
            o.push({
                from: p.from,
                to: t.from
            }, {
                from: t.to,
                insert: e.lineBreak + p.text
            });
            for (let e of t.ranges) h.push(EditorSelection.range(e.anchor - f, e.head - f))
        }
    }
    return !!o.length && (t(e.update({
        changes: o,
        scrollIntoView: !0,
        selection: EditorSelection.create(h, e.selection.mainIndex),
        userEvent: "move.line"
    })), !0)
}

function copyLine(e, t, n) {
    if (e.readOnly) return !1;
    let o = [];
    for (let t of selectedLineBlocks(e)) n ? o.push({
        from: t.from,
        insert: e.doc.slice(t.from, t.to) + e.lineBreak
    }) : o.push({
        from: t.to,
        insert: e.lineBreak + e.doc.slice(t.from, t.to)
    });
    return t(e.update({
        changes: o,
        scrollIntoView: !0,
        userEvent: "input.copyline"
    })), !0
}
const ur = newlineAndIndent(!1);

function newlineAndIndent(e) {
    return ({
        state: t,
        dispatch: n
    }) => {
        if (t.readOnly) return !1;
        let o = t.changeByRange((n => {
            let {
                from: o,
                to: h
            } = n, p = t.doc.lineAt(o), f = !e && o == h && function(e, t) {
                if (/\(\)|\[\]|\{\}/.test(e.sliceDoc(t - 1, t + 1))) return {
                    from: t,
                    to: t
                };
                let n, o = syntaxTree(e).resolveInner(t),
                    h = o.childBefore(t),
                    p = o.childAfter(t);
                return h && p && h.to <= t && p.from >= t && (n = h.type.prop(NodeProp.closedBy)) && n.indexOf(p.name) > -1 && e.doc.lineAt(h.to).from == e.doc.lineAt(p.from).from && !/\S/.test(e.sliceDoc(h.to, p.from)) ? {
                    from: h.to,
                    to: p.from
                } : null
            }(t, o);
            e && (o = h = (h <= p.to ? p : t.doc.lineAt(h)).to);
            let g = new IndentContext(t, {
                    simulateBreak: o,
                    simulateDoubleBreak: !!f
                }),
                y = getIndentation(g, o);
            for (null == y && (y = countColumn(/^\s*/.exec(t.doc.lineAt(o).text)[0], t.tabSize)); h < p.to && /\s/.test(p.text[h - p.from]);) h++;
            f ? ({
                from: o,
                to: h
            } = f) : o > p.from && o < p.from + 100 && !/\S/.test(p.text.slice(0, o)) && (o = p.from);
            let w = ["", indentString(t, y)];
            return f && w.push(indentString(t, g.lineIndent(p.from, -1))), {
                changes: {
                    from: o,
                    to: h,
                    insert: Text.of(w)
                },
                range: EditorSelection.cursor(o + 1 + w[1].length)
            }
        }));
        return n(t.update(o, {
            scrollIntoView: !0,
            userEvent: "input"
        })), !0
    }
}

function changeBySelectedLine(e, t) {
    let n = -1;
    return e.changeByRange((o => {
        let h = [];
        for (let p = o.from; p <= o.to;) {
            let f = e.doc.lineAt(p);
            f.number > n && (o.empty || o.to > f.from) && (t(f, h, o), n = f.number), p = f.to + 1
        }
        let p = e.changes(h);
        return {
            changes: h,
            range: EditorSelection.range(p.mapPos(o.anchor, 1), p.mapPos(o.head, 1))
        }
    }))
}
const indentMore = ({
        state: e,
        dispatch: t
    }) => !e.readOnly && (t(e.update(changeBySelectedLine(e, ((t, n) => {
        n.push({
            from: t.from,
            insert: e.facet(mi)
        })
    })), {
        userEvent: "input.indent"
    })), !0),
    indentLess = ({
        state: e,
        dispatch: t
    }) => !e.readOnly && (t(e.update(changeBySelectedLine(e, ((t, n) => {
        let o = /^\s*/.exec(t.text)[0];
        if (!o) return;
        let h = countColumn(o, e.tabSize),
            p = 0,
            f = indentString(e, Math.max(0, h - getIndentUnit(e)));
        for (; p < o.length && p < f.length && o.charCodeAt(p) == f.charCodeAt(p);) p++;
        n.push({
            from: t.from + p,
            to: t.from + o.length,
            insert: f.slice(p)
        })
    })), {
        userEvent: "delete.dedent"
    })), !0),
    pr = [{
        key: "Ctrl-b",
        run: cursorCharLeft,
        shift: selectCharLeft,
        preventDefault: !0
    }, {
        key: "Ctrl-f",
        run: cursorCharRight,
        shift: selectCharRight
    }, {
        key: "Ctrl-p",
        run: cursorLineUp,
        shift: selectLineUp
    }, {
        key: "Ctrl-n",
        run: cursorLineDown,
        shift: selectLineDown
    }, {
        key: "Ctrl-a",
        run: e => moveSel(e, (t => EditorSelection.cursor(e.lineBlockAt(t.head).from, 1))),
        shift: e => extendSel(e, (t => EditorSelection.cursor(e.lineBlockAt(t.head).from)))
    }, {
        key: "Ctrl-e",
        run: e => moveSel(e, (t => EditorSelection.cursor(e.lineBlockAt(t.head).to, -1))),
        shift: e => extendSel(e, (t => EditorSelection.cursor(e.lineBlockAt(t.head).to)))
    }, {
        key: "Ctrl-d",
        run: deleteCharForward
    }, {
        key: "Ctrl-h",
        run: deleteCharBackward
    }, {
        key: "Ctrl-k",
        run: e => deleteBy(e, (t => {
            let n = e.lineBlockAt(t.head).to;
            return t.head < n ? n : Math.min(e.state.doc.length, t.head + 1)
        }))
    }, {
        key: "Ctrl-Alt-h",
        run: deleteGroupBackward
    }, {
        key: "Ctrl-o",
        run: ({
            state: e,
            dispatch: t
        }) => {
            if (e.readOnly) return !1;
            let n = e.changeByRange((e => ({
                changes: {
                    from: e.from,
                    to: e.to,
                    insert: Text.of(["", ""])
                },
                range: EditorSelection.cursor(e.from)
            })));
            return t(e.update(n, {
                scrollIntoView: !0,
                userEvent: "input"
            })), !0
        }
    }, {
        key: "Ctrl-t",
        run: ({
            state: e,
            dispatch: t
        }) => {
            if (e.readOnly) return !1;
            let n = e.changeByRange((t => {
                if (!t.empty || 0 == t.from || t.from == e.doc.length) return {
                    range: t
                };
                let n = t.from,
                    o = e.doc.lineAt(n),
                    h = n == o.from ? n - 1 : findClusterBreak(o.text, n - o.from, !1) + o.from,
                    p = n == o.to ? n + 1 : findClusterBreak(o.text, n - o.from, !0) + o.from;
                return {
                    changes: {
                        from: h,
                        to: p,
                        insert: e.doc.slice(n, p).append(e.doc.slice(h, n))
                    },
                    range: EditorSelection.cursor(p)
                }
            }));
            return !n.changes.empty && (t(e.update(n, {
                scrollIntoView: !0,
                userEvent: "move.character"
            })), !0)
        }
    }, {
        key: "Ctrl-v",
        run: cursorPageDown
    }],
    fr = [{
        key: "Alt-ArrowLeft",
        mac: "Ctrl-ArrowLeft",
        run: e => moveSel(e, (t => moveBySyntax(e.state, t, !ltrAtCursor(e)))),
        shift: e => extendSel(e, (t => moveBySyntax(e.state, t, !ltrAtCursor(e))))
    }, {
        key: "Alt-ArrowRight",
        mac: "Ctrl-ArrowRight",
        run: e => moveSel(e, (t => moveBySyntax(e.state, t, ltrAtCursor(e)))),
        shift: e => extendSel(e, (t => moveBySyntax(e.state, t, ltrAtCursor(e))))
    }, {
        key: "Alt-ArrowUp",
        run: ({
            state: e,
            dispatch: t
        }) => moveLine(e, t, !1)
    }, {
        key: "Shift-Alt-ArrowUp",
        run: ({
            state: e,
            dispatch: t
        }) => copyLine(e, t, !1)
    }, {
        key: "Alt-ArrowDown",
        run: ({
            state: e,
            dispatch: t
        }) => moveLine(e, t, !0)
    }, {
        key: "Shift-Alt-ArrowDown",
        run: ({
            state: e,
            dispatch: t
        }) => copyLine(e, t, !0)
    }, {
        key: "Escape",
        run: ({
            state: e,
            dispatch: t
        }) => {
            let n = e.selection,
                o = null;
            return n.ranges.length > 1 ? o = EditorSelection.create([n.main]) : n.main.empty || (o = EditorSelection.create([EditorSelection.cursor(n.main.head)])), !!o && (t(setSel(e, o)), !0)
        }
    }, {
        key: "Mod-Enter",
        run: newlineAndIndent(!0)
    }, {
        key: "Alt-l",
        mac: "Ctrl-l",
        run: ({
            state: e,
            dispatch: t
        }) => {
            let n = selectedLineBlocks(e).map((({
                from: t,
                to: n
            }) => EditorSelection.range(t, Math.min(n + 1, e.doc.length))));
            return t(e.update({
                selection: EditorSelection.create(n),
                userEvent: "select"
            })), !0
        }
    }, {
        key: "Mod-i",
        run: ({
            state: e,
            dispatch: t
        }) => {
            let n = updateSel(e.selection, (t => {
                let n = syntaxTree(e),
                    o = n.resolveStack(t.from, 1);
                if (t.empty) {
                    let e = n.resolveStack(t.from, -1);
                    e.node.from >= o.node.from && e.node.to <= o.node.to && (o = e)
                }
                for (let e = o; e; e = e.next) {
                    let {
                        node: n
                    } = e;
                    if ((n.from < t.from && n.to >= t.to || n.to > t.to && n.from <= t.from) && e.next) return EditorSelection.range(n.to, n.from)
                }
                return t
            }));
            return !n.eq(e.selection) && (t(setSel(e, n)), !0)
        },
        preventDefault: !0
    }, {
        key: "Mod-[",
        run: indentLess
    }, {
        key: "Mod-]",
        run: indentMore
    }, {
        key: "Mod-Alt-\\",
        run: ({
            state: e,
            dispatch: t
        }) => {
            if (e.readOnly) return !1;
            let n = Object.create(null),
                o = new IndentContext(e, {
                    overrideIndentation: e => {
                        let t = n[e];
                        return null == t ? -1 : t
                    }
                }),
                h = changeBySelectedLine(e, ((t, h, p) => {
                    let f = getIndentation(o, t.from);
                    if (null == f) return;
                    /\S/.test(t.text) || (f = 0);
                    let g = /^\s*/.exec(t.text)[0],
                        y = indentString(e, f);
                    (g != y || p.from < t.from + g.length) && (n[t.from] = f, h.push({
                        from: t.from,
                        to: t.from + g.length,
                        insert: y
                    }))
                }));
            return h.changes.empty || t(e.update(h, {
                userEvent: "indent"
            })), !0
        }
    }, {
        key: "Shift-Mod-k",
        run: e => {
            if (e.state.readOnly) return !1;
            let {
                state: t
            } = e, n = t.changes(selectedLineBlocks(t).map((({
                from: e,
                to: n
            }) => (e > 0 ? e-- : n < t.doc.length && n++, {
                from: e,
                to: n
            })))), o = updateSel(t.selection, (t => {
                let n;
                if (e.lineWrapping) {
                    let o = e.lineBlockAt(t.head),
                        h = e.coordsAtPos(t.head, t.assoc || 1);
                    h && (n = o.bottom + e.documentTop - h.bottom + e.defaultLineHeight / 2)
                }
                return e.moveVertically(t, !0, n)
            })).map(n);
            return e.dispatch({
                changes: n,
                selection: o,
                scrollIntoView: !0,
                userEvent: "delete.line"
            }), !0
        }
    }, {
        key: "Shift-Mod-\\",
        run: ({
            state: e,
            dispatch: t
        }) => function(e, t) {
            let n = !1,
                o = updateSel(e.selection, (t => {
                    let o = matchBrackets(e, t.head, -1) || matchBrackets(e, t.head, 1) || t.head > 0 && matchBrackets(e, t.head - 1, 1) || t.head < e.doc.length && matchBrackets(e, t.head + 1, -1);
                    if (!o || !o.end) return t;
                    n = !0;
                    let h = o.start.from == t.head ? o.end.to : o.end.from;
                    return EditorSelection.cursor(h)
                }));
            return !!n && (t(setSel(e, o)), !0)
        }(e, t)
    }, {
        key: "Mod-/",
        run: e => {
            let {
                state: t
            } = e, n = t.doc.lineAt(t.selection.main.from), o = getConfig(e.state, n.from);
            return o.line ? Fi(e) : !!o.block && Hi(e)
        }
    }, {
        key: "Alt-A",
        run: Gi
    }, {
        key: "Ctrl-m",
        mac: "Shift-Alt-m",
        run: e => (e.setTabFocusMode(), !0)
    }].concat([{
        key: "ArrowLeft",
        run: cursorCharLeft,
        shift: selectCharLeft,
        preventDefault: !0
    }, {
        key: "Mod-ArrowLeft",
        mac: "Alt-ArrowLeft",
        run: e => cursorByGroup(e, !ltrAtCursor(e)),
        shift: e => selectByGroup(e, !ltrAtCursor(e)),
        preventDefault: !0
    }, {
        mac: "Cmd-ArrowLeft",
        run: e => moveSel(e, (t => moveByLineBoundary(e, t, !ltrAtCursor(e)))),
        shift: e => extendSel(e, (t => moveByLineBoundary(e, t, !ltrAtCursor(e)))),
        preventDefault: !0
    }, {
        key: "ArrowRight",
        run: cursorCharRight,
        shift: selectCharRight,
        preventDefault: !0
    }, {
        key: "Mod-ArrowRight",
        mac: "Alt-ArrowRight",
        run: e => cursorByGroup(e, ltrAtCursor(e)),
        shift: e => selectByGroup(e, ltrAtCursor(e)),
        preventDefault: !0
    }, {
        mac: "Cmd-ArrowRight",
        run: e => moveSel(e, (t => moveByLineBoundary(e, t, ltrAtCursor(e)))),
        shift: e => extendSel(e, (t => moveByLineBoundary(e, t, ltrAtCursor(e)))),
        preventDefault: !0
    }, {
        key: "ArrowUp",
        run: cursorLineUp,
        shift: selectLineUp,
        preventDefault: !0
    }, {
        mac: "Cmd-ArrowUp",
        run: cursorDocStart,
        shift: selectDocStart
    }, {
        mac: "Ctrl-ArrowUp",
        run: cursorPageUp,
        shift: selectPageUp
    }, {
        key: "ArrowDown",
        run: cursorLineDown,
        shift: selectLineDown,
        preventDefault: !0
    }, {
        mac: "Cmd-ArrowDown",
        run: cursorDocEnd,
        shift: selectDocEnd
    }, {
        mac: "Ctrl-ArrowDown",
        run: cursorPageDown,
        shift: selectPageDown
    }, {
        key: "PageUp",
        run: cursorPageUp,
        shift: selectPageUp
    }, {
        key: "PageDown",
        run: cursorPageDown,
        shift: selectPageDown
    }, {
        key: "Home",
        run: e => moveSel(e, (t => moveByLineBoundary(e, t, !1))),
        shift: e => extendSel(e, (t => moveByLineBoundary(e, t, !1))),
        preventDefault: !0
    }, {
        key: "Mod-Home",
        run: cursorDocStart,
        shift: selectDocStart
    }, {
        key: "End",
        run: e => moveSel(e, (t => moveByLineBoundary(e, t, !0))),
        shift: e => extendSel(e, (t => moveByLineBoundary(e, t, !0))),
        preventDefault: !0
    }, {
        key: "Mod-End",
        run: cursorDocEnd,
        shift: selectDocEnd
    }, {
        key: "Enter",
        run: ur,
        shift: ur
    }, {
        key: "Mod-a",
        run: ({
            state: e,
            dispatch: t
        }) => (t(e.update({
            selection: {
                anchor: 0,
                head: e.doc.length
            },
            userEvent: "select"
        })), !0)
    }, {
        key: "Backspace",
        run: deleteCharBackward,
        shift: deleteCharBackward
    }, {
        key: "Delete",
        run: deleteCharForward
    }, {
        key: "Mod-Backspace",
        mac: "Alt-Backspace",
        run: deleteGroupBackward
    }, {
        key: "Mod-Delete",
        mac: "Alt-Delete",
        run: e => deleteByGroup(e, !0)
    }, {
        mac: "Mod-Backspace",
        run: e => deleteBy(e, (t => {
            let n = e.moveToLineBoundary(t, !1).head;
            return t.head > n ? n : Math.max(0, t.head - 1)
        }))
    }, {
        mac: "Mod-Delete",
        run: e => deleteBy(e, (t => {
            let n = e.moveToLineBoundary(t, !0).head;
            return t.head < n ? n : Math.min(e.state.doc.length, t.head + 1)
        }))
    }].concat(pr.map((e => ({
        mac: e.key,
        run: e.run,
        shift: e.shift
    }))))),
    gr = {
        key: "Tab",
        run: indentMore,
        shift: indentLess
    };
class CompletionContext {
    constructor(e, t, n, o) {
        this.state = e, this.pos = t, this.explicit = n, this.view = o, this.abortListeners = [], this.abortOnDocChange = !1
    }
    tokenBefore(e) {
        let t = syntaxTree(this.state).resolveInner(this.pos, -1);
        for (; t && e.indexOf(t.name) < 0;) t = t.parent;
        return t ? {
            from: t.from,
            to: this.pos,
            text: this.state.sliceDoc(t.from, this.pos),
            type: t.type
        } : null
    }
    matchBefore(e) {
        let t = this.state.doc.lineAt(this.pos),
            n = Math.max(t.from, this.pos - 250),
            o = t.text.slice(n - t.from, this.pos - t.from),
            h = o.search(ensureAnchor(e, !1));
        return h < 0 ? null : {
            from: n + h,
            to: this.pos,
            text: o.slice(h)
        }
    }
    get aborted() {
        return null == this.abortListeners
    }
    addEventListener(e, t, n) {
        "abort" == e && this.abortListeners && (this.abortListeners.push(t), n && n.onDocChange && (this.abortOnDocChange = !0))
    }
}

function toSet(e) {
    let t = Object.keys(e).join(""),
        n = /\w/.test(t);
    return n && (t = t.replace(/\w/g, "")), `[${n?"\\w":""}${t.replace(/[^\w\s]/g,"\\$&")}]`
}

function completeFromList(e) {
    let t = e.map((e => "string" == typeof e ? {
            label: e
        } : e)),
        [n, o] = t.every((e => /^\w+$/.test(e.label))) ? [/\w*$/, /\w+$/] : function(e) {
            let t = Object.create(null),
                n = Object.create(null);
            for (let {
                    label: o
                } of e) {
                t[o[0]] = !0;
                for (let e = 1; e < o.length; e++) n[o[e]] = !0
            }
            let o = toSet(t) + toSet(n) + "*$";
            return [new RegExp("^" + o), new RegExp(o)]
        }(t);
    return e => {
        let h = e.matchBefore(o);
        return h || e.explicit ? {
            from: h ? h.from : e.pos,
            options: t,
            validFor: n
        } : null
    }
}
class Option {
    constructor(e, t, n, o) {
        this.completion = e, this.source = t, this.match = n, this.score = o
    }
}

function cur(e) {
    return e.selection.main.from
}

function ensureAnchor(e, t) {
    var n;
    let {
        source: o
    } = e, h = t && "^" != o[0], p = "$" != o[o.length - 1];
    return h || p ? new RegExp(`${h?"^":""}(?:${o})${p?"$":""}`, null !== (n = e.flags) && void 0 !== n ? n : e.ignoreCase ? "i" : "") : e
}
const mr = Annotation.define();
const Or = new WeakMap;

function asSource(e) {
    if (!Array.isArray(e)) return e;
    let t = Or.get(e);
    return t || Or.set(e, t = completeFromList(e)), t
}
const yr = StateEffect.define(),
    wr = StateEffect.define();
class FuzzyMatcher {
    constructor(e) {
        this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
        for (let t = 0; t < e.length;) {
            let n = codePointAt(e, t),
                o = codePointSize(n);
            this.chars.push(n);
            let h = e.slice(t, t + o),
                p = h.toUpperCase();
            this.folded.push(codePointAt(p == h ? h.toLowerCase() : p, 0)), t += o
        }
        this.astral = e.length != this.chars.length
    }
    ret(e, t) {
        return this.score = e, this.matched = t, this
    }
    match(e) {
        if (0 == this.pattern.length) return this.ret(-100, []);
        if (e.length < this.pattern.length) return null;
        let {
            chars: t,
            folded: n,
            any: o,
            precise: h,
            byWord: p
        } = this;
        if (1 == t.length) {
            let o = codePointAt(e, 0),
                h = codePointSize(o),
                p = h == e.length ? 0 : -100;
            if (o == t[0]);
            else {
                if (o != n[0]) return null;
                p += -200
            }
            return this.ret(p, [0, h])
        }
        let f = e.indexOf(this.pattern);
        if (0 == f) return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
        let g = t.length,
            y = 0;
        if (f < 0) {
            for (let h = 0, p = Math.min(e.length, 200); h < p && y < g;) {
                let p = codePointAt(e, h);
                p != t[y] && p != n[y] || (o[y++] = h), h += codePointSize(p)
            }
            if (y < g) return null
        }
        let w = 0,
            b = 0,
            S = !1,
            k = 0,
            v = -1,
            P = -1,
            C = /[a-z]/.test(e),
            Q = !0;
        for (let o = 0, y = Math.min(e.length, 200), $ = 0; o < y && b < g;) {
            let y = codePointAt(e, o);
            f < 0 && (w < g && y == t[w] && (h[w++] = o), k < g && (y == t[k] || y == n[k] ? (0 == k && (v = o), P = o + 1, k++) : k = 0));
            let A, M = y < 255 ? y >= 48 && y <= 57 || y >= 97 && y <= 122 ? 2 : y >= 65 && y <= 90 ? 1 : 0 : (A = fromCodePoint(y)) != A.toLowerCase() ? 1 : A != A.toUpperCase() ? 2 : 0;
            (!o || 1 == M && C || 0 == $ && 0 != M) && (t[b] == y || n[b] == y && (S = !0) ? p[b++] = o : p.length && (Q = !1)), $ = M, o += codePointSize(y)
        }
        return b == g && 0 == p[0] && Q ? this.result((S ? -200 : 0) - 100, p, e) : k == g && 0 == v ? this.ret(-200 - e.length + (P == e.length ? 0 : -100), [0, P]) : f > -1 ? this.ret(-700 - e.length, [f, f + this.pattern.length]) : k == g ? this.ret(-900 - e.length, [v, P]) : b == g ? this.result((S ? -200 : 0) - 100 - 700 + (Q ? 0 : -1100), p, e) : 2 == t.length ? null : this.result((o[0] ? -700 : 0) - 200 - 1100, o, e)
    }
    result(e, t, n) {
        let o = [],
            h = 0;
        for (let e of t) {
            let t = e + (this.astral ? codePointSize(codePointAt(n, e)) : 1);
            h && o[h - 1] == e ? o[h - 1] = t : (o[h++] = e, o[h++] = t)
        }
        return this.ret(e - n.length, o)
    }
}
class StrictMatcher {
    constructor(e) {
        this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase()
    }
    match(e) {
        if (e.length < this.pattern.length) return null;
        let t = e.slice(0, this.pattern.length),
            n = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null;
        return null == n ? null : (this.matched = [0, t.length], this.score = n + (e.length == this.pattern.length ? 0 : -100), this)
    }
}
const br = Facet.define({
    combine: e => combineConfig(e, {
        activateOnTyping: !0,
        activateOnCompletion: () => !1,
        activateOnTypingDelay: 100,
        selectOnOpen: !0,
        override: null,
        closeOnBlur: !0,
        maxRenderedOptions: 100,
        defaultKeymap: !0,
        tooltipClass: () => "",
        optionClass: () => "",
        aboveCursor: !1,
        icons: !0,
        addToOptions: [],
        positionInfo: defaultPositionInfo,
        filterStrict: !1,
        compareCompletions: (e, t) => e.label.localeCompare(t.label),
        interactionDelay: 75,
        updateSyncTime: 100
    }, {
        defaultKeymap: (e, t) => e && t,
        closeOnBlur: (e, t) => e && t,
        icons: (e, t) => e && t,
        tooltipClass: (e, t) => n => joinClass(e(n), t(n)),
        optionClass: (e, t) => n => joinClass(e(n), t(n)),
        addToOptions: (e, t) => e.concat(t),
        filterStrict: (e, t) => e || t
    })
});

function joinClass(e, t) {
    return e ? t ? e + " " + t : e : t
}

function defaultPositionInfo(e, t, n, o, h, p) {
    let f, g, y = e.textDirection == pe.RTL,
        w = y,
        b = !1,
        S = "top",
        k = t.left - h.left,
        v = h.right - t.right,
        P = o.right - o.left,
        C = o.bottom - o.top;
    if (w && k < Math.min(P, v) ? w = !1 : !w && v < Math.min(P, k) && (w = !0), P <= (w ? k : v)) f = Math.max(h.top, Math.min(n.top, h.bottom - C)) - t.top, g = Math.min(400, w ? k : v);
    else {
        b = !0, g = Math.min(400, (y ? t.right : h.right - t.left) - 30);
        let e = h.bottom - t.bottom;
        e >= C || e > t.top ? f = n.bottom - t.top : (S = "bottom", f = t.bottom - n.top)
    }
    return {
        style: `${S}: ${f/((t.bottom-t.top)/p.offsetHeight)}px; max-width: ${g/((t.right-t.left)/p.offsetWidth)}px`,
        class: "cm-completionInfo-" + (b ? y ? "left-narrow" : "right-narrow" : w ? "left" : "right")
    }
}

function rangeAroundSelected(e, t, n) {
    if (e <= n) return {
        from: 0,
        to: e
    };
    if (t < 0 && (t = 0), t <= e >> 1) {
        let e = Math.floor(t / n);
        return {
            from: e * n,
            to: (e + 1) * n
        }
    }
    let o = Math.floor((e - t) / n);
    return {
        from: e - (o + 1) * n,
        to: e - o * n
    }
}
class CompletionTooltip {
    constructor(e, t, n) {
        this.view = e, this.stateField = t, this.applyCompletion = n, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
            read: () => this.measureInfo(),
            write: e => this.placeInfo(e),
            key: this
        }, this.space = null, this.currentClass = "";
        let o = e.state.field(t),
            {
                options: h,
                selected: p
            } = o.open,
            f = e.state.facet(br);
        this.optionContent = function(e) {
            let t = e.addToOptions.slice();
            return e.icons && t.push({
                render(e) {
                    let t = document.createElement("div");
                    return t.classList.add("cm-completionIcon"), e.type && t.classList.add(...e.type.split(/\s+/g).map((e => "cm-completionIcon-" + e))), t.setAttribute("aria-hidden", "true"), t
                },
                position: 20
            }), t.push({
                render(e, t, n, o) {
                    let h = document.createElement("span");
                    h.className = "cm-completionLabel";
                    let p = e.displayLabel || e.label,
                        f = 0;
                    for (let e = 0; e < o.length;) {
                        let t = o[e++],
                            n = o[e++];
                        t > f && h.appendChild(document.createTextNode(p.slice(f, t)));
                        let g = h.appendChild(document.createElement("span"));
                        g.appendChild(document.createTextNode(p.slice(t, n))), g.className = "cm-completionMatchedText", f = n
                    }
                    return f < p.length && h.appendChild(document.createTextNode(p.slice(f))), h
                },
                position: 50
            }, {
                render(e) {
                    if (!e.detail) return null;
                    let t = document.createElement("span");
                    return t.className = "cm-completionDetail", t.textContent = e.detail, t
                },
                position: 80
            }), t.sort(((e, t) => e.position - t.position)).map((e => e.render))
        }(f), this.optionClass = f.optionClass, this.tooltipClass = f.tooltipClass, this.range = rangeAroundSelected(h.length, p, f.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (n => {
            let {
                options: o
            } = e.state.field(t).open;
            for (let t, h = n.target; h && h != this.dom; h = h.parentNode)
                if ("LI" == h.nodeName && (t = /-(\d+)$/.exec(h.id)) && +t[1] < o.length) return this.applyCompletion(e, o[+t[1]]), void n.preventDefault()
        })), this.dom.addEventListener("focusout", (t => {
            let n = e.state.field(this.stateField, !1);
            n && n.tooltip && e.state.facet(br).closeOnBlur && t.relatedTarget != e.contentDOM && e.dispatch({
                effects: wr.of(null)
            })
        })), this.showOptions(h, o.id)
    }
    mount() {
        this.updateSel()
    }
    showOptions(e, t) {
        this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", (() => {
            this.info && this.view.requestMeasure(this.placeInfoReq)
        }))
    }
    update(e) {
        var t;
        let n = e.state.field(this.stateField),
            o = e.startState.field(this.stateField);
        if (this.updateTooltipClass(e.state), n != o) {
            let {
                options: h,
                selected: p,
                disabled: f
            } = n.open;
            o.open && o.open.options == h || (this.range = rangeAroundSelected(h.length, p, e.state.facet(br).maxRenderedOptions), this.showOptions(h, n.id)), this.updateSel(), f != (null === (t = o.open) || void 0 === t ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!f)
        }
    }
    updateTooltipClass(e) {
        let t = this.tooltipClass(e);
        if (t != this.currentClass) {
            for (let e of this.currentClass.split(" ")) e && this.dom.classList.remove(e);
            for (let e of t.split(" ")) e && this.dom.classList.add(e);
            this.currentClass = t
        }
    }
    positioned(e) {
        this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq)
    }
    updateSel() {
        let e = this.view.state.field(this.stateField),
            t = e.open;
        if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = rangeAroundSelected(t.options.length, t.selected, this.view.state.facet(br).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
            this.destroyInfo();
            let {
                completion: n
            } = t.options[t.selected], {
                info: o
            } = n;
            if (!o) return;
            let h = "string" == typeof o ? document.createTextNode(o) : o(n);
            if (!h) return;
            "then" in h ? h.then((t => {
                t && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(t, n)
            })).catch((e => logException(this.view.state, e, "completion info"))) : this.addInfoPane(h, n)
        }
    }
    addInfoPane(e, t) {
        this.destroyInfo();
        let n = this.info = document.createElement("div");
        if (n.className = "cm-tooltip cm-completionInfo", null != e.nodeType) n.appendChild(e), this.infoDestroy = null;
        else {
            let {
                dom: t,
                destroy: o
            } = e;
            n.appendChild(t), this.infoDestroy = o || null
        }
        this.dom.appendChild(n), this.view.requestMeasure(this.placeInfoReq)
    }
    updateSelectedOption(e) {
        let t = null;
        for (let n = this.list.firstChild, o = this.range.from; n; n = n.nextSibling, o++) "LI" == n.nodeName && n.id ? o == e ? n.hasAttribute("aria-selected") || (n.setAttribute("aria-selected", "true"), t = n) : n.hasAttribute("aria-selected") && n.removeAttribute("aria-selected") : o--;
        return t && function(e, t) {
            let n = e.getBoundingClientRect(),
                o = t.getBoundingClientRect(),
                h = n.height / e.offsetHeight;
            o.top < n.top ? e.scrollTop -= (n.top - o.top) / h : o.bottom > n.bottom && (e.scrollTop += (o.bottom - n.bottom) / h)
        }(this.list, t), t
    }
    measureInfo() {
        let e = this.dom.querySelector("[aria-selected]");
        if (!e || !this.info) return null;
        let t = this.dom.getBoundingClientRect(),
            n = this.info.getBoundingClientRect(),
            o = e.getBoundingClientRect(),
            h = this.space;
        if (!h) {
            let e = this.dom.ownerDocument.defaultView || window;
            h = {
                left: 0,
                top: 0,
                right: e.innerWidth,
                bottom: e.innerHeight
            }
        }
        return o.top > Math.min(h.bottom, t.bottom) - 10 || o.bottom < Math.max(h.top, t.top) + 10 ? null : this.view.state.facet(br).positionInfo(this.view, t, o, n, h, this.dom)
    }
    placeInfo(e) {
        this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px")
    }
    createListBox(e, t, n) {
        const o = document.createElement("ul");
        o.id = t, o.setAttribute("role", "listbox"), o.setAttribute("aria-expanded", "true"), o.setAttribute("aria-label", this.view.state.phrase("Completions"));
        let h = null;
        for (let p = n.from; p < n.to; p++) {
            let {
                completion: f,
                match: g
            } = e[p], {
                section: y
            } = f;
            if (y) {
                let e = "string" == typeof y ? y : y.name;
                if (e != h && (p > n.from || 0 == n.from))
                    if (h = e, "string" != typeof y && y.header) o.appendChild(y.header(y));
                    else {
                        o.appendChild(document.createElement("completion-section")).textContent = e
                    }
            }
            const w = o.appendChild(document.createElement("li"));
            w.id = t + "-" + p, w.setAttribute("role", "option");
            let b = this.optionClass(f);
            b && (w.className = b);
            for (let e of this.optionContent) {
                let t = e(f, this.view.state, this.view, g);
                t && w.appendChild(t)
            }
        }
        return n.from && o.classList.add("cm-completionListIncompleteTop"), n.to < e.length && o.classList.add("cm-completionListIncompleteBottom"), o
    }
    destroyInfo() {
        this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null)
    }
    destroy() {
        this.destroyInfo()
    }
}

function completionTooltip(e, t) {
    return n => new CompletionTooltip(n, e, t)
}

function score(e) {
    return 100 * (e.boost || 0) + (e.apply ? 10 : 0) + (e.info ? 5 : 0) + (e.type ? 1 : 0)
}
class CompletionDialog {
    constructor(e, t, n, o, h, p) {
        this.options = e, this.attrs = t, this.tooltip = n, this.timestamp = o, this.selected = h, this.disabled = p
    }
    setSelected(e, t) {
        return e == this.selected || e >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(t, e), this.tooltip, this.timestamp, e, this.disabled)
    }
    static build(e, t, n, o, h, p) {
        if (o && !p && e.some((e => e.isPending))) return o.setDisabled();
        let f = function(e, t) {
            let n = [],
                o = null,
                addOption = e => {
                    n.push(e);
                    let {
                        section: t
                    } = e.completion;
                    if (t) {
                        o || (o = []);
                        let e = "string" == typeof t ? t : t.name;
                        o.some((t => t.name == e)) || o.push("string" == typeof t ? {
                            name: e
                        } : t)
                    }
                },
                h = t.facet(br);
            for (let o of e)
                if (o.hasResult()) {
                    let e = o.result.getMatch;
                    if (!1 === o.result.filter)
                        for (let t of o.result.options) addOption(new Option(t, o.source, e ? e(t) : [], 1e9 - n.length));
                    else {
                        let n, p = t.sliceDoc(o.from, o.to),
                            f = h.filterStrict ? new StrictMatcher(p) : new FuzzyMatcher(p);
                        for (let t of o.result.options)
                            if (n = f.match(t.label)) {
                                let h = t.displayLabel ? e ? e(t, n.matched) : [] : n.matched;
                                addOption(new Option(t, o.source, h, n.score + (t.boost || 0)))
                            }
                    }
                }
            if (o) {
                let e = Object.create(null),
                    t = 0,
                    cmp = (e, t) => {
                        var n, o;
                        return (null !== (n = e.rank) && void 0 !== n ? n : 1e9) - (null !== (o = t.rank) && void 0 !== o ? o : 1e9) || (e.name < t.name ? -1 : 1)
                    };
                for (let n of o.sort(cmp)) t -= 1e5, e[n.name] = t;
                for (let t of n) {
                    let {
                        section: n
                    } = t.completion;
                    n && (t.score += e["string" == typeof n ? n : n.name])
                }
            }
            let p = [],
                f = null,
                g = h.compareCompletions;
            for (let e of n.sort(((e, t) => t.score - e.score || g(e.completion, t.completion)))) {
                let t = e.completion;
                !f || f.label != t.label || f.detail != t.detail || null != f.type && null != t.type && f.type != t.type || f.apply != t.apply || f.boost != t.boost ? p.push(e) : score(e.completion) > score(f) && (p[p.length - 1] = e), f = e.completion
            }
            return p
        }(e, t);
        if (!f.length) return o && e.some((e => e.isPending)) ? o.setDisabled() : null;
        let g = t.facet(br).selectOnOpen ? 0 : -1;
        if (o && o.selected != g && -1 != o.selected) {
            let e = o.options[o.selected].completion;
            for (let t = 0; t < f.length; t++)
                if (f[t].completion == e) {
                    g = t;
                    break
                }
        }
        return new CompletionDialog(f, makeAttrs(n, g), {
            pos: e.reduce(((e, t) => t.hasResult() ? Math.min(e, t.from) : e), 1e8),
            create: Qr,
            above: h.aboveCursor
        }, o ? o.timestamp : Date.now(), g, !1)
    }
    map(e) {
        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {
            pos: e.mapPos(this.tooltip.pos)
        }), this.timestamp, this.selected, this.disabled)
    }
    setDisabled() {
        return new CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0)
    }
}
class CompletionState {
    constructor(e, t, n) {
        this.active = e, this.id = t, this.open = n
    }
    static start() {
        return new CompletionState(kr, "cm-ac-" + Math.floor(2e6 * Math.random()).toString(36), null)
    }
    update(e) {
        let {
            state: t
        } = e, n = t.facet(br), o = (n.override || t.languageDataAt("autocomplete", cur(t)).map(asSource)).map((t => (this.active.find((e => e.source == t)) || new ActiveSource(t, this.active.some((e => 0 != e.state)) ? 1 : 0)).update(e, n)));
        o.length == this.active.length && o.every(((e, t) => e == this.active[t])) && (o = this.active);
        let h = this.open,
            p = e.effects.some((e => e.is(vr)));
        h && e.docChanged && (h = h.map(e.changes)), e.selection || o.some((t => t.hasResult() && e.changes.touchesRange(t.from, t.to))) || ! function(e, t) {
            if (e == t) return !0;
            for (let n = 0, o = 0;;) {
                for (; n < e.length && !e[n].hasResult();) n++;
                for (; o < t.length && !t[o].hasResult();) o++;
                let h = n == e.length,
                    p = o == t.length;
                if (h || p) return h == p;
                if (e[n++].result != t[o++].result) return !1
            }
        }(o, this.active) || p ? h = CompletionDialog.build(o, t, this.id, h, n, p) : h && h.disabled && !o.some((e => e.isPending)) && (h = null), !h && o.every((e => !e.isPending)) && o.some((e => e.hasResult())) && (o = o.map((e => e.hasResult() ? new ActiveSource(e.source, 0) : e)));
        for (let t of e.effects) t.is(Pr) && (h = h && h.setSelected(t.value, this.id));
        return o == this.active && h == this.open ? this : new CompletionState(o, this.id, h)
    }
    get tooltip() {
        return this.open ? this.open.tooltip : null
    }
    get attrs() {
        return this.open ? this.open.attrs : this.active.length ? Sr : xr
    }
}
const Sr = {
        "aria-autocomplete": "list"
    },
    xr = {};

function makeAttrs(e, t) {
    let n = {
        "aria-autocomplete": "list",
        "aria-haspopup": "listbox",
        "aria-controls": e
    };
    return t > -1 && (n["aria-activedescendant"] = e + "-" + t), n
}
const kr = [];

function getUpdateType(e, t) {
    if (e.isUserEvent("input.complete")) {
        let n = e.annotation(mr);
        if (n && t.activateOnCompletion(n)) return 12
    }
    let n = e.isUserEvent("input.type");
    return n && t.activateOnTyping ? 5 : n ? 1 : e.isUserEvent("delete.backward") ? 2 : e.selection ? 8 : e.docChanged ? 16 : 0
}
class ActiveSource {
    constructor(e, t, n = !1) {
        this.source = e, this.state = t, this.explicit = n
    }
    hasResult() {
        return !1
    }
    get isPending() {
        return 1 == this.state
    }
    update(e, t) {
        let n = getUpdateType(e, t),
            o = this;
        (8 & n || 16 & n && this.touches(e)) && (o = new ActiveSource(o.source, 0)), 4 & n && 0 == o.state && (o = new ActiveSource(this.source, 1)), o = o.updateFor(e, n);
        for (let t of e.effects)
            if (t.is(yr)) o = new ActiveSource(o.source, 1, t.value);
            else if (t.is(wr)) o = new ActiveSource(o.source, 0);
        else if (t.is(vr))
            for (let e of t.value) e.source == o.source && (o = e);
        return o
    }
    updateFor(e, t) {
        return this.map(e.changes)
    }
    map(e) {
        return this
    }
    touches(e) {
        return e.changes.touchesRange(cur(e.state))
    }
}
class ActiveResult extends ActiveSource {
    constructor(e, t, n, o, h, p) {
        super(e, 3, t), this.limit = n, this.result = o, this.from = h, this.to = p
    }
    hasResult() {
        return !0
    }
    updateFor(e, t) {
        var n;
        if (!(3 & t)) return this.map(e.changes);
        let o = this.result;
        o.map && !e.changes.empty && (o = o.map(o, e.changes));
        let h = e.changes.mapPos(this.from),
            p = e.changes.mapPos(this.to, 1),
            f = cur(e.state);
        if (f > p || !o || 2 & t && (cur(e.startState) == this.from || f < this.limit)) return new ActiveSource(this.source, 4 & t ? 1 : 0);
        let g = e.changes.mapPos(this.limit);
        return function(e, t, n, o) {
            if (!e) return !1;
            let h = t.sliceDoc(n, o);
            return "function" == typeof e ? e(h, n, o, t) : ensureAnchor(e, !0).test(h)
        }(o.validFor, e.state, h, p) ? new ActiveResult(this.source, this.explicit, g, o, h, p) : o.update && (o = o.update(o, h, p, new CompletionContext(e.state, f, !1))) ? new ActiveResult(this.source, this.explicit, g, o, o.from, null !== (n = o.to) && void 0 !== n ? n : cur(e.state)) : new ActiveSource(this.source, 1, this.explicit)
    }
    map(e) {
        if (e.empty) return this;
        return (this.result.map ? this.result.map(this.result, e) : this.result) ? new ActiveResult(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new ActiveSource(this.source, 0)
    }
    touches(e) {
        return e.changes.touchesRange(this.from, this.to)
    }
}
const vr = StateEffect.define({
        map: (e, t) => e.map((e => e.map(t)))
    }),
    Pr = StateEffect.define(),
    Cr = StateField.define({
        create: () => CompletionState.start(),
        update: (e, t) => e.update(t),
        provide: e => [an.from(e, (e => e.tooltip)), EditorView.contentAttributes.from(e, (e => e.attrs))]
    });

function applyCompletion(e, t) {
    const n = t.completion.apply || t.completion.label;
    let o = e.state.field(Cr).active.find((e => e.source == t.source));
    return o instanceof ActiveResult && ("string" == typeof n ? e.dispatch(Object.assign(Object.assign({}, function(e, t, n, o) {
        let {
            main: h
        } = e.selection, p = n - h.from, f = o - h.from;
        return Object.assign(Object.assign({}, e.changeByRange((g => {
            if (g != h && n != o && e.sliceDoc(g.from + p, g.from + f) != e.sliceDoc(n, o)) return {
                range: g
            };
            let y = e.toText(t);
            return {
                changes: {
                    from: g.from + p,
                    to: o == h.from ? g.to : g.from + f,
                    insert: y
                },
                range: EditorSelection.cursor(g.from + p + y.length)
            }
        }))), {
            scrollIntoView: !0,
            userEvent: "input.complete"
        })
    }(e.state, n, o.from, o.to)), {
        annotations: mr.of(t.completion)
    })) : n(e, t.completion, o.from, o.to), !0)
}
const Qr = completionTooltip(Cr, applyCompletion);

function moveCompletionSelection(e, t = "option") {
    return n => {
        let o = n.state.field(Cr, !1);
        if (!o || !o.open || o.open.disabled || Date.now() - o.open.timestamp < n.state.facet(br).interactionDelay) return !1;
        let h, p = 1;
        "page" == t && (h = getTooltip(n, o.open.tooltip)) && (p = Math.max(2, Math.floor(h.dom.offsetHeight / h.dom.querySelector("li").offsetHeight) - 1));
        let {
            length: f
        } = o.open.options, g = o.open.selected > -1 ? o.open.selected + p * (e ? 1 : -1) : e ? 0 : f - 1;
        return g < 0 ? g = "page" == t ? 0 : f - 1 : g >= f && (g = "page" == t ? f - 1 : 0), n.dispatch({
            effects: Pr.of(g)
        }), !0
    }
}
const startCompletion = e => !!e.state.field(Cr, !1) && (e.dispatch({
    effects: yr.of(!0)
}), !0);
class RunningQuery {
    constructor(e, t) {
        this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0
    }
}
const Tr = ViewPlugin.fromClass(class {
        constructor(e) {
            this.view = e, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
            for (let t of e.state.field(Cr).active) t.isPending && this.startQuery(t)
        }
        update(e) {
            let t = e.state.field(Cr),
                n = e.state.facet(br);
            if (!e.selectionSet && !e.docChanged && e.startState.field(Cr) == t) return;
            let o = e.transactions.some((e => {
                let t = getUpdateType(e, n);
                return 8 & t || (e.selection || e.docChanged) && !(3 & t)
            }));
            for (let t = 0; t < this.running.length; t++) {
                let n = this.running[t];
                if (o || n.context.abortOnDocChange && e.docChanged || n.updates.length + e.transactions.length > 50 && Date.now() - n.time > 1e3) {
                    for (let e of n.context.abortListeners) try {
                        e()
                    } catch (e) {
                        logException(this.view.state, e)
                    }
                    n.context.abortListeners = null, this.running.splice(t--, 1)
                } else n.updates.push(...e.transactions)
            }
            this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), e.transactions.some((e => e.effects.some((e => e.is(yr))))) && (this.pendingStart = !0);
            let h = this.pendingStart ? 50 : n.activateOnTypingDelay;
            if (this.debounceUpdate = t.active.some((e => e.isPending && !this.running.some((t => t.active.source == e.source)))) ? setTimeout((() => this.startUpdate()), h) : -1, 0 != this.composing)
                for (let t of e.transactions) t.isUserEvent("input.type") ? this.composing = 2 : 2 == this.composing && t.selection && (this.composing = 3)
        }
        startUpdate() {
            this.debounceUpdate = -1, this.pendingStart = !1;
            let {
                state: e
            } = this.view, t = e.field(Cr);
            for (let e of t.active) e.isPending && !this.running.some((t => t.active.source == e.source)) && this.startQuery(e);
            this.running.length && t.open && t.open.disabled && (this.debounceAccept = setTimeout((() => this.accept()), this.view.state.facet(br).updateSyncTime))
        }
        startQuery(e) {
            let {
                state: t
            } = this.view, n = cur(t), o = new CompletionContext(t, n, e.explicit, this.view), h = new RunningQuery(e, o);
            this.running.push(h), Promise.resolve(e.source(o)).then((e => {
                h.context.aborted || (h.done = e || null, this.scheduleAccept())
            }), (e => {
                this.view.dispatch({
                    effects: wr.of(null)
                }), logException(this.view.state, e)
            }))
        }
        scheduleAccept() {
            this.running.every((e => void 0 !== e.done)) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout((() => this.accept()), this.view.state.facet(br).updateSyncTime))
        }
        accept() {
            var e;
            this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
            let t = [],
                n = this.view.state.facet(br),
                o = this.view.state.field(Cr);
            for (let h = 0; h < this.running.length; h++) {
                let p = this.running[h];
                if (void 0 === p.done) continue;
                if (this.running.splice(h--, 1), p.done) {
                    let o = cur(p.updates.length ? p.updates[0].startState : this.view.state),
                        h = Math.min(o, p.done.from + (p.active.explicit ? 0 : 1)),
                        f = new ActiveResult(p.active.source, p.active.explicit, h, p.done, p.done.from, null !== (e = p.done.to) && void 0 !== e ? e : o);
                    for (let e of p.updates) f = f.update(e, n);
                    if (f.hasResult()) {
                        t.push(f);
                        continue
                    }
                }
                let f = o.active.find((e => e.source == p.active.source));
                if (f && f.isPending)
                    if (null == p.done) {
                        let e = new ActiveSource(p.active.source, 0);
                        for (let t of p.updates) e = e.update(t, n);
                        e.isPending || t.push(e)
                    } else this.startQuery(f)
            }(t.length || o.open && o.open.disabled) && this.view.dispatch({
                effects: vr.of(t)
            })
        }
    }, {
        eventHandlers: {
            blur(e) {
                let t = this.view.state.field(Cr, !1);
                if (t && t.tooltip && this.view.state.facet(br).closeOnBlur) {
                    let n = t.open && getTooltip(this.view, t.open.tooltip);
                    n && n.dom.contains(e.relatedTarget) || setTimeout((() => this.view.dispatch({
                        effects: wr.of(null)
                    })), 10)
                }
            },
            compositionstart() {
                this.composing = 1
            },
            compositionend() {
                3 == this.composing && setTimeout((() => this.view.dispatch({
                    effects: yr.of(!1)
                })), 20), this.composing = 0
            }
        }
    }),
    $r = "object" == typeof navigator && /Win/.test(navigator.platform),
    Er = b.highest(EditorView.domEventHandlers({
        keydown(e, t) {
            let n = t.state.field(Cr, !1);
            if (!n || !n.open || n.open.disabled || n.open.selected < 0 || e.key.length > 1 || e.ctrlKey && (!$r || !e.altKey) || e.metaKey) return !1;
            let o = n.open.options[n.open.selected],
                h = n.active.find((e => e.source == o.source)),
                p = o.completion.commitCharacters || h.result.commitCharacters;
            return p && p.indexOf(e.key) > -1 && applyCompletion(t, o), !1
        }
    })),
    Ar = EditorView.baseTheme({
        ".cm-tooltip.cm-tooltip-autocomplete": {
            "& > ul": {
                fontFamily: "monospace",
                whiteSpace: "nowrap",
                overflow: "hidden auto",
                maxWidth_fallback: "700px",
                maxWidth: "min(700px, 95vw)",
                minWidth: "250px",
                maxHeight: "10em",
                height: "100%",
                listStyle: "none",
                margin: 0,
                padding: 0,
                "& > li, & > completion-section": {
                    padding: "1px 3px",
                    lineHeight: 1.2
                },
                "& > li": {
                    overflowX: "hidden",
                    textOverflow: "ellipsis",
                    cursor: "pointer"
                },
                "& > completion-section": {
                    display: "list-item",
                    borderBottom: "1px solid silver",
                    paddingLeft: "0.5em",
                    opacity: .7
                }
            }
        },
        "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
            background: "#17c",
            color: "white"
        },
        "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
            background: "#777"
        },
        "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
            background: "#347",
            color: "white"
        },
        "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
            background: "#444"
        },
        ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
            content: '"Â·Â·Â·"',
            opacity: .5,
            display: "block",
            textAlign: "center"
        },
        ".cm-tooltip.cm-completionInfo": {
            position: "absolute",
            padding: "3px 9px",
            width: "max-content",
            maxWidth: "400px",
            boxSizing: "border-box",
            whiteSpace: "pre-line"
        },
        ".cm-completionInfo.cm-completionInfo-left": {
            right: "100%"
        },
        ".cm-completionInfo.cm-completionInfo-right": {
            left: "100%"
        },
        ".cm-completionInfo.cm-completionInfo-left-narrow": {
            right: "30px"
        },
        ".cm-completionInfo.cm-completionInfo-right-narrow": {
            left: "30px"
        },
        "&light .cm-snippetField": {
            backgroundColor: "#00000022"
        },
        "&dark .cm-snippetField": {
            backgroundColor: "#ffffff22"
        },
        ".cm-snippetFieldPosition": {
            verticalAlign: "text-top",
            width: 0,
            height: "1.15em",
            display: "inline-block",
            margin: "0 -0.7px -.7em",
            borderLeft: "1.4px dotted #888"
        },
        ".cm-completionMatchedText": {
            textDecoration: "underline"
        },
        ".cm-completionDetail": {
            marginLeft: "0.5em",
            fontStyle: "italic"
        },
        ".cm-completionIcon": {
            fontSize: "90%",
            width: ".8em",
            display: "inline-block",
            textAlign: "center",
            paddingRight: ".6em",
            opacity: "0.6",
            boxSizing: "content-box"
        },
        ".cm-completionIcon-function, .cm-completionIcon-method": {
            "&:after": {
                content: "'Æ’'"
            }
        },
        ".cm-completionIcon-class": {
            "&:after": {
                content: "'â—‹'"
            }
        },
        ".cm-completionIcon-interface": {
            "&:after": {
                content: "'â—Œ'"
            }
        },
        ".cm-completionIcon-variable": {
            "&:after": {
                content: "'ð‘¥'"
            }
        },
        ".cm-completionIcon-constant": {
            "&:after": {
                content: "'ð¶'"
            }
        },
        ".cm-completionIcon-type": {
            "&:after": {
                content: "'ð‘¡'"
            }
        },
        ".cm-completionIcon-enum": {
            "&:after": {
                content: "'âˆª'"
            }
        },
        ".cm-completionIcon-property": {
            "&:after": {
                content: "'â–¡'"
            }
        },
        ".cm-completionIcon-keyword": {
            "&:after": {
                content: "'ðŸ”‘ï¸Ž'"
            }
        },
        ".cm-completionIcon-namespace": {
            "&:after": {
                content: "'â–¢'"
            }
        },
        ".cm-completionIcon-text": {
            "&:after": {
                content: "'abc'",
                fontSize: "50%",
                verticalAlign: "middle"
            }
        }
    });
class FieldPos {
    constructor(e, t, n, o) {
        this.field = e, this.line = t, this.from = n, this.to = o
    }
}
class FieldRange {
    constructor(e, t, n) {
        this.field = e, this.from = t, this.to = n
    }
    map(e) {
        let t = e.mapPos(this.from, -1, o.TrackDel),
            n = e.mapPos(this.to, 1, o.TrackDel);
        return null == t || null == n ? null : new FieldRange(this.field, t, n)
    }
}
class Snippet {
    constructor(e, t) {
        this.lines = e, this.fieldPositions = t
    }
    instantiate(e, t) {
        let n = [],
            o = [t],
            h = e.doc.lineAt(t),
            p = /^\s*/.exec(h.text)[0];
        for (let h of this.lines) {
            if (n.length) {
                let n = p,
                    f = /^\t*/.exec(h)[0].length;
                for (let t = 0; t < f; t++) n += e.facet(mi);
                o.push(t + n.length - f), h = n + h.slice(f)
            }
            n.push(h), t += h.length + 1
        }
        let f = this.fieldPositions.map((e => new FieldRange(e.field, o[e.line] + e.from, o[e.line] + e.to)));
        return {
            text: n,
            ranges: f
        }
    }
    static parse(e) {
        let t, n = [],
            o = [],
            h = [];
        for (let p of e.split(/\r\n?|\n/)) {
            for (; t = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(p);) {
                let e = t[1] ? +t[1] : null,
                    f = t[2] || t[3] || "",
                    g = -1,
                    y = f.replace(/\\[{}]/g, (e => e[1]));
                for (let t = 0; t < n.length; t++)(null != e ? n[t].seq == e : y && n[t].name == y) && (g = t);
                if (g < 0) {
                    let t = 0;
                    for (; t < n.length && (null == e || null != n[t].seq && n[t].seq < e);) t++;
                    n.splice(t, 0, {
                        seq: e,
                        name: y
                    }), g = t;
                    for (let e of h) e.field >= g && e.field++
                }
                h.push(new FieldPos(g, o.length, t.index, t.index + y.length)), p = p.slice(0, t.index) + f + p.slice(t.index + t[0].length)
            }
            p = p.replace(/\\([{}])/g, ((e, t, n) => {
                for (let e of h) e.line == o.length && e.from > n && (e.from--, e.to--);
                return t
            })), o.push(p)
        }
        return new Snippet(o, h)
    }
}
let Mr = Decoration.widget({
        widget: new class extends WidgetType {
            toDOM() {
                let e = document.createElement("span");
                return e.className = "cm-snippetFieldPosition", e
            }
            ignoreEvent() {
                return !1
            }
        }
    }),
    Rr = Decoration.mark({
        class: "cm-snippetField"
    });
class ActiveSnippet {
    constructor(e, t) {
        this.ranges = e, this.active = t, this.deco = Decoration.set(e.map((e => (e.from == e.to ? Mr : Rr).range(e.from, e.to))))
    }
    map(e) {
        let t = [];
        for (let n of this.ranges) {
            let o = n.map(e);
            if (!o) return null;
            t.push(o)
        }
        return new ActiveSnippet(t, this.active)
    }
    selectionInsideField(e) {
        return e.ranges.every((e => this.ranges.some((t => t.field == this.active && t.from <= e.from && t.to >= e.to))))
    }
}
const Dr = StateEffect.define({
        map: (e, t) => e && e.map(t)
    }),
    Lr = StateEffect.define(),
    Vr = StateField.define({
        create: () => null,
        update(e, t) {
            for (let n of t.effects) {
                if (n.is(Dr)) return n.value;
                if (n.is(Lr) && e) return new ActiveSnippet(e.ranges, n.value)
            }
            return e && t.docChanged && (e = e.map(t.changes)), e && t.selection && !e.selectionInsideField(t.selection) && (e = null), e
        },
        provide: e => EditorView.decorations.from(e, (e => e ? e.deco : Decoration.none))
    });

function fieldSelection(e, t) {
    return EditorSelection.create(e.filter((e => e.field == t)).map((e => EditorSelection.range(e.from, e.to))))
}

function snippet(e) {
    let t = Snippet.parse(e);
    return (e, n, o, h) => {
        let {
            text: p,
            ranges: f
        } = t.instantiate(e.state, o), g = {
            changes: {
                from: o,
                to: h,
                insert: Text.of(p)
            },
            scrollIntoView: !0,
            annotations: n ? [mr.of(n), A.userEvent.of("input.complete")] : void 0
        };
        if (f.length && (g.selection = fieldSelection(f, 0)), f.some((e => e.field > 0))) {
            let t = new ActiveSnippet(f, 0),
                n = g.effects = [Dr.of(t)];
            void 0 === e.state.field(Vr, !1) && n.push(StateEffect.appendConfig.of([Vr, Br, Ir, Ar]))
        }
        e.dispatch(e.state.update(g))
    }
}

function moveField(e) {
    return ({
        state: t,
        dispatch: n
    }) => {
        let o = t.field(Vr, !1);
        if (!o || e < 0 && 0 == o.active) return !1;
        let h = o.active + e,
            p = e > 0 && !o.ranges.some((t => t.field == h + e));
        return n(t.update({
            selection: fieldSelection(o.ranges, h),
            effects: Dr.of(p ? null : new ActiveSnippet(o.ranges, h)),
            scrollIntoView: !0
        })), !0
    }
}
const Zr = [{
        key: "Tab",
        run: moveField(1),
        shift: moveField(-1)
    }, {
        key: "Escape",
        run: ({
            state: e,
            dispatch: t
        }) => !!e.field(Vr, !1) && (t(e.update({
            effects: Dr.of(null)
        })), !0)
    }],
    _r = Facet.define({
        combine: e => e.length ? e[0] : Zr
    }),
    Br = b.highest(Qt.compute([_r], (e => e.facet(_r))));

function snippetCompletion(e, t) {
    return Object.assign(Object.assign({}, t), {
        apply: snippet(e)
    })
}
const Ir = EditorView.domEventHandlers({
        mousedown(e, t) {
            let n, o = t.state.field(Vr, !1);
            if (!o || null == (n = t.posAtCoords({
                    x: e.clientX,
                    y: e.clientY
                }))) return !1;
            let h = o.ranges.find((e => e.from <= n && e.to >= n));
            return !(!h || h.field == o.active) && (t.dispatch({
                selection: fieldSelection(o.ranges, h.field),
                effects: Dr.of(o.ranges.some((e => e.field > h.field)) ? new ActiveSnippet(o.ranges, h.field) : null),
                scrollIntoView: !0
            }), !0)
        }
    }),
    Xr = {
        brackets: ["(", "[", "{", "'", '"'],
        before: ")]}:;>",
        stringPrefixes: []
    },
    qr = StateEffect.define({
        map(e, t) {
            let n = t.mapPos(e, -1, o.TrackAfter);
            return null == n ? void 0 : n
        }
    }),
    zr = new class extends RangeValue {};
zr.startSide = 1, zr.endSide = -1;
const Nr = StateField.define({
    create: () => RangeSet.empty,
    update(e, t) {
        if (e = e.map(t.changes), t.selection) {
            let n = t.state.doc.lineAt(t.selection.main.head);
            e = e.update({
                filter: e => e >= n.from && e <= n.to
            })
        }
        for (let n of t.effects) n.is(qr) && (e = e.update({
            add: [zr.range(n.value, n.value + 1)]
        }));
        return e
    }
});
const Yr = "()[]{}<>";

function closing(e) {
    for (let t = 0; t < 8; t += 2)
        if (Yr.charCodeAt(t) == e) return Yr.charAt(t + 1);
    return fromCodePoint(e < 128 ? e : e + 1)
}

function config(e, t) {
    return e.languageDataAt("closeBrackets", t)[0] || Xr
}
const jr = "object" == typeof navigator && /Android\b/.test(navigator.userAgent),
    Wr = EditorView.inputHandler.of(((e, t, n, o) => {
        if ((jr ? e.composing : e.compositionStarted) || e.state.readOnly) return !1;
        let h = e.state.selection.main;
        if (o.length > 2 || 2 == o.length && 1 == codePointSize(codePointAt(o, 0)) || t != h.from || n != h.to) return !1;
        let p = function(e, t) {
            let n = config(e, e.selection.main.head),
                o = n.brackets || Xr.brackets;
            for (let h of o) {
                let p = closing(codePointAt(h, 0));
                if (t == h) return p == h ? handleSame(e, h, o.indexOf(h + h + h) > -1, n) : handleOpen(e, h, p, n.before || Xr.before);
                if (t == p && closedBracketAt(e, e.selection.main.from)) return handleClose(e, h, p)
            }
            return null
        }(e.state, o);
        return !!p && (e.dispatch(p), !0)
    })),
    Ur = [{
        key: "Backspace",
        run: ({
            state: e,
            dispatch: t
        }) => {
            if (e.readOnly) return !1;
            let n = config(e, e.selection.main.head).brackets || Xr.brackets,
                o = null,
                h = e.changeByRange((t => {
                    if (t.empty) {
                        let o = function(e, t) {
                            let n = e.sliceString(t - 2, t);
                            return codePointSize(codePointAt(n, 0)) == n.length ? n : n.slice(1)
                        }(e.doc, t.head);
                        for (let h of n)
                            if (h == o && nextChar(e.doc, t.head) == closing(codePointAt(h, 0))) return {
                                changes: {
                                    from: t.head - h.length,
                                    to: t.head + h.length
                                },
                                range: EditorSelection.cursor(t.head - h.length)
                            }
                    }
                    return {
                        range: o = t
                    }
                }));
            return o || t(e.update(h, {
                scrollIntoView: !0,
                userEvent: "delete.backward"
            })), !o
        }
    }];

function closedBracketAt(e, t) {
    let n = !1;
    return e.field(Nr).between(0, e.doc.length, (e => {
        e == t && (n = !0)
    })), n
}

function nextChar(e, t) {
    let n = e.sliceString(t, t + 2);
    return n.slice(0, codePointSize(codePointAt(n, 0)))
}

function handleOpen(e, t, n, o) {
    let h = null,
        p = e.changeByRange((p => {
            if (!p.empty) return {
                changes: [{
                    insert: t,
                    from: p.from
                }, {
                    insert: n,
                    from: p.to
                }],
                effects: qr.of(p.to + t.length),
                range: EditorSelection.range(p.anchor + t.length, p.head + t.length)
            };
            let f = nextChar(e.doc, p.head);
            return !f || /\s/.test(f) || o.indexOf(f) > -1 ? {
                changes: {
                    insert: t + n,
                    from: p.head
                },
                effects: qr.of(p.head + t.length),
                range: EditorSelection.cursor(p.head + t.length)
            } : {
                range: h = p
            }
        }));
    return h ? null : e.update(p, {
        scrollIntoView: !0,
        userEvent: "input.type"
    })
}

function handleClose(e, t, n) {
    let o = null,
        h = e.changeByRange((t => t.empty && nextChar(e.doc, t.head) == n ? {
            changes: {
                from: t.head,
                to: t.head + n.length,
                insert: n
            },
            range: EditorSelection.cursor(t.head + n.length)
        } : o = {
            range: t
        }));
    return o ? null : e.update(h, {
        scrollIntoView: !0,
        userEvent: "input.type"
    })
}

function handleSame(e, t, n, o) {
    let h = o.stringPrefixes || Xr.stringPrefixes,
        p = null,
        f = e.changeByRange((o => {
            if (!o.empty) return {
                changes: [{
                    insert: t,
                    from: o.from
                }, {
                    insert: t,
                    from: o.to
                }],
                effects: qr.of(o.to + t.length),
                range: EditorSelection.range(o.anchor + t.length, o.head + t.length)
            };
            let f, g = o.head,
                y = nextChar(e.doc, g);
            if (y == t) {
                if (nodeStart(e, g)) return {
                    changes: {
                        insert: t + t,
                        from: g
                    },
                    effects: qr.of(g + t.length),
                    range: EditorSelection.cursor(g + t.length)
                };
                if (closedBracketAt(e, g)) {
                    let o = n && e.sliceDoc(g, g + 3 * t.length) == t + t + t ? t + t + t : t;
                    return {
                        changes: {
                            from: g,
                            to: g + o.length,
                            insert: o
                        },
                        range: EditorSelection.cursor(g + o.length)
                    }
                }
            } else {
                if (n && e.sliceDoc(g - 2 * t.length, g) == t + t && (f = canStartStringAt(e, g - 2 * t.length, h)) > -1 && nodeStart(e, f)) return {
                    changes: {
                        insert: t + t + t + t,
                        from: g
                    },
                    effects: qr.of(g + t.length),
                    range: EditorSelection.cursor(g + t.length)
                };
                if (e.charCategorizer(g)(y) != R.Word && canStartStringAt(e, g, h) > -1 && ! function(e, t, n, o) {
                        let h = syntaxTree(e).resolveInner(t, -1),
                            p = o.reduce(((e, t) => Math.max(e, t.length)), 0);
                        for (let f = 0; f < 5; f++) {
                            let f = e.sliceDoc(h.from, Math.min(h.to, h.from + n.length + p)),
                                g = f.indexOf(n);
                            if (!g || g > -1 && o.indexOf(f.slice(0, g)) > -1) {
                                let t = h.firstChild;
                                for (; t && t.from == h.from && t.to - t.from > n.length + g;) {
                                    if (e.sliceDoc(t.to - n.length, t.to) == n) return !1;
                                    t = t.firstChild
                                }
                                return !0
                            }
                            let y = h.to == t && h.parent;
                            if (!y) break;
                            h = y
                        }
                        return !1
                    }(e, g, t, h)) return {
                    changes: {
                        insert: t + t,
                        from: g
                    },
                    effects: qr.of(g + t.length),
                    range: EditorSelection.cursor(g + t.length)
                }
            }
            return {
                range: p = o
            }
        }));
    return p ? null : e.update(f, {
        scrollIntoView: !0,
        userEvent: "input.type"
    })
}

function nodeStart(e, t) {
    let n = syntaxTree(e).resolveInner(t + 1);
    return n.parent && n.from == t
}

function canStartStringAt(e, t, n) {
    let o = e.charCategorizer(t);
    if (o(e.sliceDoc(t - 1, t)) != R.Word) return t;
    for (let h of n) {
        let n = t - h.length;
        if (e.sliceDoc(n, t) == h && o(e.sliceDoc(n - 1, n)) != R.Word) return n
    }
    return -1
}

function autocompletion(e = {}) {
    return [Er, Cr, br.of(e), Tr, Gr, Ar]
}
const Fr = [{
        key: "Ctrl-Space",
        run: startCompletion
    }, {
        mac: "Alt-`",
        run: startCompletion
    }, {
        key: "Escape",
        run: e => {
            let t = e.state.field(Cr, !1);
            return !(!t || !t.active.some((e => 0 != e.state))) && (e.dispatch({
                effects: wr.of(null)
            }), !0)
        }
    }, {
        key: "ArrowDown",
        run: moveCompletionSelection(!0)
    }, {
        key: "ArrowUp",
        run: moveCompletionSelection(!1)
    }, {
        key: "PageDown",
        run: moveCompletionSelection(!0, "page")
    }, {
        key: "PageUp",
        run: moveCompletionSelection(!1, "page")
    }, {
        key: "Enter",
        run: e => {
            let t = e.state.field(Cr, !1);
            return !(e.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < e.state.facet(br).interactionDelay) && applyCompletion(e, t.open.options[t.open.selected])
        }
    }],
    Gr = b.highest(Qt.computeN([br], (e => e.facet(br).defaultKeymap ? [Fr] : [])));

function crelt() {
    var e = arguments[0];
    "string" == typeof e && (e = document.createElement(e));
    var t = 1,
        n = arguments[1];
    if (n && "object" == typeof n && null == n.nodeType && !Array.isArray(n)) {
        for (var o in n)
            if (Object.prototype.hasOwnProperty.call(n, o)) {
                var h = n[o];
                "string" == typeof h ? e.setAttribute(o, h) : null != h && (e[o] = h)
            }
        t++
    }
    for (; t < arguments.length; t++) add(e, arguments[t]);
    return e
}

function add(e, t) {
    if ("string" == typeof t) e.appendChild(document.createTextNode(t));
    else if (null == t);
    else if (null != t.nodeType) e.appendChild(t);
    else {
        if (!Array.isArray(t)) throw new RangeError("Unsupported child node: " + t);
        for (var n = 0; n < t.length; n++) add(e, t[n])
    }
}
const Hr = "function" == typeof String.prototype.normalize ? e => e.normalize("NFKD") : e => e;
class SearchCursor {
    constructor(e, t, n = 0, o = e.length, h, p) {
        this.test = p, this.value = {
            from: 0,
            to: 0
        }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(n, o), this.bufferStart = n, this.normalize = h ? e => h(Hr(e)) : Hr, this.query = this.normalize(t)
    }
    peek() {
        if (this.bufferPos == this.buffer.length) {
            if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done) return -1;
            this.bufferPos = 0, this.buffer = this.iter.value
        }
        return codePointAt(this.buffer, this.bufferPos)
    }
    next() {
        for (; this.matches.length;) this.matches.pop();
        return this.nextOverlapping()
    }
    nextOverlapping() {
        for (;;) {
            let e = this.peek();
            if (e < 0) return this.done = !0, this;
            let t = fromCodePoint(e),
                n = this.bufferStart + this.bufferPos;
            this.bufferPos += codePointSize(e);
            let o = this.normalize(t);
            if (o.length)
                for (let e = 0, h = n;; e++) {
                    let p = o.charCodeAt(e),
                        f = this.match(p, h, this.bufferPos + this.bufferStart);
                    if (e == o.length - 1) {
                        if (f) return this.value = f, this;
                        break
                    }
                    h == n && e < t.length && t.charCodeAt(e) == p && h++
                }
        }
    }
    match(e, t, n) {
        let o = null;
        for (let t = 0; t < this.matches.length; t += 2) {
            let h = this.matches[t],
                p = !1;
            this.query.charCodeAt(h) == e && (h == this.query.length - 1 ? o = {
                from: this.matches[t + 1],
                to: n
            } : (this.matches[t]++, p = !0)), p || (this.matches.splice(t, 2), t -= 2)
        }
        return this.query.charCodeAt(0) == e && (1 == this.query.length ? o = {
            from: t,
            to: n
        } : this.matches.push(1, t)), o && this.test && !this.test(o.from, o.to, this.buffer, this.bufferStart) && (o = null), o
    }
}
"undefined" != typeof Symbol && (SearchCursor.prototype[Symbol.iterator] = function() {
    return this
});
const Kr = {
        from: -1,
        to: -1,
        match: /.*/.exec("")
    },
    Jr = "gm" + (null == /x/.unicode ? "" : "u");
class RegExpCursor {
    constructor(e, t, n, o = 0, h = e.length) {
        if (this.text = e, this.to = h, this.curLine = "", this.done = !1, this.value = Kr, /\\[sWDnr]|\n|\r|\[\^/.test(t)) return new MultilineRegExpCursor(e, t, n, o, h);
        this.re = new RegExp(t, Jr + ((null == n ? void 0 : n.ignoreCase) ? "i" : "")), this.test = null == n ? void 0 : n.test, this.iter = e.iter();
        let p = e.lineAt(o);
        this.curLineStart = p.from, this.matchPos = toCharEnd(e, o), this.getLine(this.curLineStart)
    }
    getLine(e) {
        this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next())
    }
    nextLine() {
        this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0)
    }
    next() {
        for (let e = this.matchPos - this.curLineStart;;) {
            this.re.lastIndex = e;
            let t = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (t) {
                let n = this.curLineStart + t.index,
                    o = n + t[0].length;
                if (this.matchPos = toCharEnd(this.text, o + (n == o ? 1 : 0)), n == this.curLineStart + this.curLine.length && this.nextLine(), (n < o || n > this.value.to) && (!this.test || this.test(n, o, t))) return this.value = {
                    from: n,
                    to: o,
                    match: t
                }, this;
                e = this.matchPos - this.curLineStart
            } else {
                if (!(this.curLineStart + this.curLine.length < this.to)) return this.done = !0, this;
                this.nextLine(), e = 0
            }
        }
    }
}
const eo = new WeakMap;
class FlattenedDoc {
    constructor(e, t) {
        this.from = e, this.text = t
    }
    get to() {
        return this.from + this.text.length
    }
    static get(e, t, n) {
        let o = eo.get(e);
        if (!o || o.from >= n || o.to <= t) {
            let o = new FlattenedDoc(t, e.sliceString(t, n));
            return eo.set(e, o), o
        }
        if (o.from == t && o.to == n) return o;
        let {
            text: h,
            from: p
        } = o;
        return p > t && (h = e.sliceString(t, p) + h, p = t), o.to < n && (h += e.sliceString(o.to, n)), eo.set(e, new FlattenedDoc(p, h)), new FlattenedDoc(t, h.slice(t - p, n - p))
    }
}
class MultilineRegExpCursor {
    constructor(e, t, n, o, h) {
        this.text = e, this.to = h, this.done = !1, this.value = Kr, this.matchPos = toCharEnd(e, o), this.re = new RegExp(t, Jr + ((null == n ? void 0 : n.ignoreCase) ? "i" : "")), this.test = null == n ? void 0 : n.test, this.flat = FlattenedDoc.get(e, o, this.chunkEnd(o + 5e3))
    }
    chunkEnd(e) {
        return e >= this.to ? this.to : this.text.lineAt(e).to
    }
    next() {
        for (;;) {
            let e = this.re.lastIndex = this.matchPos - this.flat.from,
                t = this.re.exec(this.flat.text);
            if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
                let e = this.flat.from + t.index,
                    n = e + t[0].length;
                if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(e, n, t))) return this.value = {
                    from: e,
                    to: n,
                    match: t
                }, this.matchPos = toCharEnd(this.text, n + (e == n ? 1 : 0)), this
            }
            if (this.flat.to == this.to) return this.done = !0, this;
            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + 2 * this.flat.text.length))
        }
    }
}

function toCharEnd(e, t) {
    if (t >= e.length) return t;
    let n, o = e.lineAt(t);
    for (; t < o.to && (n = o.text.charCodeAt(t - o.from)) >= 56320 && n < 57344;) t++;
    return t
}

function createLineDialog(e) {
    let t = crelt("input", {
        class: "cm-textfield",
        name: "line",
        value: String(e.state.doc.lineAt(e.state.selection.main.head).number)
    });

    function go() {
        let n = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
        if (!n) return;
        let {
            state: o
        } = e, h = o.doc.lineAt(o.selection.main.head), [, p, f, g, y] = n, w = g ? +g.slice(1) : 0, b = f ? +f : h.number;
        if (f && y) {
            let e = b / 100;
            p && (e = e * ("-" == p ? -1 : 1) + h.number / o.doc.lines), b = Math.round(o.doc.lines * e)
        } else f && p && (b = b * ("-" == p ? -1 : 1) + h.number);
        let S = o.doc.line(Math.max(1, Math.min(o.doc.lines, b))),
            k = EditorSelection.cursor(S.from + Math.max(0, Math.min(w, S.length)));
        e.dispatch({
            effects: [to.of(!1), EditorView.scrollIntoView(k.from, {
                y: "center"
            })],
            selection: k
        }), e.focus()
    }
    return {
        dom: crelt("form", {
            class: "cm-gotoLine",
            onkeydown: t => {
                27 == t.keyCode ? (t.preventDefault(), e.dispatch({
                    effects: to.of(!1)
                }), e.focus()) : 13 == t.keyCode && (t.preventDefault(), go())
            },
            onsubmit: e => {
                e.preventDefault(), go()
            }
        }, crelt("label", e.state.phrase("Go to line"), ": ", t), " ", crelt("button", {
            class: "cm-button",
            type: "submit"
        }, e.state.phrase("go")))
    }
}
"undefined" != typeof Symbol && (RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this
});
const to = StateEffect.define(),
    no = StateField.define({
        create: () => !0,
        update(e, t) {
            for (let n of t.effects) n.is(to) && (e = n.value);
            return e
        },
        provide: e => gn.from(e, (e => e ? createLineDialog : null))
    }),
    io = EditorView.baseTheme({
        ".cm-panel.cm-gotoLine": {
            padding: "2px 6px 4px",
            "& label": {
                fontSize: "80%"
            }
        }
    }),
    ro = {
        highlightWordAroundCursor: !1,
        minSelectionLength: 1,
        maxMatches: 100,
        wholeWords: !1
    },
    oo = Facet.define({
        combine: e => combineConfig(e, ro, {
            highlightWordAroundCursor: (e, t) => e || t,
            minSelectionLength: Math.min,
            maxMatches: Math.min
        })
    });
const so = Decoration.mark({
        class: "cm-selectionMatch"
    }),
    ao = Decoration.mark({
        class: "cm-selectionMatch cm-selectionMatch-main"
    });

function insideWordBoundaries(e, t, n, o) {
    return !(0 != n && e(t.sliceDoc(n - 1, n)) == R.Word || o != t.doc.length && e(t.sliceDoc(o, o + 1)) == R.Word)
}
const lo = ViewPlugin.fromClass(class {
        constructor(e) {
            this.decorations = this.getDeco(e)
        }
        update(e) {
            (e.selectionSet || e.docChanged || e.viewportChanged) && (this.decorations = this.getDeco(e.view))
        }
        getDeco(e) {
            let t = e.state.facet(oo),
                {
                    state: n
                } = e,
                o = n.selection;
            if (o.ranges.length > 1) return Decoration.none;
            let h, p = o.main,
                f = null;
            if (p.empty) {
                if (!t.highlightWordAroundCursor) return Decoration.none;
                let e = n.wordAt(p.head);
                if (!e) return Decoration.none;
                f = n.charCategorizer(p.head), h = n.sliceDoc(e.from, e.to)
            } else {
                let e = p.to - p.from;
                if (e < t.minSelectionLength || e > 200) return Decoration.none;
                if (t.wholeWords) {
                    if (h = n.sliceDoc(p.from, p.to), f = n.charCategorizer(p.head), !insideWordBoundaries(f, n, p.from, p.to) || ! function(e, t, n, o) {
                            return e(t.sliceDoc(n, n + 1)) == R.Word && e(t.sliceDoc(o - 1, o)) == R.Word
                        }(f, n, p.from, p.to)) return Decoration.none
                } else if (h = n.sliceDoc(p.from, p.to), !h) return Decoration.none
            }
            let g = [];
            for (let o of e.visibleRanges) {
                let e = new SearchCursor(n.doc, h, o.from, o.to);
                for (; !e.next().done;) {
                    let {
                        from: o,
                        to: h
                    } = e.value;
                    if ((!f || insideWordBoundaries(f, n, o, h)) && (p.empty && o <= p.from && h >= p.to ? g.push(ao.range(o, h)) : (o >= p.to || h <= p.from) && g.push(so.range(o, h)), g.length > t.maxMatches)) return Decoration.none
                }
            }
            return Decoration.set(g)
        }
    }, {
        decorations: e => e.decorations
    }),
    co = EditorView.baseTheme({
        ".cm-selectionMatch": {
            backgroundColor: "#99ff7780"
        },
        ".cm-searchMatch .cm-selectionMatch": {
            backgroundColor: "transparent"
        }
    });
const ho = Facet.define({
    combine: e => combineConfig(e, {
        top: !1,
        caseSensitive: !1,
        literal: !1,
        regexp: !1,
        wholeWord: !1,
        createPanel: e => new SearchPanel(e),
        scrollToMatch: e => EditorView.scrollIntoView(e)
    })
});
class SearchQuery {
    constructor(e) {
        this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || function(e) {
            try {
                return new RegExp(e, Jr), !0
            } catch (e) {
                return !1
            }
        }(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord
    }
    unquote(e) {
        return this.literal ? e : e.replace(/\\([nrt\\])/g, ((e, t) => "n" == t ? "\n" : "r" == t ? "\r" : "t" == t ? "\t" : "\\"))
    }
    eq(e) {
        return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord
    }
    create() {
        return this.regexp ? new RegExpQuery(this) : new StringQuery(this)
    }
    getCursor(e, t = 0, n) {
        let o = e.doc ? e : EditorState.create({
            doc: e
        });
        return null == n && (n = o.doc.length), this.regexp ? regexpCursor(this, o, t, n) : stringCursor(this, o, t, n)
    }
}
class QueryType {
    constructor(e) {
        this.spec = e
    }
}

function stringCursor(e, t, n, o) {
    return new SearchCursor(t.doc, e.unquoted, n, o, e.caseSensitive ? void 0 : e => e.toLowerCase(), e.wholeWord ? function(e, t) {
        return (n, o, h, p) => ((p > n || p + h.length < o) && (p = Math.max(0, n - 2), h = e.sliceString(p, Math.min(e.length, o + 2))), !(t(charBefore(h, n - p)) == R.Word && t(charAfter(h, n - p)) == R.Word || t(charAfter(h, o - p)) == R.Word && t(charBefore(h, o - p)) == R.Word))
    }(t.doc, t.charCategorizer(t.selection.main.head)) : void 0)
}
class StringQuery extends QueryType {
    constructor(e) {
        super(e)
    }
    nextMatch(e, t, n) {
        let o = stringCursor(this.spec, e, n, e.doc.length).nextOverlapping();
        if (o.done) {
            let n = Math.min(e.doc.length, t + this.spec.unquoted.length);
            o = stringCursor(this.spec, e, 0, n).nextOverlapping()
        }
        return o.done || o.value.from == t && o.value.to == n ? null : o.value
    }
    prevMatchInRange(e, t, n) {
        for (let o = n;;) {
            let n = Math.max(t, o - 1e4 - this.spec.unquoted.length),
                h = stringCursor(this.spec, e, n, o),
                p = null;
            for (; !h.nextOverlapping().done;) p = h.value;
            if (p) return p;
            if (n == t) return null;
            o -= 1e4
        }
    }
    prevMatch(e, t, n) {
        let o = this.prevMatchInRange(e, 0, t);
        return o || (o = this.prevMatchInRange(e, Math.max(0, n - this.spec.unquoted.length), e.doc.length)), !o || o.from == t && o.to == n ? null : o
    }
    getReplacement(e) {
        return this.spec.unquote(this.spec.replace)
    }
    matchAll(e, t) {
        let n = stringCursor(this.spec, e, 0, e.doc.length),
            o = [];
        for (; !n.next().done;) {
            if (o.length >= t) return null;
            o.push(n.value)
        }
        return o
    }
    highlight(e, t, n, o) {
        let h = stringCursor(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(n + this.spec.unquoted.length, e.doc.length));
        for (; !h.next().done;) o(h.value.from, h.value.to)
    }
}

function regexpCursor(e, t, n, o) {
    return new RegExpCursor(t.doc, e.search, {
        ignoreCase: !e.caseSensitive,
        test: e.wholeWord ? (h = t.charCategorizer(t.selection.main.head), (e, t, n) => !n[0].length || (h(charBefore(n.input, n.index)) != R.Word || h(charAfter(n.input, n.index)) != R.Word) && (h(charAfter(n.input, n.index + n[0].length)) != R.Word || h(charBefore(n.input, n.index + n[0].length)) != R.Word)) : void 0
    }, n, o);
    var h
}

function charBefore(e, t) {
    return e.slice(findClusterBreak(e, t, !1), t)
}

function charAfter(e, t) {
    return e.slice(t, findClusterBreak(e, t))
}
class RegExpQuery extends QueryType {
    nextMatch(e, t, n) {
        let o = regexpCursor(this.spec, e, n, e.doc.length).next();
        return o.done && (o = regexpCursor(this.spec, e, 0, t).next()), o.done ? null : o.value
    }
    prevMatchInRange(e, t, n) {
        for (let o = 1;; o++) {
            let h = Math.max(t, n - 1e4 * o),
                p = regexpCursor(this.spec, e, h, n),
                f = null;
            for (; !p.next().done;) f = p.value;
            if (f && (h == t || f.from > h + 10)) return f;
            if (h == t) return null
        }
    }
    prevMatch(e, t, n) {
        return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, n, e.doc.length)
    }
    getReplacement(e) {
        return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, ((t, n) => "$" == n ? "$" : "&" == n ? e.match[0] : "0" != n && +n < e.match.length ? e.match[n] : t))
    }
    matchAll(e, t) {
        let n = regexpCursor(this.spec, e, 0, e.doc.length),
            o = [];
        for (; !n.next().done;) {
            if (o.length >= t) return null;
            o.push(n.value)
        }
        return o
    }
    highlight(e, t, n, o) {
        let h = regexpCursor(this.spec, e, Math.max(0, t - 250), Math.min(n + 250, e.doc.length));
        for (; !h.next().done;) o(h.value.from, h.value.to)
    }
}
const uo = StateEffect.define(),
    po = StateEffect.define(),
    fo = StateField.define({
        create: e => new SearchState(defaultQuery(e).create(), null),
        update(e, t) {
            for (let n of t.effects) n.is(uo) ? e = new SearchState(n.value.create(), e.panel) : n.is(po) && (e = new SearchState(e.query, n.value ? createSearchPanel : null));
            return e
        },
        provide: e => gn.from(e, (e => e.panel))
    });
class SearchState {
    constructor(e, t) {
        this.query = e, this.panel = t
    }
}
const mo = Decoration.mark({
        class: "cm-searchMatch"
    }),
    Oo = Decoration.mark({
        class: "cm-searchMatch cm-searchMatch-selected"
    }),
    yo = ViewPlugin.fromClass(class {
        constructor(e) {
            this.view = e, this.decorations = this.highlight(e.state.field(fo))
        }
        update(e) {
            let t = e.state.field(fo);
            (t != e.startState.field(fo) || e.docChanged || e.selectionSet || e.viewportChanged) && (this.decorations = this.highlight(t))
        }
        highlight({
            query: e,
            panel: t
        }) {
            if (!t || !e.spec.valid) return Decoration.none;
            let {
                view: n
            } = this, o = new RangeSetBuilder;
            for (let t = 0, h = n.visibleRanges, p = h.length; t < p; t++) {
                let {
                    from: f,
                    to: g
                } = h[t];
                for (; t < p - 1 && g > h[t + 1].from - 500;) g = h[++t].to;
                e.highlight(n.state, f, g, ((e, t) => {
                    let h = n.state.selection.ranges.some((n => n.from == e && n.to == t));
                    o.add(e, t, h ? Oo : mo)
                }))
            }
            return o.finish()
        }
    }, {
        decorations: e => e.decorations
    });

function searchCommand(e) {
    return t => {
        let n = t.state.field(fo, !1);
        return n && n.query.spec.valid ? e(t, n) : openSearchPanel(t)
    }
}
const wo = searchCommand(((e, {
        query: t
    }) => {
        let {
            to: n
        } = e.state.selection.main, o = t.nextMatch(e.state, n, n);
        if (!o) return !1;
        let h = EditorSelection.single(o.from, o.to),
            p = e.state.facet(ho);
        return e.dispatch({
            selection: h,
            effects: [announceMatch(e, o), p.scrollToMatch(h.main, e)],
            userEvent: "select.search"
        }), selectSearchInput(e), !0
    })),
    bo = searchCommand(((e, {
        query: t
    }) => {
        let {
            state: n
        } = e, {
            from: o
        } = n.selection.main, h = t.prevMatch(n, o, o);
        if (!h) return !1;
        let p = EditorSelection.single(h.from, h.to),
            f = e.state.facet(ho);
        return e.dispatch({
            selection: p,
            effects: [announceMatch(e, h), f.scrollToMatch(p.main, e)],
            userEvent: "select.search"
        }), selectSearchInput(e), !0
    })),
    So = searchCommand(((e, {
        query: t
    }) => {
        let n = t.matchAll(e.state, 1e3);
        return !(!n || !n.length) && (e.dispatch({
            selection: EditorSelection.create(n.map((e => EditorSelection.range(e.from, e.to)))),
            userEvent: "select.search.matches"
        }), !0)
    })),
    xo = searchCommand(((e, {
        query: t
    }) => {
        let {
            state: n
        } = e, {
            from: o,
            to: h
        } = n.selection.main;
        if (n.readOnly) return !1;
        let p = t.nextMatch(n, o, o);
        if (!p) return !1;
        let f, g, y = p,
            w = [],
            b = [];
        if (y.from == o && y.to == h && (g = n.toText(t.getReplacement(y)), w.push({
                from: y.from,
                to: y.to,
                insert: g
            }), y = t.nextMatch(n, y.from, y.to), b.push(EditorView.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(o).number) + "."))), y) {
            let t = 0 == w.length || w[0].from >= p.to ? 0 : p.to - p.from - g.length;
            f = EditorSelection.single(y.from - t, y.to - t), b.push(announceMatch(e, y)), b.push(n.facet(ho).scrollToMatch(f.main, e))
        }
        return e.dispatch({
            changes: w,
            selection: f,
            effects: b,
            userEvent: "input.replace"
        }), !0
    })),
    ko = searchCommand(((e, {
        query: t
    }) => {
        if (e.state.readOnly) return !1;
        let n = t.matchAll(e.state, 1e9).map((e => {
            let {
                from: n,
                to: o
            } = e;
            return {
                from: n,
                to: o,
                insert: t.getReplacement(e)
            }
        }));
        if (!n.length) return !1;
        let o = e.state.phrase("replaced $ matches", n.length) + ".";
        return e.dispatch({
            changes: n,
            effects: EditorView.announce.of(o),
            userEvent: "input.replace.all"
        }), !0
    }));

function createSearchPanel(e) {
    return e.state.facet(ho).createPanel(e)
}

function defaultQuery(e, t) {
    var n, o, h, p, f;
    let g = e.selection.main,
        y = g.empty || g.to > g.from + 100 ? "" : e.sliceDoc(g.from, g.to);
    if (t && !y) return t;
    let w = e.facet(ho);
    return new SearchQuery({
        search: (null !== (n = null == t ? void 0 : t.literal) && void 0 !== n ? n : w.literal) ? y : y.replace(/\n/g, "\\n"),
        caseSensitive: null !== (o = null == t ? void 0 : t.caseSensitive) && void 0 !== o ? o : w.caseSensitive,
        literal: null !== (h = null == t ? void 0 : t.literal) && void 0 !== h ? h : w.literal,
        regexp: null !== (p = null == t ? void 0 : t.regexp) && void 0 !== p ? p : w.regexp,
        wholeWord: null !== (f = null == t ? void 0 : t.wholeWord) && void 0 !== f ? f : w.wholeWord
    })
}

function getSearchInput(e) {
    let t = getPanel(e, createSearchPanel);
    return t && t.dom.querySelector("[main-field]")
}

function selectSearchInput(e) {
    let t = getSearchInput(e);
    t && t == e.root.activeElement && t.select()
}
const openSearchPanel = e => {
        let t = e.state.field(fo, !1);
        if (t && t.panel) {
            let n = getSearchInput(e);
            if (n && n != e.root.activeElement) {
                let o = defaultQuery(e.state, t.query.spec);
                o.valid && e.dispatch({
                    effects: uo.of(o)
                }), n.focus(), n.select()
            }
        } else e.dispatch({
            effects: [po.of(!0), t ? uo.of(defaultQuery(e.state, t.query.spec)) : StateEffect.appendConfig.of(To)]
        });
        return !0
    },
    closeSearchPanel = e => {
        let t = e.state.field(fo, !1);
        if (!t || !t.panel) return !1;
        let n = getPanel(e, createSearchPanel);
        return n && n.dom.contains(e.root.activeElement) && e.focus(), e.dispatch({
            effects: po.of(!1)
        }), !0
    },
    vo = [{
        key: "Mod-f",
        run: openSearchPanel,
        scope: "editor search-panel"
    }, {
        key: "F3",
        run: wo,
        shift: bo,
        scope: "editor search-panel",
        preventDefault: !0
    }, {
        key: "Mod-g",
        run: wo,
        shift: bo,
        scope: "editor search-panel",
        preventDefault: !0
    }, {
        key: "Escape",
        run: closeSearchPanel,
        scope: "editor search-panel"
    }, {
        key: "Mod-Shift-l",
        run: ({
            state: e,
            dispatch: t
        }) => {
            let n = e.selection;
            if (n.ranges.length > 1 || n.main.empty) return !1;
            let {
                from: o,
                to: h
            } = n.main, p = [], f = 0;
            for (let t = new SearchCursor(e.doc, e.sliceDoc(o, h)); !t.next().done;) {
                if (p.length > 1e3) return !1;
                t.value.from == o && (f = p.length), p.push(EditorSelection.range(t.value.from, t.value.to))
            }
            return t(e.update({
                selection: EditorSelection.create(p, f),
                userEvent: "select.search.matches"
            })), !0
        }
    }, {
        key: "Mod-Alt-g",
        run: e => {
            let t = getPanel(e, createLineDialog);
            if (!t) {
                let n = [to.of(!0)];
                null == e.state.field(no, !1) && n.push(StateEffect.appendConfig.of([no, io])), e.dispatch({
                    effects: n
                }), t = getPanel(e, createLineDialog)
            }
            return t && t.dom.querySelector("input").select(), !0
        }
    }, {
        key: "Mod-d",
        run: ({
            state: e,
            dispatch: t
        }) => {
            let {
                ranges: n
            } = e.selection;
            if (n.some((e => e.from === e.to))) return (({
                state: e,
                dispatch: t
            }) => {
                let {
                    selection: n
                } = e, o = EditorSelection.create(n.ranges.map((t => e.wordAt(t.head) || EditorSelection.cursor(t.head))), n.mainIndex);
                return !o.eq(n) && (t(e.update({
                    selection: o
                })), !0)
            })({
                state: e,
                dispatch: t
            });
            let o = e.sliceDoc(n[0].from, n[0].to);
            if (e.selection.ranges.some((t => e.sliceDoc(t.from, t.to) != o))) return !1;
            let h = function(e, t) {
                let {
                    main: n,
                    ranges: o
                } = e.selection, h = e.wordAt(n.head), p = h && h.from == n.from && h.to == n.to;
                for (let n = !1, h = new SearchCursor(e.doc, t, o[o.length - 1].to);;) {
                    if (h.next(), !h.done) {
                        if (n && o.some((e => e.from == h.value.from))) continue;
                        if (p) {
                            let t = e.wordAt(h.value.from);
                            if (!t || t.from != h.value.from || t.to != h.value.to) continue
                        }
                        return h.value
                    }
                    if (n) return null;
                    h = new SearchCursor(e.doc, t, 0, Math.max(0, o[o.length - 1].from - 1)), n = !0
                }
            }(e, o);
            return !!h && (t(e.update({
                selection: e.selection.addRange(EditorSelection.range(h.from, h.to), !1),
                effects: EditorView.scrollIntoView(h.to)
            })), !0)
        },
        preventDefault: !0
    }];
class SearchPanel {
    constructor(e) {
        this.view = e;
        let t = this.query = e.state.field(fo).query.spec;

        function button(e, t, n) {
            return crelt("button", {
                class: "cm-button",
                name: e,
                onclick: t,
                type: "button"
            }, n)
        }
        this.commit = this.commit.bind(this), this.searchField = crelt("input", {
            value: t.search,
            placeholder: phrase(e, "Find"),
            "aria-label": phrase(e, "Find"),
            class: "cm-textfield",
            name: "search",
            form: "",
            "main-field": "true",
            onchange: this.commit,
            onkeyup: this.commit
        }), this.replaceField = crelt("input", {
            value: t.replace,
            placeholder: phrase(e, "Replace"),
            "aria-label": phrase(e, "Replace"),
            class: "cm-textfield",
            name: "replace",
            form: "",
            onchange: this.commit,
            onkeyup: this.commit
        }), this.caseField = crelt("input", {
            type: "checkbox",
            name: "case",
            form: "",
            checked: t.caseSensitive,
            onchange: this.commit
        }), this.reField = crelt("input", {
            type: "checkbox",
            name: "re",
            form: "",
            checked: t.regexp,
            onchange: this.commit
        }), this.wordField = crelt("input", {
            type: "checkbox",
            name: "word",
            form: "",
            checked: t.wholeWord,
            onchange: this.commit
        }), this.dom = crelt("div", {
            onkeydown: e => this.keydown(e),
            class: "cm-search"
        }, [this.searchField, button("next", (() => wo(e)), [phrase(e, "next")]), button("prev", (() => bo(e)), [phrase(e, "previous")]), button("select", (() => So(e)), [phrase(e, "all")]), crelt("label", null, [this.caseField, phrase(e, "match case")]), crelt("label", null, [this.reField, phrase(e, "regexp")]), crelt("label", null, [this.wordField, phrase(e, "by word")]), ...e.state.readOnly ? [] : [crelt("br"), this.replaceField, button("replace", (() => xo(e)), [phrase(e, "replace")]), button("replaceAll", (() => ko(e)), [phrase(e, "replace all")])], crelt("button", {
            name: "close",
            onclick: () => closeSearchPanel(e),
            "aria-label": phrase(e, "close"),
            type: "button"
        }, ["Ã—"])])
    }
    commit() {
        let e = new SearchQuery({
            search: this.searchField.value,
            caseSensitive: this.caseField.checked,
            regexp: this.reField.checked,
            wholeWord: this.wordField.checked,
            replace: this.replaceField.value
        });
        e.eq(this.query) || (this.query = e, this.view.dispatch({
            effects: uo.of(e)
        }))
    }
    keydown(e) {
        runScopeHandlers(this.view, e, "search-panel") ? e.preventDefault() : 13 == e.keyCode && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? bo : wo)(this.view)) : 13 == e.keyCode && e.target == this.replaceField && (e.preventDefault(), xo(this.view))
    }
    update(e) {
        for (let t of e.transactions)
            for (let e of t.effects) e.is(uo) && !e.value.eq(this.query) && this.setQuery(e.value)
    }
    setQuery(e) {
        this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord
    }
    mount() {
        this.searchField.select()
    }
    get pos() {
        return 80
    }
    get top() {
        return this.view.state.facet(ho).top
    }
}

function phrase(e, t) {
    return e.state.phrase(t)
}
const Po = 30,
    Co = /[\s\.,:;?!]/;

function announceMatch(e, {
    from: t,
    to: n
}) {
    let o = e.state.doc.lineAt(t),
        h = e.state.doc.lineAt(n).to,
        p = Math.max(o.from, t - Po),
        f = Math.min(h, n + Po),
        g = e.state.sliceDoc(p, f);
    if (p != o.from)
        for (let e = 0; e < Po; e++)
            if (!Co.test(g[e + 1]) && Co.test(g[e])) {
                g = g.slice(e);
                break
            }
    if (f != h)
        for (let e = g.length - 1; e > g.length - Po; e--)
            if (!Co.test(g[e - 1]) && Co.test(g[e])) {
                g = g.slice(0, e);
                break
            }
    return EditorView.announce.of(`${e.state.phrase("current match")}. ${g} ${e.state.phrase("on line")} ${o.number}.`)
}
const Qo = EditorView.baseTheme({
        ".cm-panel.cm-search": {
            padding: "2px 6px 4px",
            position: "relative",
            "& [name=close]": {
                position: "absolute",
                top: "0",
                right: "4px",
                backgroundColor: "inherit",
                border: "none",
                font: "inherit",
                padding: 0,
                margin: 0
            },
            "& input, & button, & label": {
                margin: ".2em .6em .2em 0"
            },
            "& input[type=checkbox]": {
                marginRight: ".2em"
            },
            "& label": {
                fontSize: "80%",
                whiteSpace: "pre"
            }
        },
        "&light .cm-searchMatch": {
            backgroundColor: "#ffff0054"
        },
        "&dark .cm-searchMatch": {
            backgroundColor: "#00ffff8a"
        },
        "&light .cm-searchMatch-selected": {
            backgroundColor: "#ff6a0054"
        },
        "&dark .cm-searchMatch-selected": {
            backgroundColor: "#ff00ff8a"
        }
    }),
    To = [fo, b.low(yo), Qo];
class SelectedDiagnostic {
    constructor(e, t, n) {
        this.from = e, this.to = t, this.diagnostic = n
    }
}
class LintState {
    constructor(e, t, n) {
        this.diagnostics = e, this.panel = t, this.selected = n
    }
    static init(e, t, n) {
        let o = e,
            h = n.facet(Vo).markerFilter;
        h && (o = h(o, n));
        let p = Decoration.set(o.map((e => e.from == e.to || e.from == e.to - 1 && n.doc.lineAt(e.from).to == e.from ? Decoration.widget({
            widget: new DiagnosticWidget(e),
            diagnostic: e
        }).range(e.from) : Decoration.mark({
            attributes: {
                class: "cm-lintRange cm-lintRange-" + e.severity + (e.markClass ? " " + e.markClass : "")
            },
            diagnostic: e
        }).range(e.from, e.to))), !0);
        return new LintState(p, t, findDiagnostic(p))
    }
}

function findDiagnostic(e, t = null, n = 0) {
    let o = null;
    return e.between(n, 1e9, ((e, n, {
        spec: h
    }) => {
        if (!t || h.diagnostic == t) return o = new SelectedDiagnostic(e, n, h.diagnostic), !1
    })), o
}

function hideTooltip(e, t) {
    let n = t.pos,
        o = t.end || n,
        h = e.state.facet(Vo).hideOn(e, n, o);
    if (null != h) return h;
    let p = e.startState.doc.lineAt(t.pos);
    return !(!e.effects.some((e => e.is($o))) && !e.changes.touchesRange(p.from, Math.max(p.to, o)))
}

function maybeEnableLint(e, t) {
    return e.field(Mo, !1) ? t : t.concat(StateEffect.appendConfig.of(zo))
}
const $o = StateEffect.define(),
    Eo = StateEffect.define(),
    Ao = StateEffect.define(),
    Mo = StateField.define({
        create: () => new LintState(Decoration.none, null, null),
        update(e, t) {
            if (t.docChanged && e.diagnostics.size) {
                let n = e.diagnostics.map(t.changes),
                    o = null,
                    h = e.panel;
                if (e.selected) {
                    let h = t.changes.mapPos(e.selected.from, 1);
                    o = findDiagnostic(n, e.selected.diagnostic, h) || findDiagnostic(n, null, h)
                }!n.size && h && t.state.facet(Vo).autoPanel && (h = null), e = new LintState(n, h, o)
            }
            for (let n of t.effects)
                if (n.is($o)) {
                    let o = t.state.facet(Vo).autoPanel ? n.value.length ? LintPanel.open : null : e.panel;
                    e = LintState.init(n.value, o, t.state)
                } else n.is(Eo) ? e = new LintState(e.diagnostics, n.value ? LintPanel.open : null, e.selected) : n.is(Ao) && (e = new LintState(e.diagnostics, e.panel, n.value));
            return e
        },
        provide: e => [gn.from(e, (e => e.panel)), EditorView.decorations.from(e, (e => e.diagnostics))]
    }),
    Ro = Decoration.mark({
        class: "cm-lintRange cm-lintRange-active"
    });

function lintTooltip(e, t, n) {
    let {
        diagnostics: o
    } = e.state.field(Mo), h = [], p = 2e8, f = 0;
    o.between(t - (n < 0 ? 1 : 0), t + (n > 0 ? 1 : 0), ((e, o, {
        spec: g
    }) => {
        t >= e && t <= o && (e == o || (t > e || n > 0) && (t < o || n < 0)) && (h.push(g.diagnostic), p = Math.min(e, p), f = Math.max(o, f))
    }));
    let g = e.state.facet(Vo).tooltipFilter;
    return g && (h = g(h, e.state)), h.length ? {
        pos: p,
        end: f,
        above: e.state.doc.lineAt(p).to < f,
        create: () => ({
            dom: diagnosticsTooltip(e, h)
        })
    } : null
}

function diagnosticsTooltip(e, t) {
    return crelt("ul", {
        class: "cm-tooltip-lint"
    }, t.map((t => renderDiagnostic(e, t, !1))))
}
const closeLintPanel = e => {
        let t = e.state.field(Mo, !1);
        return !(!t || !t.panel) && (e.dispatch({
            effects: Eo.of(!1)
        }), !0)
    },
    Do = [{
        key: "Mod-Shift-m",
        run: e => {
            let t = e.state.field(Mo, !1);
            t && t.panel || e.dispatch({
                effects: maybeEnableLint(e.state, [Eo.of(!0)])
            });
            let n = getPanel(e, LintPanel.open);
            return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0
        },
        preventDefault: !0
    }, {
        key: "F8",
        run: e => {
            let t = e.state.field(Mo, !1);
            if (!t) return !1;
            let n = e.state.selection.main,
                o = t.diagnostics.iter(n.to + 1);
            return !(!o.value && (o = t.diagnostics.iter(0), !o.value || o.from == n.from && o.to == n.to)) && (e.dispatch({
                selection: {
                    anchor: o.from,
                    head: o.to
                },
                scrollIntoView: !0
            }), !0)
        }
    }],
    Lo = ViewPlugin.fromClass(class {
        constructor(e) {
            this.view = e, this.timeout = -1, this.set = !0;
            let {
                delay: t
            } = e.state.facet(Vo);
            this.lintTime = Date.now() + t, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, t)
        }
        run() {
            clearTimeout(this.timeout);
            let e = Date.now();
            if (e < this.lintTime - 10) this.timeout = setTimeout(this.run, this.lintTime - e);
            else {
                this.set = !1;
                let {
                    state: e
                } = this.view, {
                    sources: t
                } = e.facet(Vo);
                t.length && function(e, t, n) {
                    let o = [],
                        h = -1;
                    for (let p of e) p.then((n => {
                        o.push(n), clearTimeout(h), o.length == e.length ? t(o) : setTimeout((() => t(o)), 200)
                    }), n)
                }(t.map((e => Promise.resolve(e(this.view)))), (t => {
                    this.view.state.doc == e.doc && this.view.dispatch(function(e, t) {
                        return {
                            effects: maybeEnableLint(e, [$o.of(t)])
                        }
                    }(this.view.state, t.reduce(((e, t) => e.concat(t)))))
                }), (e => {
                    logException(this.view.state, e)
                }))
            }
        }
        update(e) {
            let t = e.state.facet(Vo);
            (e.docChanged || t != e.startState.facet(Vo) || t.needsRefresh && t.needsRefresh(e)) && (this.lintTime = Date.now() + t.delay, this.set || (this.set = !0, this.timeout = setTimeout(this.run, t.delay)))
        }
        force() {
            this.set && (this.lintTime = Date.now(), this.run())
        }
        destroy() {
            clearTimeout(this.timeout)
        }
    });
const Vo = Facet.define({
    combine: e => Object.assign({
        sources: e.map((e => e.source)).filter((e => null != e))
    }, combineConfig(e.map((e => e.config)), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
    }, {
        needsRefresh: (e, t) => e ? t ? n => e(n) || t(n) : e : t
    }))
});

function linter(e, t = {}) {
    return [Vo.of({
        source: e,
        config: t
    }), Lo, zo]
}

function assignKeys(e) {
    let t = [];
    if (e) e: for (let {
            name: n
        } of e) {
        for (let e = 0; e < n.length; e++) {
            let o = n[e];
            if (/[a-zA-Z]/.test(o) && !t.some((e => e.toLowerCase() == o.toLowerCase()))) {
                t.push(o);
                continue e
            }
        }
        t.push("")
    }
    return t
}

function renderDiagnostic(e, t, n) {
    var o;
    let h = n ? assignKeys(t.actions) : [];
    return crelt("li", {
        class: "cm-diagnostic cm-diagnostic-" + t.severity
    }, crelt("span", {
        class: "cm-diagnosticText"
    }, t.renderMessage ? t.renderMessage(e) : t.message), null === (o = t.actions) || void 0 === o ? void 0 : o.map(((n, o) => {
        let p = !1,
            click = o => {
                if (o.preventDefault(), p) return;
                p = !0;
                let h = findDiagnostic(e.state.field(Mo).diagnostics, t);
                h && n.apply(e, h.from, h.to)
            },
            {
                name: f
            } = n,
            g = h[o] ? f.indexOf(h[o]) : -1,
            y = g < 0 ? f : [f.slice(0, g), crelt("u", f.slice(g, g + 1)), f.slice(g + 1)];
        return crelt("button", {
            type: "button",
            class: "cm-diagnosticAction",
            onclick: click,
            onmousedown: click,
            "aria-label": ` Action: ${f}${g<0?"":` (access key "${h[o]})"`}.`
        }, y)
    })), t.source && crelt("div", {
        class: "cm-diagnosticSource"
    }, t.source))
}
class DiagnosticWidget extends WidgetType {
    constructor(e) {
        super(), this.diagnostic = e
    }
    eq(e) {
        return e.diagnostic == this.diagnostic
    }
    toDOM() {
        return crelt("span", {
            class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity
        })
    }
}
class PanelItem {
    constructor(e, t) {
        this.diagnostic = t, this.id = "item_" + Math.floor(4294967295 * Math.random()).toString(16), this.dom = renderDiagnostic(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option")
    }
}
class LintPanel {
    constructor(e) {
        this.view = e, this.items = [];
        this.list = crelt("ul", {
            tabIndex: 0,
            role: "listbox",
            "aria-label": this.view.state.phrase("Diagnostics"),
            onkeydown: t => {
                if (27 == t.keyCode) closeLintPanel(this.view), this.view.focus();
                else if (38 == t.keyCode || 33 == t.keyCode) this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
                else if (40 == t.keyCode || 34 == t.keyCode) this.moveSelection((this.selectedIndex + 1) % this.items.length);
                else if (36 == t.keyCode) this.moveSelection(0);
                else if (35 == t.keyCode) this.moveSelection(this.items.length - 1);
                else if (13 == t.keyCode) this.view.focus();
                else {
                    if (!(t.keyCode >= 65 && t.keyCode <= 90 && this.selectedIndex >= 0)) return; {
                        let {
                            diagnostic: n
                        } = this.items[this.selectedIndex], o = assignKeys(n.actions);
                        for (let h = 0; h < o.length; h++)
                            if (o[h].toUpperCase().charCodeAt(0) == t.keyCode) {
                                let t = findDiagnostic(this.view.state.field(Mo).diagnostics, n);
                                t && n.actions[h].apply(e, t.from, t.to)
                            }
                    }
                }
                t.preventDefault()
            },
            onclick: e => {
                for (let t = 0; t < this.items.length; t++) this.items[t].dom.contains(e.target) && this.moveSelection(t)
            }
        }), this.dom = crelt("div", {
            class: "cm-panel-lint"
        }, this.list, crelt("button", {
            type: "button",
            name: "close",
            "aria-label": this.view.state.phrase("close"),
            onclick: () => closeLintPanel(this.view)
        }, "Ã—")), this.update()
    }
    get selectedIndex() {
        let e = this.view.state.field(Mo).selected;
        if (!e) return -1;
        for (let t = 0; t < this.items.length; t++)
            if (this.items[t].diagnostic == e.diagnostic) return t;
        return -1
    }
    update() {
        let {
            diagnostics: e,
            selected: t
        } = this.view.state.field(Mo), n = 0, o = !1, h = null;
        for (e.between(0, this.view.state.doc.length, ((e, p, {
                spec: f
            }) => {
                let g, y = -1;
                for (let e = n; e < this.items.length; e++)
                    if (this.items[e].diagnostic == f.diagnostic) {
                        y = e;
                        break
                    }
                y < 0 ? (g = new PanelItem(this.view, f.diagnostic), this.items.splice(n, 0, g), o = !0) : (g = this.items[y], y > n && (this.items.splice(n, y - n), o = !0)), t && g.diagnostic == t.diagnostic ? g.dom.hasAttribute("aria-selected") || (g.dom.setAttribute("aria-selected", "true"), h = g) : g.dom.hasAttribute("aria-selected") && g.dom.removeAttribute("aria-selected"), n++
            })); n < this.items.length && !(1 == this.items.length && this.items[0].diagnostic.from < 0);) o = !0, this.items.pop();
        0 == this.items.length && (this.items.push(new PanelItem(this.view, {
            from: -1,
            to: -1,
            severity: "info",
            message: this.view.state.phrase("No diagnostics")
        })), o = !0), h ? (this.list.setAttribute("aria-activedescendant", h.id), this.view.requestMeasure({
            key: this,
            read: () => ({
                sel: h.dom.getBoundingClientRect(),
                panel: this.list.getBoundingClientRect()
            }),
            write: ({
                sel: e,
                panel: t
            }) => {
                let n = t.height / this.list.offsetHeight;
                e.top < t.top ? this.list.scrollTop -= (t.top - e.top) / n : e.bottom > t.bottom && (this.list.scrollTop += (e.bottom - t.bottom) / n)
            }
        })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), o && this.sync()
    }
    sync() {
        let e = this.list.firstChild;

        function rm() {
            let t = e;
            e = t.nextSibling, t.remove()
        }
        for (let t of this.items)
            if (t.dom.parentNode == this.list) {
                for (; e != t.dom;) rm();
                e = t.dom.nextSibling
            } else this.list.insertBefore(t.dom, e);
        for (; e;) rm()
    }
    moveSelection(e) {
        if (this.selectedIndex < 0) return;
        let t = findDiagnostic(this.view.state.field(Mo).diagnostics, this.items[e].diagnostic);
        t && this.view.dispatch({
            selection: {
                anchor: t.from,
                head: t.to
            },
            scrollIntoView: !0,
            effects: Ao.of(t)
        })
    }
    static open(e) {
        return new LintPanel(e)
    }
}

function svg(e, t = 'viewBox="0 0 40 40"') {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${t}>${encodeURIComponent(e)}</svg>')`
}

function underline(e) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${e}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"')
}
const Zo = EditorView.baseTheme({
    ".cm-diagnostic": {
        padding: "3px 6px 3px 8px",
        marginLeft: "-1px",
        display: "block",
        whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": {
        borderLeft: "5px solid #d11"
    },
    ".cm-diagnostic-warning": {
        borderLeft: "5px solid orange"
    },
    ".cm-diagnostic-info": {
        borderLeft: "5px solid #999"
    },
    ".cm-diagnostic-hint": {
        borderLeft: "5px solid #66d"
    },
    ".cm-diagnosticAction": {
        font: "inherit",
        border: "none",
        padding: "2px 4px",
        backgroundColor: "#444",
        color: "white",
        borderRadius: "3px",
        marginLeft: "8px",
        cursor: "pointer"
    },
    ".cm-diagnosticSource": {
        fontSize: "70%",
        opacity: .7
    },
    ".cm-lintRange": {
        backgroundPosition: "left bottom",
        backgroundRepeat: "repeat-x",
        paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": {
        backgroundImage: underline("#d11")
    },
    ".cm-lintRange-warning": {
        backgroundImage: underline("orange")
    },
    ".cm-lintRange-info": {
        backgroundImage: underline("#999")
    },
    ".cm-lintRange-hint": {
        backgroundImage: underline("#66d")
    },
    ".cm-lintRange-active": {
        backgroundColor: "#ffdd9980"
    },
    ".cm-tooltip-lint": {
        padding: 0,
        margin: 0
    },
    ".cm-lintPoint": {
        position: "relative",
        "&:after": {
            content: '""',
            position: "absolute",
            bottom: 0,
            left: "-2px",
            borderLeft: "3px solid transparent",
            borderRight: "3px solid transparent",
            borderBottom: "4px solid #d11"
        }
    },
    ".cm-lintPoint-warning": {
        "&:after": {
            borderBottomColor: "orange"
        }
    },
    ".cm-lintPoint-info": {
        "&:after": {
            borderBottomColor: "#999"
        }
    },
    ".cm-lintPoint-hint": {
        "&:after": {
            borderBottomColor: "#66d"
        }
    },
    ".cm-panel.cm-panel-lint": {
        position: "relative",
        "& ul": {
            maxHeight: "100px",
            overflowY: "auto",
            "& [aria-selected]": {
                backgroundColor: "#ddd",
                "& u": {
                    textDecoration: "underline"
                }
            },
            "&:focus [aria-selected]": {
                background_fallback: "#bdf",
                backgroundColor: "Highlight",
                color_fallback: "white",
                color: "HighlightText"
            },
            "& u": {
                textDecoration: "none"
            },
            padding: 0,
            margin: 0
        },
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "2px",
            background: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        }
    }
});

function severityWeight(e) {
    return "error" == e ? 4 : "warning" == e ? 3 : "info" == e ? 2 : 1
}
class LintGutterMarker extends GutterMarker {
    constructor(e) {
        super(), this.diagnostics = e, this.severity = e.reduce(((e, t) => severityWeight(e) < severityWeight(t.severity) ? t.severity : e), "hint")
    }
    toDOM(e) {
        let t = document.createElement("div");
        t.className = "cm-lint-marker cm-lint-marker-" + this.severity;
        let n = this.diagnostics,
            o = e.state.facet(No).tooltipFilter;
        return o && (n = o(n, e.state)), n.length && (t.onmouseover = () => function(e, t, n) {
            function hovered() {
                let o = e.elementAtHeight(t.getBoundingClientRect().top + 5 - e.documentTop);
                e.coordsAtPos(o.from) && e.dispatch({
                        effects: Io.of({
                            pos: o.from,
                            above: !1,
                            create: () => ({
                                dom: diagnosticsTooltip(e, n),
                                getCoords: () => t.getBoundingClientRect()
                            })
                        })
                    }), t.onmouseout = t.onmousemove = null,
                    function(e, t) {
                        let mousemove = n => {
                            let o = t.getBoundingClientRect();
                            if (!(n.clientX > o.left - 10 && n.clientX < o.right + 10 && n.clientY > o.top - 10 && n.clientY < o.bottom + 10)) {
                                for (let e = n.target; e; e = e.parentNode)
                                    if (1 == e.nodeType && e.classList.contains("cm-tooltip-lint")) return;
                                window.removeEventListener("mousemove", mousemove), e.state.field(Xo) && e.dispatch({
                                    effects: Io.of(null)
                                })
                            }
                        };
                        window.addEventListener("mousemove", mousemove)
                    }(e, t)
            }
            let {
                hoverTime: o
            } = e.state.facet(No), h = setTimeout(hovered, o);
            t.onmouseout = () => {
                clearTimeout(h), t.onmouseout = t.onmousemove = null
            }, t.onmousemove = () => {
                clearTimeout(h), h = setTimeout(hovered, o)
            }
        }(e, t, n)), t
    }
}

function markersForDiagnostics(e, t) {
    let n = Object.create(null);
    for (let o of t) {
        let t = e.lineAt(o.from);
        (n[t.from] || (n[t.from] = [])).push(o)
    }
    let o = [];
    for (let e in n) o.push(new LintGutterMarker(n[e]).range(+e));
    return RangeSet.of(o, !0)
}
const _o = gutter({
        class: "cm-gutter-lint",
        markers: e => e.state.field(Bo),
        widgetMarker: (e, t, n) => {
            let o = [];
            return e.state.field(Bo).between(n.from, n.to, ((e, t, n) => {
                o.push(...n.diagnostics)
            })), o.length ? new LintGutterMarker(o) : null
        }
    }),
    Bo = StateField.define({
        create: () => RangeSet.empty,
        update(e, t) {
            e = e.map(t.changes);
            let n = t.state.facet(No).markerFilter;
            for (let o of t.effects)
                if (o.is($o)) {
                    let h = o.value;
                    n && (h = n(h || [], t.state)), e = markersForDiagnostics(t.state.doc, h.slice(0))
                }
            return e
        }
    }),
    Io = StateEffect.define(),
    Xo = StateField.define({
        create: () => null,
        update: (e, t) => (e && t.docChanged && (e = hideTooltip(t, e) ? null : Object.assign(Object.assign({}, e), {
            pos: t.changes.mapPos(e.pos)
        })), t.effects.reduce(((e, t) => t.is(Io) ? t.value : e), e)),
        provide: e => an.from(e)
    }),
    qo = EditorView.baseTheme({
        ".cm-gutter-lint": {
            width: "1.4em",
            "& .cm-gutterElement": {
                padding: ".2em"
            }
        },
        ".cm-lint-marker": {
            width: "1em",
            height: "1em"
        },
        ".cm-lint-marker-info": {
            content: svg('<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>')
        },
        ".cm-lint-marker-warning": {
            content: svg('<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>')
        },
        ".cm-lint-marker-error": {
            content: svg('<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>')
        }
    }),
    zo = [Mo, EditorView.decorations.compute([Mo], (e => {
        let {
            selected: t,
            panel: n
        } = e.field(Mo);
        return t && n && t.from != t.to ? Decoration.set([Ro.range(t.from, t.to)]) : Decoration.none
    })), hoverTooltip(lintTooltip, {
        hideOn: hideTooltip
    }), Zo],
    No = Facet.define({
        combine: e => combineConfig(e, {
            hoverTime: 300,
            markerFilter: null,
            tooltipFilter: null
        })
    });

function lintGutter(e = {}) {
    return [No.of(e), Bo, _o, qo, Xo]
}
class Stack {
    constructor(e, t, n, o, h, p, f, g, y, w = 0, b) {
        this.p = e, this.stack = t, this.state = n, this.reducePos = o, this.pos = h, this.score = p, this.buffer = f, this.bufferBase = g, this.curContext = y, this.lookAhead = w, this.parent = b
    }
    toString() {
        return `[${this.stack.filter(((e,t)=>t%3==0)).concat(this.state)}]@${this.pos}${this.score?"!"+this.score:""}`
    }
    static start(e, t, n = 0) {
        let o = e.parser.context;
        return new Stack(e, [], t, n, n, 0, [], 0, o ? new StackContext(o, o.start) : null, 0, null)
    }
    get context() {
        return this.curContext ? this.curContext.context : null
    }
    pushState(e, t) {
        this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e
    }
    reduce(e) {
        var t;
        let n = e >> 19,
            o = 65535 & e,
            {
                parser: h
            } = this.p,
            p = this.reducePos < this.pos - 25;
        p && this.setLookAhead(this.pos);
        let f = h.dynamicPrecedence(o);
        if (f && (this.score += f), 0 == n) return this.pushState(h.getGoto(this.state, o, !0), this.reducePos), o < h.minRepeatTerm && this.storeNode(o, this.reducePos, this.reducePos, p ? 8 : 4, !0), void this.reduceContext(o, this.reducePos);
        let g = this.stack.length - 3 * (n - 1) - (262144 & e ? 6 : 0),
            y = g ? this.stack[g - 2] : this.p.ranges[0].from,
            w = this.reducePos - y;
        w >= 2e3 && !(null === (t = this.p.parser.nodeSet.types[o]) || void 0 === t ? void 0 : t.isAnonymous) && (y == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = w) : this.p.lastBigReductionSize < w && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = y, this.p.lastBigReductionSize = w));
        let b = g ? this.stack[g - 1] : 0,
            S = this.bufferBase + this.buffer.length - b;
        if (o < h.minRepeatTerm || 131072 & e) {
            let e = h.stateFlag(this.state, 1) ? this.pos : this.reducePos;
            this.storeNode(o, y, e, S + 4, !0)
        }
        if (262144 & e) this.state = this.stack[g];
        else {
            let e = this.stack[g - 3];
            this.state = h.getGoto(e, o, !0)
        }
        for (; this.stack.length > g;) this.stack.pop();
        this.reduceContext(o, y)
    }
    storeNode(e, t, n, o = 4, h = !1) {
        if (0 == e && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
            let e = this,
                o = this.buffer.length;
            if (0 == o && e.parent && (o = e.bufferBase - e.parent.bufferBase, e = e.parent), o > 0 && 0 == e.buffer[o - 4] && e.buffer[o - 1] > -1) {
                if (t == n) return;
                if (e.buffer[o - 2] >= t) return void(e.buffer[o - 2] = n)
            }
        }
        if (h && this.pos != n) {
            let h = this.buffer.length;
            if (h > 0 && 0 != this.buffer[h - 4]) {
                let e = !1;
                for (let t = h; t > 0 && this.buffer[t - 2] > n; t -= 4)
                    if (this.buffer[t - 1] >= 0) {
                        e = !0;
                        break
                    }
                if (e)
                    for (; h > 0 && this.buffer[h - 2] > n;) this.buffer[h] = this.buffer[h - 4], this.buffer[h + 1] = this.buffer[h - 3], this.buffer[h + 2] = this.buffer[h - 2], this.buffer[h + 3] = this.buffer[h - 1], h -= 4, o > 4 && (o -= 4)
            }
            this.buffer[h] = e, this.buffer[h + 1] = t, this.buffer[h + 2] = n, this.buffer[h + 3] = o
        } else this.buffer.push(e, t, n, o)
    }
    shift(e, t, n, o) {
        if (131072 & e) this.pushState(65535 & e, this.pos);
        else if (262144 & e) this.pos = o, this.shiftContext(t, n), t <= this.p.parser.maxNode && this.buffer.push(t, n, o, 4);
        else {
            let h = e,
                {
                    parser: p
                } = this.p;
            (o > this.pos || t <= p.maxNode) && (this.pos = o, p.stateFlag(h, 1) || (this.reducePos = o)), this.pushState(h, n), this.shiftContext(t, n), t <= p.maxNode && this.buffer.push(t, n, o, 4)
        }
    }
    apply(e, t, n, o) {
        65536 & e ? this.reduce(e) : this.shift(e, t, n, o)
    }
    useNode(e, t) {
        let n = this.p.reused.length - 1;
        (n < 0 || this.p.reused[n] != e) && (this.p.reused.push(e), n++);
        let o = this.pos;
        this.reducePos = this.pos = o + e.length, this.pushState(t, o), this.buffer.push(n, o, this.reducePos, -1), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)))
    }
    split() {
        let e = this,
            t = e.buffer.length;
        for (; t > 0 && e.buffer[t - 2] > e.reducePos;) t -= 4;
        let n = e.buffer.slice(t),
            o = e.bufferBase + t;
        for (; e && o == e.bufferBase;) e = e.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, n, o, this.curContext, this.lookAhead, e)
    }
    recoverByDelete(e, t) {
        let n = e <= this.p.parser.maxNode;
        n && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, n ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190
    }
    canShift(e) {
        for (let t = new SimulatedStack(this);;) {
            let n = this.p.parser.stateSlot(t.state, 4) || this.p.parser.hasAction(t.state, e);
            if (0 == n) return !1;
            if (!(65536 & n)) return !0;
            t.reduce(n)
        }
    }
    recoverByInsert(e) {
        if (this.stack.length >= 300) return [];
        let t = this.p.parser.nextStates(this.state);
        if (t.length > 8 || this.stack.length >= 120) {
            let n = [];
            for (let o, h = 0; h < t.length; h += 2)(o = t[h + 1]) != this.state && this.p.parser.hasAction(o, e) && n.push(t[h], o);
            if (this.stack.length < 120)
                for (let e = 0; n.length < 8 && e < t.length; e += 2) {
                    let o = t[e + 1];
                    n.some(((e, t) => 1 & t && e == o)) || n.push(t[e], o)
                }
            t = n
        }
        let n = [];
        for (let e = 0; e < t.length && n.length < 4; e += 2) {
            let o = t[e + 1];
            if (o == this.state) continue;
            let h = this.split();
            h.pushState(o, this.pos), h.storeNode(0, h.pos, h.pos, 4, !0), h.shiftContext(t[e], this.pos), h.reducePos = this.pos, h.score -= 200, n.push(h)
        }
        return n
    }
    forceReduce() {
        let {
            parser: e
        } = this.p, t = e.stateSlot(this.state, 5);
        if (!(65536 & t)) return !1;
        if (!e.validAction(this.state, t)) {
            let n = t >> 19,
                o = 65535 & t,
                h = this.stack.length - 3 * n;
            if (h < 0 || e.getGoto(this.stack[h], o, !1) < 0) {
                let e = this.findForcedReduction();
                if (null == e) return !1;
                t = e
            }
            this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100
        }
        return this.reducePos = this.pos, this.reduce(t), !0
    }
    findForcedReduction() {
        let {
            parser: e
        } = this.p, t = [], explore = (n, o) => {
            if (!t.includes(n)) return t.push(n), e.allActions(n, (t => {
                if (393216 & t);
                else if (65536 & t) {
                    let n = (t >> 19) - o;
                    if (n > 1) {
                        let o = 65535 & t,
                            h = this.stack.length - 3 * n;
                        if (h >= 0 && e.getGoto(this.stack[h], o, !1) >= 0) return n << 19 | 65536 | o
                    }
                } else {
                    let e = explore(t, o + 1);
                    if (null != e) return e
                }
            }))
        };
        return explore(this.state, 0)
    }
    forceAll() {
        for (; !this.p.parser.stateFlag(this.state, 2);)
            if (!this.forceReduce()) {
                this.storeNode(0, this.pos, this.pos, 4, !0);
                break
            }
        return this
    }
    get deadEnd() {
        if (3 != this.stack.length) return !1;
        let {
            parser: e
        } = this.p;
        return 65535 == e.data[e.stateSlot(this.state, 1)] && !e.stateSlot(this.state, 4)
    }
    restart() {
        this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0
    }
    sameState(e) {
        if (this.state != e.state || this.stack.length != e.stack.length) return !1;
        for (let t = 0; t < this.stack.length; t += 3)
            if (this.stack[t] != e.stack[t]) return !1;
        return !0
    }
    get parser() {
        return this.p.parser
    }
    dialectEnabled(e) {
        return this.p.parser.dialect.flags[e]
    }
    shiftContext(e, t) {
        this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)))
    }
    reduceContext(e, t) {
        this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)))
    }
    emitContext() {
        let e = this.buffer.length - 1;
        (e < 0 || -3 != this.buffer[e]) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3)
    }
    emitLookAhead() {
        let e = this.buffer.length - 1;
        (e < 0 || -4 != this.buffer[e]) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4)
    }
    updateContext(e) {
        if (e != this.curContext.context) {
            let t = new StackContext(this.curContext.tracker, e);
            t.hash != this.curContext.hash && this.emitContext(), this.curContext = t
        }
    }
    setLookAhead(e) {
        e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e)
    }
    close() {
        this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead()
    }
}
class StackContext {
    constructor(e, t) {
        this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0
    }
}
class SimulatedStack {
    constructor(e) {
        this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length
    }
    reduce(e) {
        let t = 65535 & e,
            n = e >> 19;
        0 == n ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= 3 * (n - 1);
        let o = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
        this.state = o
    }
}
class StackBufferCursor {
    constructor(e, t, n) {
        this.stack = e, this.pos = t, this.index = n, this.buffer = e.buffer, 0 == this.index && this.maybeNext()
    }
    static create(e, t = e.bufferBase + e.buffer.length) {
        return new StackBufferCursor(e, t, t - e.bufferBase)
    }
    maybeNext() {
        let e = this.stack.parent;
        null != e && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer)
    }
    get id() {
        return this.buffer[this.index - 4]
    }
    get start() {
        return this.buffer[this.index - 3]
    }
    get end() {
        return this.buffer[this.index - 2]
    }
    get size() {
        return this.buffer[this.index - 1]
    }
    next() {
        this.index -= 4, this.pos -= 4, 0 == this.index && this.maybeNext()
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index)
    }
}

function decodeArray(e, t = Uint16Array) {
    if ("string" != typeof e) return e;
    let n = null;
    for (let o = 0, h = 0; o < e.length;) {
        let p = 0;
        for (;;) {
            let t = e.charCodeAt(o++),
                n = !1;
            if (126 == t) {
                p = 65535;
                break
            }
            t >= 92 && t--, t >= 34 && t--;
            let h = t - 32;
            if (h >= 46 && (h -= 46, n = !0), p += h, n) break;
            p *= 46
        }
        n ? n[h++] = p : n = new t(p)
    }
    return n
}
class CachedToken {
    constructor() {
        this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0
    }
}
const Yo = new CachedToken;
class InputStream {
    constructor(e, t) {
        this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = Yo, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext()
    }
    resolveOffset(e, t) {
        let n = this.range,
            o = this.rangeIndex,
            h = this.pos + e;
        for (; h < n.from;) {
            if (!o) return null;
            let e = this.ranges[--o];
            h -= n.from - e.to, n = e
        }
        for (; t < 0 ? h > n.to : h >= n.to;) {
            if (o == this.ranges.length - 1) return null;
            let e = this.ranges[++o];
            h += e.from - n.to, n = e
        }
        return h
    }
    clipPos(e) {
        if (e >= this.range.from && e < this.range.to) return e;
        for (let t of this.ranges)
            if (t.to > e) return Math.max(e, t.from);
        return this.end
    }
    peek(e) {
        let t, n, o = this.chunkOff + e;
        if (o >= 0 && o < this.chunk.length) t = this.pos + e, n = this.chunk.charCodeAt(o);
        else {
            let o = this.resolveOffset(e, 1);
            if (null == o) return -1;
            if (t = o, t >= this.chunk2Pos && t < this.chunk2Pos + this.chunk2.length) n = this.chunk2.charCodeAt(t - this.chunk2Pos);
            else {
                let e = this.rangeIndex,
                    o = this.range;
                for (; o.to <= t;) o = this.ranges[++e];
                this.chunk2 = this.input.chunk(this.chunk2Pos = t), t + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - t)), n = this.chunk2.charCodeAt(0)
            }
        }
        return t >= this.token.lookAhead && (this.token.lookAhead = t + 1), n
    }
    acceptToken(e, t = 0) {
        let n = t ? this.resolveOffset(t, -1) : this.pos;
        if (null == n || n < this.token.start) throw new RangeError("Token end out of bounds");
        this.token.value = e, this.token.end = n
    }
    acceptTokenTo(e, t) {
        this.token.value = e, this.token.end = t
    }
    getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let {
                chunk: e,
                chunkPos: t
            } = this;
            this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos
        } else {
            this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
            let e = this.input.chunk(this.pos),
                t = this.pos + e.length;
            this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0
        }
    }
    readNext() {
        return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff)
    }
    advance(e = 1) {
        for (this.chunkOff += e; this.pos + e >= this.range.to;) {
            if (this.rangeIndex == this.ranges.length - 1) return this.setDone();
            e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from
        }
        return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext()
    }
    setDone() {
        return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1
    }
    reset(e, t) {
        if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = Yo, this.pos != e) {
            if (this.pos = e, e == this.end) return this.setDone(), this;
            for (; e < this.range.from;) this.range = this.ranges[--this.rangeIndex];
            for (; e >= this.range.to;) this.range = this.ranges[++this.rangeIndex];
            e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext()
        }
        return this
    }
    read(e, t) {
        if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length) return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
        if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
        if (e >= this.range.from && t <= this.range.to) return this.input.read(e, t);
        let n = "";
        for (let o of this.ranges) {
            if (o.from >= t) break;
            o.to > e && (n += this.input.read(Math.max(o.from, e), Math.min(o.to, t)))
        }
        return n
    }
}
class TokenGroup {
    constructor(e, t) {
        this.data = e, this.id = t
    }
    token(e, t) {
        let {
            parser: n
        } = t.p;
        readToken(this.data, e, t, this.id, n.data, n.tokenPrecTable)
    }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = !1;
class LocalTokenGroup {
    constructor(e, t, n) {
        this.precTable = t, this.elseToken = n, this.data = "string" == typeof e ? decodeArray(e) : e
    }
    token(e, t) {
        let n = e.pos,
            o = 0;
        for (;;) {
            let n = e.next < 0,
                h = e.resolveOffset(1, 1);
            if (readToken(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1) break;
            if (null == this.elseToken) return;
            if (n || o++, null == h) break;
            e.reset(h, e.token)
        }
        o && (e.reset(n, e.token), e.acceptToken(this.elseToken, o))
    }
}
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = !1;
class ExternalTokenizer {
    constructor(e, t = {}) {
        this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend
    }
}

function readToken(e, t, n, o, h, p) {
    let f = 0,
        g = 1 << o,
        {
            dialect: y
        } = n.p.parser;
    e: for (; g & e[f];) {
        let n = e[f + 1];
        for (let o = f + 3; o < n; o += 2)
            if ((e[o + 1] & g) > 0) {
                let n = e[o];
                if (y.allows(n) && (-1 == t.token.value || t.token.value == n || overrides(n, t.token.value, h, p))) {
                    t.acceptToken(n);
                    break
                }
            }
        let o = t.next,
            w = 0,
            b = e[f + 2];
        if (!(t.next < 0 && b > w && 65535 == e[n + 3 * b - 3])) {
            for (; w < b;) {
                let h = w + b >> 1,
                    p = n + h + (h << 1),
                    g = e[p],
                    y = e[p + 1] || 65536;
                if (o < g) b = h;
                else {
                    if (!(o >= y)) {
                        f = e[p + 2], t.advance();
                        continue e
                    }
                    w = h + 1
                }
            }
            break
        }
        f = e[n + 3 * b - 1]
    }
}

function findOffset(e, t, n) {
    for (let o, h = t; 65535 != (o = e[h]); h++)
        if (o == n) return h - t;
    return -1
}

function overrides(e, t, n, o) {
    let h = findOffset(n, o, t);
    return h < 0 || findOffset(n, o, e) < h
}
const jo = "undefined" != typeof process && process.env && /\bparse\b/.test(process.env.LOG);
let Wo = null;

function cutAt(e, t, n) {
    let o = e.cursor(Bn.IncludeAnonymous);
    for (o.moveTo(t);;)
        if (!(n < 0 ? o.childBefore(t) : o.childAfter(t)))
            for (;;) {
                if ((n < 0 ? o.to < t : o.from > t) && !o.type.isError) return n < 0 ? Math.max(0, Math.min(o.to - 1, t - 25)) : Math.min(e.length, Math.max(o.from + 1, t + 25));
                if (n < 0 ? o.prevSibling() : o.nextSibling()) break;
                if (!o.parent()) return n < 0 ? 0 : e.length
            }
}
let Uo = class {
    constructor(e, t) {
        this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment()
    }
    nextFragment() {
        let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (e) {
            for (this.safeFrom = e.openStart ? cutAt(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? cutAt(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length;) this.trees.pop(), this.start.pop(), this.index.pop();
            this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom
        } else this.nextStart = 1e9
    }
    nodeAt(e) {
        if (e < this.nextStart) return null;
        for (; this.fragment && this.safeTo <= e;) this.nextFragment();
        if (!this.fragment) return null;
        for (;;) {
            let t = this.trees.length - 1;
            if (t < 0) return this.nextFragment(), null;
            let n = this.trees[t],
                o = this.index[t];
            if (o == n.children.length) {
                this.trees.pop(), this.start.pop(), this.index.pop();
                continue
            }
            let h = n.children[o],
                p = this.start[t] + n.positions[o];
            if (p > e) return this.nextStart = p, null;
            if (h instanceof Tree) {
                if (p == e) {
                    if (p < this.safeFrom) return null;
                    let e = p + h.length;
                    if (e <= this.safeTo) {
                        let t = h.prop(NodeProp.lookAhead);
                        if (!t || e + t < this.fragment.to) return h
                    }
                }
                this.index[t]++, p + h.length >= Math.max(this.safeFrom, e) && (this.trees.push(h), this.start.push(p), this.index.push(0))
            } else this.index[t]++, this.nextStart = p + h.length
        }
    }
};
class TokenCache {
    constructor(e, t) {
        this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((e => new CachedToken))
    }
    getActions(e) {
        let t = 0,
            n = null,
            {
                parser: o
            } = e.p,
            {
                tokenizers: h
            } = o,
            p = o.stateSlot(e.state, 3),
            f = e.curContext ? e.curContext.hash : 0,
            g = 0;
        for (let o = 0; o < h.length; o++) {
            if (!(1 << o & p)) continue;
            let y = h[o],
                w = this.tokens[o];
            if ((!n || y.fallback) && ((y.contextual || w.start != e.pos || w.mask != p || w.context != f) && (this.updateCachedToken(w, y, e), w.mask = p, w.context = f), w.lookAhead > w.end + 25 && (g = Math.max(w.lookAhead, g)), 0 != w.value)) {
                let o = t;
                if (w.extended > -1 && (t = this.addActions(e, w.extended, w.end, t)), t = this.addActions(e, w.value, w.end, t), !y.extend && (n = w, t > o)) break
            }
        }
        for (; this.actions.length > t;) this.actions.pop();
        return g && e.setLookAhead(g), n || e.pos != this.stream.end || (n = new CachedToken, n.value = e.p.parser.eofTerm, n.start = n.end = e.pos, t = this.addActions(e, n.value, n.end, t)), this.mainToken = n, this.actions
    }
    getMainToken(e) {
        if (this.mainToken) return this.mainToken;
        let t = new CachedToken,
            {
                pos: n,
                p: o
            } = e;
        return t.start = n, t.end = Math.min(n + 1, o.stream.end), t.value = n == o.stream.end ? o.parser.eofTerm : 0, t
    }
    updateCachedToken(e, t, n) {
        let o = this.stream.clipPos(n.pos);
        if (t.token(this.stream.reset(o, e), n), e.value > -1) {
            let {
                parser: t
            } = n.p;
            for (let o = 0; o < t.specialized.length; o++)
                if (t.specialized[o] == e.value) {
                    let h = t.specializers[o](this.stream.read(e.start, e.end), n);
                    if (h >= 0 && n.p.parser.dialect.allows(h >> 1)) {
                        1 & h ? e.extended = h >> 1 : e.value = h >> 1;
                        break
                    }
                }
        } else e.value = 0, e.end = this.stream.clipPos(o + 1)
    }
    putAction(e, t, n, o) {
        for (let t = 0; t < o; t += 3)
            if (this.actions[t] == e) return o;
        return this.actions[o++] = e, this.actions[o++] = t, this.actions[o++] = n, o
    }
    addActions(e, t, n, o) {
        let {
            state: h
        } = e, {
            parser: p
        } = e.p, {
            data: f
        } = p;
        for (let e = 0; e < 2; e++)
            for (let g = p.stateSlot(h, e ? 2 : 1);; g += 3) {
                if (65535 == f[g]) {
                    if (1 != f[g + 1]) {
                        0 == o && 2 == f[g + 1] && (o = this.putAction(pair(f, g + 2), t, n, o));
                        break
                    }
                    g = pair(f, g + 2)
                }
                f[g] == t && (o = this.putAction(pair(f, g + 1), t, n, o))
            }
        return o
    }
}
class Parse {
    constructor(e, t, n, o) {
        this.parser = e, this.input = t, this.ranges = o, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new InputStream(t, o), this.tokens = new TokenCache(e, this.stream), this.topTerm = e.top[1];
        let {
            from: h
        } = o[0];
        this.stacks = [Stack.start(this, e.top[0], h)], this.fragments = n.length && this.stream.end - h > 4 * e.bufferLength ? new Uo(n, e.nodeSet) : null
    }
    get parsedPos() {
        return this.minStackPos
    }
    advance() {
        let e, t, n = this.stacks,
            o = this.minStackPos,
            h = this.stacks = [];
        if (this.bigReductionCount > 300 && 1 == n.length) {
            let [e] = n;
            for (; e.forceReduce() && e.stack.length && e.stack[e.stack.length - 2] >= this.lastBigReductionStart;);
            this.bigReductionCount = this.lastBigReductionSize = 0
        }
        for (let p = 0; p < n.length; p++) {
            let f = n[p];
            for (;;) {
                if (this.tokens.mainToken = null, f.pos > o) h.push(f);
                else {
                    if (this.advanceStack(f, h, n)) continue; {
                        e || (e = [], t = []), e.push(f);
                        let n = this.tokens.getMainToken(f);
                        t.push(n.value, n.end)
                    }
                }
                break
            }
        }
        if (!h.length) {
            let t = e && function(e) {
                let t = null;
                for (let n of e) {
                    let e = n.p.stoppedAt;
                    (n.pos == n.p.stream.end || null != e && n.pos > e) && n.p.parser.stateFlag(n.state, 2) && (!t || t.score < n.score) && (t = n)
                }
                return t
            }(e);
            if (t) return jo && console.log("Finish with " + this.stackID(t)), this.stackToTree(t);
            if (this.parser.strict) throw jo && e && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + o);
            this.recovering || (this.recovering = 5)
        }
        if (this.recovering && e) {
            let n = null != this.stoppedAt && e[0].pos > this.stoppedAt ? e[0] : this.runRecovery(e, t, h);
            if (n) return jo && console.log("Force-finish " + this.stackID(n)), this.stackToTree(n.forceAll())
        }
        if (this.recovering) {
            let e = 1 == this.recovering ? 1 : 3 * this.recovering;
            if (h.length > e)
                for (h.sort(((e, t) => t.score - e.score)); h.length > e;) h.pop();
            h.some((e => e.reducePos > o)) && this.recovering--
        } else if (h.length > 1) {
            e: for (let e = 0; e < h.length - 1; e++) {
                let t = h[e];
                for (let n = e + 1; n < h.length; n++) {
                    let o = h[n];
                    if (t.sameState(o) || t.buffer.length > 500 && o.buffer.length > 500) {
                        if (!((t.score - o.score || t.buffer.length - o.buffer.length) > 0)) {
                            h.splice(e--, 1);
                            continue e
                        }
                        h.splice(n--, 1)
                    }
                }
            }
            h.length > 12 && h.splice(12, h.length - 12)
        }
        this.minStackPos = h[0].pos;
        for (let e = 1; e < h.length; e++) h[e].pos < this.minStackPos && (this.minStackPos = h[e].pos);
        return null
    }
    stopAt(e) {
        if (null != this.stoppedAt && this.stoppedAt < e) throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = e
    }
    advanceStack(e, t, n) {
        let o = e.pos,
            {
                parser: h
            } = this,
            p = jo ? this.stackID(e) + " -> " : "";
        if (null != this.stoppedAt && o > this.stoppedAt) return e.forceReduce() ? e : null;
        if (this.fragments) {
            let t = e.curContext && e.curContext.tracker.strict,
                n = t ? e.curContext.hash : 0;
            for (let f = this.fragments.nodeAt(o); f;) {
                let o = this.parser.nodeSet.types[f.type.id] == f.type ? h.getGoto(e.state, f.type.id) : -1;
                if (o > -1 && f.length && (!t || (f.prop(NodeProp.contextHash) || 0) == n)) return e.useNode(f, o), jo && console.log(p + this.stackID(e) + ` (via reuse of ${h.getName(f.type.id)})`), !0;
                if (!(f instanceof Tree) || 0 == f.children.length || f.positions[0] > 0) break;
                let g = f.children[0];
                if (!(g instanceof Tree && 0 == f.positions[0])) break;
                f = g
            }
        }
        let f = h.stateSlot(e.state, 4);
        if (f > 0) return e.reduce(f), jo && console.log(p + this.stackID(e) + ` (via always-reduce ${h.getName(65535&f)})`), !0;
        if (e.stack.length >= 8400)
            for (; e.stack.length > 6e3 && e.forceReduce(););
        let g = this.tokens.getActions(e);
        for (let f = 0; f < g.length;) {
            let y = g[f++],
                w = g[f++],
                b = g[f++],
                S = f == g.length || !n,
                k = S ? e : e.split(),
                v = this.tokens.mainToken;
            if (k.apply(y, w, v ? v.start : k.pos, b), jo && console.log(p + this.stackID(k) + ` (via ${65536&y?`reduce of ${h.getName(65535&y)}`:"shift"} for ${h.getName(w)} @ ${o}${k==e?"":", split"})`), S) return !0;
            k.pos > o ? t.push(k) : n.push(k)
        }
        return !1
    }
    advanceFully(e, t) {
        let n = e.pos;
        for (;;) {
            if (!this.advanceStack(e, null, null)) return !1;
            if (e.pos > n) return pushStackDedup(e, t), !0
        }
    }
    runRecovery(e, t, n) {
        let o = null,
            h = !1;
        for (let p = 0; p < e.length; p++) {
            let f = e[p],
                g = t[p << 1],
                y = t[1 + (p << 1)],
                w = jo ? this.stackID(f) + " -> " : "";
            if (f.deadEnd) {
                if (h) continue;
                if (h = !0, f.restart(), jo && console.log(w + this.stackID(f) + " (restarted)"), this.advanceFully(f, n)) continue
            }
            let b = f.split(),
                S = w;
            for (let e = 0; b.forceReduce() && e < 10; e++) {
                if (jo && console.log(S + this.stackID(b) + " (via force-reduce)"), this.advanceFully(b, n)) break;
                jo && (S = this.stackID(b) + " -> ")
            }
            for (let e of f.recoverByInsert(g)) jo && console.log(w + this.stackID(e) + " (via recover-insert)"), this.advanceFully(e, n);
            this.stream.end > f.pos ? (y == f.pos && (y++, g = 0), f.recoverByDelete(g, y), jo && console.log(w + this.stackID(f) + ` (via recover-delete ${this.parser.getName(g)})`), pushStackDedup(f, n)) : (!o || o.score < f.score) && (o = f)
        }
        return o
    }
    stackToTree(e) {
        return e.close(), Tree.build({
            buffer: StackBufferCursor.create(e),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: e.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm
        })
    }
    stackID(e) {
        let t = (Wo || (Wo = new WeakMap)).get(e);
        return t || Wo.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e
    }
}

function pushStackDedup(e, t) {
    for (let n = 0; n < t.length; n++) {
        let o = t[n];
        if (o.pos == e.pos && o.sameState(e)) return void(t[n].score < e.score && (t[n] = e))
    }
    t.push(e)
}
class Dialect {
    constructor(e, t, n) {
        this.source = e, this.flags = t, this.disabled = n
    }
    allows(e) {
        return !this.disabled || 0 == this.disabled[e]
    }
}
const id$1 = e => e;
class ContextTracker {
    constructor(e) {
        this.start = e.start, this.shift = e.shift || id$1, this.reduce = e.reduce || id$1, this.reuse = e.reuse || id$1, this.hash = e.hash || (() => 0), this.strict = !1 !== e.strict
    }
}
class LRParser extends Parser {
    constructor(e) {
        if (super(), this.wrappers = [], 14 != e.version) throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
        let t = e.nodeNames.split(" ");
        this.minRepeatTerm = t.length;
        for (let n = 0; n < e.repeatNodeCount; n++) t.push("");
        let n = Object.keys(e.topRules).map((t => e.topRules[t][1])),
            o = [];
        for (let e = 0; e < t.length; e++) o.push([]);

        function setProp(e, t, n) {
            o[e].push([t, t.deserialize(String(n))])
        }
        if (e.nodeProps)
            for (let t of e.nodeProps) {
                let e = t[0];
                "string" == typeof e && (e = NodeProp[e]);
                for (let n = 1; n < t.length;) {
                    let o = t[n++];
                    if (o >= 0) setProp(o, e, t[n++]);
                    else {
                        let h = t[n + -o];
                        for (let p = -o; p > 0; p--) setProp(t[n++], e, h);
                        n++
                    }
                }
            }
        this.nodeSet = new NodeSet(t.map(((t, h) => NodeType.define({
            name: h >= this.minRepeatTerm ? void 0 : t,
            id: h,
            props: o[h],
            top: n.indexOf(h) > -1,
            error: 0 == h,
            skipped: e.skippedNodes && e.skippedNodes.indexOf(h) > -1
        })))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = Dn;
        let h = decodeArray(e.tokenData);
        this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
        for (let e = 0; e < this.specializerSpecs.length; e++) this.specialized[e] = this.specializerSpecs[e].term;
        this.specializers = this.specializerSpecs.map(getSpecializer), this.states = decodeArray(e.states, Uint32Array), this.data = decodeArray(e.stateData), this.goto = decodeArray(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((e => "number" == typeof e ? new TokenGroup(h, e) : e)), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]]
    }
    createParse(e, t, n) {
        let o = new Parse(this, e, t, n);
        for (let h of this.wrappers) o = h(o, e, t, n);
        return o
    }
    getGoto(e, t, n = !1) {
        let o = this.goto;
        if (t >= o[0]) return -1;
        for (let h = o[t + 1];;) {
            let t = o[h++],
                p = 1 & t,
                f = o[h++];
            if (p && n) return f;
            for (let n = h + (t >> 1); h < n; h++)
                if (o[h] == e) return f;
            if (p) return -1
        }
    }
    hasAction(e, t) {
        let n = this.data;
        for (let o = 0; o < 2; o++)
            for (let h, p = this.stateSlot(e, o ? 2 : 1);; p += 3) {
                if (65535 == (h = n[p])) {
                    if (1 != n[p + 1]) {
                        if (2 == n[p + 1]) return pair(n, p + 2);
                        break
                    }
                    h = n[p = pair(n, p + 2)]
                }
                if (h == t || 0 == h) return pair(n, p + 1)
            }
        return 0
    }
    stateSlot(e, t) {
        return this.states[6 * e + t]
    }
    stateFlag(e, t) {
        return (this.stateSlot(e, 0) & t) > 0
    }
    validAction(e, t) {
        return !!this.allActions(e, (e => e == t || null))
    }
    allActions(e, t) {
        let n = this.stateSlot(e, 4),
            o = n ? t(n) : void 0;
        for (let n = this.stateSlot(e, 1); null == o; n += 3) {
            if (65535 == this.data[n]) {
                if (1 != this.data[n + 1]) break;
                n = pair(this.data, n + 2)
            }
            o = t(pair(this.data, n + 1))
        }
        return o
    }
    nextStates(e) {
        let t = [];
        for (let n = this.stateSlot(e, 1);; n += 3) {
            if (65535 == this.data[n]) {
                if (1 != this.data[n + 1]) break;
                n = pair(this.data, n + 2)
            }
            if (!(1 & this.data[n + 2])) {
                let e = this.data[n + 1];
                t.some(((t, n) => 1 & n && t == e)) || t.push(this.data[n], e)
            }
        }
        return t
    }
    configure(e) {
        let t = Object.assign(Object.create(LRParser.prototype), this);
        if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
            let n = this.topRules[e.top];
            if (!n) throw new RangeError(`Invalid top rule name ${e.top}`);
            t.top = n
        }
        return e.tokenizers && (t.tokenizers = this.tokenizers.map((t => {
            let n = e.tokenizers.find((e => e.from == t));
            return n ? n.to : t
        }))), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map(((n, o) => {
            let h = e.specializers.find((e => e.from == n.external));
            if (!h) return n;
            let p = Object.assign(Object.assign({}, n), {
                external: h.to
            });
            return t.specializers[o] = getSpecializer(p), p
        }))), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), null != e.strict && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), null != e.bufferLength && (t.bufferLength = e.bufferLength), t
    }
    hasWrappers() {
        return this.wrappers.length > 0
    }
    getName(e) {
        return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e)
    }
    get eofTerm() {
        return this.maxNode + 1
    }
    get topNode() {
        return this.nodeSet.types[this.top[1]]
    }
    dynamicPrecedence(e) {
        let t = this.dynamicPrecedences;
        return null == t ? 0 : t[e] || 0
    }
    parseDialect(e) {
        let t = Object.keys(this.dialects),
            n = t.map((() => !1));
        if (e)
            for (let o of e.split(" ")) {
                let e = t.indexOf(o);
                e >= 0 && (n[e] = !0)
            }
        let o = null;
        for (let e = 0; e < t.length; e++)
            if (!n[e])
                for (let n, h = this.dialects[t[e]]; 65535 != (n = this.data[h++]);)(o || (o = new Uint8Array(this.maxTerm + 1)))[n] = 1;
        return new Dialect(e, n, o)
    }
    static deserialize(e) {
        return new LRParser(e)
    }
}

function pair(e, t) {
    return e[t] | e[t + 1] << 16
}

function getSpecializer(e) {
    if (e.external) {
        let t = e.extend ? 1 : 0;
        return (n, o) => e.external(n, o) << 1 | t
    }
    return e.get
}
const Fo = {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        command: !0,
        embed: !0,
        frame: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0,
        menuitem: !0
    },
    Go = {
        dd: !0,
        li: !0,
        optgroup: !0,
        option: !0,
        p: !0,
        rp: !0,
        rt: !0,
        tbody: !0,
        td: !0,
        tfoot: !0,
        th: !0,
        tr: !0
    },
    Ho = {
        dd: {
            dd: !0,
            dt: !0
        },
        dt: {
            dd: !0,
            dt: !0
        },
        li: {
            li: !0
        },
        option: {
            option: !0,
            optgroup: !0
        },
        optgroup: {
            optgroup: !0
        },
        p: {
            address: !0,
            article: !0,
            aside: !0,
            blockquote: !0,
            dir: !0,
            div: !0,
            dl: !0,
            fieldset: !0,
            footer: !0,
            form: !0,
            h1: !0,
            h2: !0,
            h3: !0,
            h4: !0,
            h5: !0,
            h6: !0,
            header: !0,
            hgroup: !0,
            hr: !0,
            menu: !0,
            nav: !0,
            ol: !0,
            p: !0,
            pre: !0,
            section: !0,
            table: !0,
            ul: !0
        },
        rp: {
            rp: !0,
            rt: !0
        },
        rt: {
            rp: !0,
            rt: !0
        },
        tbody: {
            tbody: !0,
            tfoot: !0
        },
        td: {
            td: !0,
            th: !0
        },
        tfoot: {
            tbody: !0
        },
        th: {
            td: !0,
            th: !0
        },
        thead: {
            tbody: !0,
            tfoot: !0
        },
        tr: {
            tr: !0
        }
    };

function isSpace(e) {
    return 9 == e || 10 == e || 13 == e || 32 == e
}
let Ko = null,
    Jo = null,
    es = 0;

function tagNameAfter(e, t) {
    let n = e.pos + t;
    if (es == n && Jo == e) return Ko;
    let o = e.peek(t);
    for (; isSpace(o);) o = e.peek(++t);
    let h = "";
    for (; 45 == (p = o) || 46 == p || 58 == p || p >= 65 && p <= 90 || 95 == p || p >= 97 && p <= 122 || p >= 161;) h += String.fromCharCode(o), o = e.peek(++t);
    var p;
    return Jo = e, es = n, Ko = h ? h.toLowerCase() : o == ts || o == ns ? void 0 : null
}
const ts = 63,
    ns = 33;

function ElementContext(e, t) {
    this.name = e, this.parent = t
}
const is = [6, 10, 7, 8, 9],
    rs = new ContextTracker({
        start: null,
        shift: (e, t, n, o) => is.indexOf(t) > -1 ? new ElementContext(tagNameAfter(o, 1) || "", e) : e,
        reduce: (e, t) => 20 == t && e ? e.parent : e,
        reuse(e, t, n, o) {
            let h = t.type.id;
            return 6 == h || 36 == h ? new ElementContext(tagNameAfter(o, 1) || "", e) : e
        },
        strict: !1
    }),
    os = new ExternalTokenizer(((e, t) => {
        if (60 != e.next) return void(e.next < 0 && t.context && e.acceptToken(57));
        e.advance();
        let n = 47 == e.next;
        n && e.advance();
        let o = tagNameAfter(e, 0);
        if (void 0 === o) return;
        if (!o) return e.acceptToken(n ? 14 : 6);
        let h = t.context ? t.context.name : null;
        if (n) {
            if (o == h) return e.acceptToken(11);
            if (h && Go[h]) return e.acceptToken(57, -2);
            if (t.dialectEnabled(0)) return e.acceptToken(12);
            for (let e = t.context; e; e = e.parent)
                if (e.name == o) return;
            e.acceptToken(13)
        } else {
            if ("script" == o) return e.acceptToken(7);
            if ("style" == o) return e.acceptToken(8);
            if ("textarea" == o) return e.acceptToken(9);
            if (Fo.hasOwnProperty(o)) return e.acceptToken(10);
            h && Ho[h] && Ho[h][o] ? e.acceptToken(57, -1) : e.acceptToken(6)
        }
    }), {
        contextual: !0
    }),
    ss = new ExternalTokenizer((e => {
        for (let t = 0, n = 0;; n++) {
            if (e.next < 0) {
                n && e.acceptToken(58);
                break
            }
            if (45 == e.next) t++;
            else {
                if (62 == e.next && t >= 2) {
                    n >= 3 && e.acceptToken(58, -2);
                    break
                }
                t = 0
            }
            e.advance()
        }
    }));
const as = new ExternalTokenizer(((e, t) => {
    if (47 == e.next && 62 == e.peek(1)) {
        let n = t.dialectEnabled(1) || function(e) {
            for (; e; e = e.parent)
                if ("svg" == e.name || "math" == e.name) return !0;
            return !1
        }(t.context);
        e.acceptToken(n ? 5 : 4, 2)
    } else 62 == e.next && e.acceptToken(4, 1)
}));

function contentTokenizer(e, t, n) {
    let o = 2 + e.length;
    return new ExternalTokenizer((h => {
        for (let p = 0, f = 0, g = 0;; g++) {
            if (h.next < 0) {
                g && h.acceptToken(t);
                break
            }
            if (0 == p && 60 == h.next || 1 == p && 47 == h.next || p >= 2 && p < o && h.next == e.charCodeAt(p - 2)) p++, f++;
            else if (2 != p && p != o || !isSpace(h.next)) {
                if (p == o && 62 == h.next) {
                    g > f ? h.acceptToken(t, -f) : h.acceptToken(n, -(f - 2));
                    break
                }
                if ((10 == h.next || 13 == h.next) && g) {
                    h.acceptToken(t, 1);
                    break
                }
                p = f = 0
            } else f++;
            h.advance()
        }
    }))
}
const ls = contentTokenizer("script", 54, 1),
    cs = contentTokenizer("style", 55, 2),
    hs = contentTokenizer("textarea", 56, 3),
    ds = styleTags({
        "Text RawText": ai.content,
        "StartTag StartCloseTag SelfClosingEndTag EndTag": ai.angleBracket,
        TagName: ai.tagName,
        "MismatchedCloseTag/TagName": [ai.tagName, ai.invalid],
        AttributeName: ai.attributeName,
        "AttributeValue UnquotedAttributeValue": ai.attributeValue,
        Is: ai.definitionOperator,
        "EntityReference CharacterReference": ai.character,
        Comment: ai.blockComment,
        ProcessingInst: ai.processingInstruction,
        DoctypeDecl: ai.documentMeta
    }),
    us = LRParser.deserialize({
        version: 14,
        states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
        stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
        goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
        nodeNames: "âš  StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
        maxTerm: 67,
        context: rs,
        nodeProps: [
            ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
            ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
            ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
            ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
        ],
        propSources: [ds],
        skippedNodes: [0],
        repeatNodeCount: 9,
        tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
        tokenizers: [ls, cs, hs, as, os, ss, 0, 1, 2, 3, 4, 5],
        topRules: {
            Document: [0, 15]
        },
        dialects: {
            noMatch: 0,
            selfClosing: 509
        },
        tokenPrec: 511
    });

function getAttrs(e, t) {
    let n = Object.create(null);
    for (let o of e.getChildren(23)) {
        let e = o.getChild(24),
            h = o.getChild(26) || o.getChild(27);
        e && (n[t.read(e.from, e.to)] = h ? 26 == h.type.id ? t.read(h.from + 1, h.to - 1) : t.read(h.from, h.to) : "")
    }
    return n
}

function findTagName(e, t) {
    let n = e.getChild(22);
    return n ? t.read(n.from, n.to) : " "
}

function maybeNest(e, t, n) {
    let o;
    for (let h of n)
        if (!h.attrs || h.attrs(o || (o = getAttrs(e.node.parent.firstChild, t)))) return {
            parser: h.parser
        };
    return null
}

function configureNesting(e = [], t = []) {
    let n = [],
        o = [],
        h = [],
        p = [];
    for (let t of e) {
        ("script" == t.tag ? n : "style" == t.tag ? o : "textarea" == t.tag ? h : p).push(t)
    }
    let f = t.length ? Object.create(null) : null;
    for (let e of t)(f[e.name] || (f[e.name] = [])).push(e);
    return parseMixed(((e, t) => {
        let g = e.type.id;
        if (28 == g) return maybeNest(e, t, n);
        if (31 == g) return maybeNest(e, t, o);
        if (34 == g) return maybeNest(e, t, h);
        if (20 == g && p.length) {
            let n, o = e.node,
                h = o.firstChild,
                f = h && findTagName(h, t);
            if (f)
                for (let e of p)
                    if (e.tag == f && (!e.attrs || e.attrs(n || (n = getAttrs(h, t))))) {
                        let t = o.lastChild,
                            n = 37 == t.type.id ? t.from : o.to;
                        if (n > h.to) return {
                            parser: e.parser,
                            overlay: [{
                                from: h.to,
                                to: n
                            }]
                        }
                    }
        }
        if (f && 23 == g) {
            let n, o = e.node;
            if (n = o.firstChild) {
                let e = f[t.read(n.from, n.to)];
                if (e)
                    for (let n of e) {
                        if (n.tagName && n.tagName != findTagName(o.parent, t)) continue;
                        let e = o.lastChild;
                        if (26 == e.type.id) {
                            let t = e.from + 1,
                                o = e.lastChild,
                                h = e.to - (o && o.isError ? 0 : 1);
                            if (h > t) return {
                                parser: n.parser,
                                overlay: [{
                                    from: t,
                                    to: h
                                }]
                            }
                        } else if (27 == e.type.id) return {
                            parser: n.parser,
                            overlay: [{
                                from: e.from,
                                to: e.to
                            }]
                        }
                    }
            }
        }
        return null
    }))
}
const ps = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];

function isAlpha(e) {
    return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 161
}

function isDigit(e) {
    return e >= 48 && e <= 57
}
const fs = new ExternalTokenizer(((e, t) => {
        for (let n = !1, o = 0, h = 0;; h++) {
            let {
                next: p
            } = e;
            if (isAlpha(p) || 45 == p || 95 == p || n && isDigit(p)) !n && (45 != p || h > 0) && (n = !0), o === h && 45 == p && o++, e.advance();
            else {
                if (92 != p || 10 == e.peek(1)) {
                    n && e.acceptToken(40 == p ? 100 : 2 == o && t.canShift(2) ? 2 : 101);
                    break
                }
                e.advance(), e.next > -1 && e.advance(), n = !0
            }
        }
    })),
    gs = new ExternalTokenizer((e => {
        if (ps.includes(e.peek(-1))) {
            let {
                next: t
            } = e;
            (isAlpha(t) || 95 == t || 35 == t || 46 == t || 91 == t || 58 == t && isAlpha(e.peek(1)) || 45 == t || 38 == t) && e.acceptToken(99)
        }
    })),
    ms = new ExternalTokenizer((e => {
        if (!ps.includes(e.peek(-1))) {
            let {
                next: t
            } = e;
            if (37 == t && (e.advance(), e.acceptToken(1)), isAlpha(t)) {
                do {
                    e.advance()
                } while (isAlpha(e.next) || isDigit(e.next));
                e.acceptToken(1)
            }
        }
    })),
    Os = styleTags({
        "AtKeyword import charset namespace keyframes media supports": ai.definitionKeyword,
        "from to selector": ai.keyword,
        NamespaceName: ai.namespace,
        KeyframeName: ai.labelName,
        KeyframeRangeName: ai.operatorKeyword,
        TagName: ai.tagName,
        ClassName: ai.className,
        PseudoClassName: ai.constant(ai.className),
        IdName: ai.labelName,
        "FeatureName PropertyName": ai.propertyName,
        AttributeName: ai.attributeName,
        NumberLiteral: ai.number,
        KeywordQuery: ai.keyword,
        UnaryQueryOp: ai.operatorKeyword,
        "CallTag ValueName": ai.atom,
        VariableName: ai.variableName,
        Callee: ai.operatorKeyword,
        Unit: ai.unit,
        "UniversalSelector NestingSelector": ai.definitionOperator,
        MatchOp: ai.compareOperator,
        "ChildOp SiblingOp, LogicOp": ai.logicOperator,
        BinOp: ai.arithmeticOperator,
        Important: ai.modifier,
        Comment: ai.blockComment,
        ColorLiteral: ai.color,
        "ParenthesizedContent StringLiteral": ai.string,
        ":": ai.punctuation,
        "PseudoOp #": ai.derefOperator,
        "; ,": ai.separator,
        "( )": ai.paren,
        "[ ]": ai.squareBracket,
        "{ }": ai.brace
    }),
    ys = {
        __proto__: null,
        lang: 32,
        "nth-child": 32,
        "nth-last-child": 32,
        "nth-of-type": 32,
        "nth-last-of-type": 32,
        dir: 32,
        "host-context": 32,
        url: 60,
        "url-prefix": 60,
        domain: 60,
        regexp: 60,
        selector: 138
    },
    ws = {
        __proto__: null,
        "@import": 118,
        "@media": 142,
        "@charset": 146,
        "@namespace": 150,
        "@keyframes": 156,
        "@supports": 168
    },
    bs = {
        __proto__: null,
        not: 132,
        only: 132
    },
    Ss = LRParser.deserialize({
        version: 14,
        states: ":jQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO-kQdO,59}O-{Q[O'#E^O.YQWO,5;_O.YQWO,5;_POOO'#EV'#EVP.eO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO/[QXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/iQ`O1G/^O0SQXO1G/aO0jQXO1G/cO1QQXO1G/dO1hQWO,59|O1mQ[O'#DSO1tQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1{QpO,59]OOQS,59_,59_O${QdO,59aO2TQWO1G/mOOQS,59c,59cO2YQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2eQ[O,59jOOQS,59j,59jO2mQWO'#DjO2xQWO,5:VO2}QWO,5:]O&`Q[O,5:XO&`Q[O'#E_O3VQWO,5;`O3bQWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3sQWO1G0OO3xQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO4TQtO1G/iOOQO1G/i1G/iOOQO,5:x,5:xO4kQ[O,5:xOOQO-E8[-E8[O4xQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO5TQXO'#ErO5[QWO,59nO5aQtO'#EXO6XQdO'#EoO6cQWO,59ZO6hQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XOOQS1G/P1G/PO6pQWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6uQWO,5:yOOQO-E8]-E8]O7TQXO1G/xOOQS7+%j7+%jO7[QYO'#CsOOQO'#EQ'#EQO7gQ`O'#EPOOQO'#EP'#EPO7rQWO'#E`O7zQdO,5:jOOQS,5:j,5:jO8VQtO'#E]O${QdO'#E]O9WQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9kQpO<<HdO9sQWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9{QWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO:TQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3{QdO'#EaO7rQWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO:[QtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO;]QdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
        stateData: ";o~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!X#rO!Y!Va#U!Va!S!Va~P${O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#xO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.pOp#zO|#{O~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/qOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/qOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/qO!S#|O~Oa#fP~P(aOa#cP~P${Oa$TOj#XO~O!Y$VO~Oa$WOh$XOo$XO~Op$ZO#X#]O~O]!`Xa!^X!b!^X~O]$[O~Oa$]O!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$bO~O!S$iO#X$dO#e$cO~Oj#XOt$kO!X$mO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$qO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$sOa#cX~P${Oa$uO~Oj#XOp$vO~Oa$wO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$yO~P.pOP#WOtgX!TgX~O#e$cOt!sX!T!sX~Ot${O!TwO~O!S%PO#X$dO#e$cO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$kO!X%SO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%TO~OtoOa#fa~Ot$sOa#ca~Oa%WO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
        goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#tkYOPdhotuvw!n#R#h#tkSOPdhotuvw!n#R#h#tQmTR!tnQ{VR!xqQ!x}Q#Z!XR#y!zq![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%Up![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%UU$f#m$h${R$z$eq!XZ]!T!m#S#U#X#q#{$Q$[$k$l$s$x%Up![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%UQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#y!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ$}$gR%Z$|SgPwQ!phQ#s!nR$n#tZfPhw!n#ta!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$g#m$hR%X${V$e#m$h${Q!rjR#w!rQdOShPwU!ldh#tR#t!nQ$Q#SU$r$Q$x%UQ$x$[R%U$sQ#_!ZR$Y#_Q$t$QR%V$tQpUS!vp$pR$p#}Q$l#qR%R$lQ!ogS#u!o#vR#v!pQ#f!_R$`#fQ$h#mR%O$hQ$|$gR%Y$|_cOPdhw!n#t^UOPdhw!n#tQ!uoQ!}tQ#OuQ#PvQ#}#RR$a#hR$R#SQ!VZQ!d]Q#V!TQ#q!m[$P#S$Q$[$s$x%UQ$S#UQ$U#XS$j#q$lQ$o#{R%Q$kR$O#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$^#dR$_#e",
        nodeNames: "âš  Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
        maxTerm: 117,
        nodeProps: [
            ["isolate", -2, 3, 24, ""],
            ["openedBy", 17, "(", 32, "[", 50, "{"],
            ["closedBy", 18, ")", 33, "]", 51, "}"]
        ],
        propSources: [Os],
        skippedNodes: [0, 3, 87],
        repeatNodeCount: 11,
        tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
        tokenizers: [gs, ms, fs, 1, 2, 3, 4, new LocalTokenGroup("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
        topRules: {
            StyleSheet: [0, 4],
            Styles: [1, 86]
        },
        specialized: [{
            term: 100,
            get: e => ys[e] || -1
        }, {
            term: 58,
            get: e => ws[e] || -1
        }, {
            term: 101,
            get: e => bs[e] || -1
        }],
        tokenPrec: 1219
    });
let xs = null;

function properties() {
    if (!xs && "object" == typeof document && document.body) {
        let {
            style: e
        } = document.body, t = [], n = new Set;
        for (let o in e) "cssText" != o && "cssFloat" != o && "string" == typeof e[o] && (/[A-Z]/.test(o) && (o = o.replace(/[A-Z]/g, (e => "-" + e.toLowerCase()))), n.has(o) || (t.push(o), n.add(o)));
        xs = t.sort().map((e => ({
            type: "property",
            label: e
        })))
    }
    return xs || []
}
const ks = ["active", "after", "any-link", "autofill", "backdrop", "before", "checked", "cue", "default", "defined", "disabled", "empty", "enabled", "file-selector-button", "first", "first-child", "first-letter", "first-line", "first-of-type", "focus", "focus-visible", "focus-within", "fullscreen", "has", "host", "host-context", "hover", "in-range", "indeterminate", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "marker", "modal", "not", "nth-child", "nth-last-child", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "part", "placeholder", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "selection", "slotted", "target", "target-text", "valid", "visited", "where"].map((e => ({
        type: "class",
        label: e
    }))),
    vs = ["above", "absolute", "activeborder", "additive", "activecaption", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "antialiased", "appworkspace", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "axis-pan", "background", "backwards", "baseline", "below", "bidi-override", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic-abegede-gez", "ethiopic-halehame-aa-er", "ethiopic-halehame-gez", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fill-box", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "graytext", "grid", "groove", "hand", "hard-light", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "keep-all", "landscape", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lowercase", "ltr", "luminosity", "manipulation", "match", "matrix", "matrix3d", "medium", "menu", "menutext", "message-box", "middle", "min-intrinsic", "mix", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "perspective", "pinch-zoom", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "start", "static", "status-bar", "stretch", "stroke", "stroke-box", "sub", "subpixel-antialiased", "svg_masks", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "text", "text-bottom", "text-top", "textarea", "textfield", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "to", "top", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up", "upper-latin", "uppercase", "url", "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"].map((e => ({
        type: "keyword",
        label: e
    }))).concat(["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"].map((e => ({
        type: "constant",
        label: e
    })))),
    Ps = ["a", "abbr", "address", "article", "aside", "b", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "figcaption", "figure", "footer", "form", "header", "hgroup", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "meter", "nav", "ol", "output", "p", "pre", "ruby", "section", "select", "small", "source", "span", "strong", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "tr", "u", "ul"].map((e => ({
        type: "type",
        label: e
    }))),
    Cs = ["@charset", "@color-profile", "@container", "@counter-style", "@font-face", "@font-feature-values", "@font-palette-values", "@import", "@keyframes", "@layer", "@media", "@namespace", "@page", "@position-try", "@property", "@scope", "@starting-style", "@supports", "@view-transition"].map((e => ({
        type: "keyword",
        label: e
    }))),
    Qs = /^(\w[\w-]*|-\w[\w-]*|)$/,
    Ts = /^-(-[\w-]*)?$/;
const $s = new NodeWeakMap,
    Es = ["Declaration"];

function astTop(e) {
    for (let t = e;;) {
        if (t.type.isTop) return t;
        if (!(t = t.parent)) return e
    }
}

function variableNames(e, t, n) {
    if (t.to - t.from > 4096) {
        let o = $s.get(t);
        if (o) return o;
        let h = [],
            p = new Set,
            f = t.cursor(Bn.IncludeAnonymous);
        if (f.firstChild())
            do {
                for (let t of variableNames(e, f.node, n)) p.has(t.label) || (p.add(t.label), h.push(t))
            } while (f.nextSibling());
        return $s.set(t, h), h
    } {
        let o = [],
            h = new Set;
        return t.cursor().iterate((t => {
            var p;
            if (n(t) && t.matchContext(Es) && ":" == (null === (p = t.node.nextSibling) || void 0 === p ? void 0 : p.name)) {
                let n = e.sliceString(t.from, t.to);
                h.has(n) || (h.add(n), o.push({
                    label: n,
                    type: "variable"
                }))
            }
        })), o
    }
}
const defineCSSCompletionSource = e => t => {
        let {
            state: n,
            pos: o
        } = t, h = syntaxTree(n).resolveInner(o, -1), p = h.type.isError && h.from == h.to - 1 && "-" == n.doc.sliceString(h.from, h.to);
        if ("PropertyName" == h.name || (p || "TagName" == h.name) && /^(Block|Styles)$/.test(h.resolve(h.to).name)) return {
            from: h.from,
            options: properties(),
            validFor: Qs
        };
        if ("ValueName" == h.name) return {
            from: h.from,
            options: vs,
            validFor: Qs
        };
        if ("PseudoClassName" == h.name) return {
            from: h.from,
            options: ks,
            validFor: Qs
        };
        if (e(h) || (t.explicit || p) && function(e, t) {
                var n;
                if (("(" == e.name || e.type.isError) && (e = e.parent || e), "ArgList" != e.name) return !1;
                let o = null === (n = e.parent) || void 0 === n ? void 0 : n.firstChild;
                return "Callee" == (null == o ? void 0 : o.name) && "var" == t.sliceString(o.from, o.to)
            }(h, n.doc)) return {
            from: e(h) || p ? h.from : o,
            options: variableNames(n.doc, astTop(h), e),
            validFor: Ts
        };
        if ("TagName" == h.name) {
            for (let {
                    parent: e
                } = h; e; e = e.parent)
                if ("Block" == e.name) return {
                    from: h.from,
                    options: properties(),
                    validFor: Qs
                };
            return {
                from: h.from,
                options: Ps,
                validFor: Qs
            }
        }
        if ("AtKeyword" == h.name) return {
            from: h.from,
            options: Cs,
            validFor: Qs
        };
        if (!t.explicit) return null;
        let f = h.resolve(o),
            g = f.childBefore(o);
        return g && ":" == g.name && "PseudoClassSelector" == f.name ? {
            from: o,
            options: ks,
            validFor: Qs
        } : g && ":" == g.name && "Declaration" == f.name || "ArgList" == f.name ? {
            from: o,
            options: vs,
            validFor: Qs
        } : "Block" == f.name || "Styles" == f.name ? {
            from: o,
            options: properties(),
            validFor: Qs
        } : null
    },
    As = defineCSSCompletionSource((e => "VariableName" == e.name)),
    Ms = LRLanguage.define({
        name: "css",
        parser: Ss.configure({
            props: [Oi.add({
                Declaration: continuedIndent()
            }), wi.add({
                "Block KeyframeList": foldInside
            })]
        }),
        languageData: {
            commentTokens: {
                block: {
                    open: "/*",
                    close: "*/"
                }
            },
            indentOnInput: /^\s*\}$/,
            wordChars: "-"
        }
    });
const Rs = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288],
    Ds = new ContextTracker({
        start: !1,
        shift: (e, t) => 5 == t || 6 == t || 316 == t ? e : 317 == t,
        strict: !1
    }),
    Ls = new ExternalTokenizer(((e, t) => {
        let {
            next: n
        } = e;
        (125 == n || -1 == n || t.context) && e.acceptToken(314)
    }), {
        contextual: !0,
        fallback: !0
    }),
    Vs = new ExternalTokenizer(((e, t) => {
        let n, {
            next: o
        } = e;
        Rs.indexOf(o) > -1 || (47 != o || 47 != (n = e.peek(1)) && 42 != n) && (125 == o || 59 == o || -1 == o || t.context || e.acceptToken(312))
    }), {
        contextual: !0
    }),
    Zs = new ExternalTokenizer(((e, t) => {
        91 != e.next || t.context || e.acceptToken(313)
    }), {
        contextual: !0
    }),
    _s = new ExternalTokenizer(((e, t) => {
        let {
            next: n
        } = e;
        if (43 == n || 45 == n) {
            if (e.advance(), n == e.next) {
                e.advance();
                let n = !t.context && t.canShift(1);
                e.acceptToken(n ? 1 : 2)
            }
        } else 63 == n && 46 == e.peek(1) && (e.advance(), e.advance(), (e.next < 48 || e.next > 57) && e.acceptToken(3))
    }), {
        contextual: !0
    });

function identifierChar(e, t) {
    return e >= 65 && e <= 90 || e >= 97 && e <= 122 || 95 == e || e >= 192 || !t && e >= 48 && e <= 57
}
const Bs = new ExternalTokenizer(((e, t) => {
        if (60 != e.next || !t.dialectEnabled(0)) return;
        if (e.advance(), 47 == e.next) return;
        let n = 0;
        for (; Rs.indexOf(e.next) > -1;) e.advance(), n++;
        if (identifierChar(e.next, !0)) {
            for (e.advance(), n++; identifierChar(e.next, !1);) e.advance(), n++;
            for (; Rs.indexOf(e.next) > -1;) e.advance(), n++;
            if (44 == e.next) return;
            for (let t = 0;; t++) {
                if (7 == t) {
                    if (!identifierChar(e.next, !0)) return;
                    break
                }
                if (e.next != "extends".charCodeAt(t)) break;
                e.advance(), n++
            }
        }
        e.acceptToken(4, -n)
    })),
    Is = styleTags({
        "get set async static": ai.modifier,
        "for while do if else switch try catch finally return throw break continue default case": ai.controlKeyword,
        "in of await yield void typeof delete instanceof": ai.operatorKeyword,
        "let var const using function class extends": ai.definitionKeyword,
        "import export from": ai.moduleKeyword,
        "with debugger as new": ai.keyword,
        TemplateString: ai.special(ai.string),
        super: ai.atom,
        BooleanLiteral: ai.bool,
        this: ai.self,
        null: ai.null,
        Star: ai.modifier,
        VariableName: ai.variableName,
        "CallExpression/VariableName TaggedTemplateExpression/VariableName": ai.function(ai.variableName),
        VariableDefinition: ai.definition(ai.variableName),
        Label: ai.labelName,
        PropertyName: ai.propertyName,
        PrivatePropertyName: ai.special(ai.propertyName),
        "CallExpression/MemberExpression/PropertyName": ai.function(ai.propertyName),
        "FunctionDeclaration/VariableDefinition": ai.function(ai.definition(ai.variableName)),
        "ClassDeclaration/VariableDefinition": ai.definition(ai.className),
        PropertyDefinition: ai.definition(ai.propertyName),
        PrivatePropertyDefinition: ai.definition(ai.special(ai.propertyName)),
        UpdateOp: ai.updateOperator,
        "LineComment Hashbang": ai.lineComment,
        BlockComment: ai.blockComment,
        Number: ai.number,
        String: ai.string,
        Escape: ai.escape,
        ArithOp: ai.arithmeticOperator,
        LogicOp: ai.logicOperator,
        BitOp: ai.bitwiseOperator,
        CompareOp: ai.compareOperator,
        RegExp: ai.regexp,
        Equals: ai.definitionOperator,
        Arrow: ai.function(ai.punctuation),
        ": Spread": ai.punctuation,
        "( )": ai.paren,
        "[ ]": ai.squareBracket,
        "{ }": ai.brace,
        "InterpolationStart InterpolationEnd": ai.special(ai.brace),
        ".": ai.derefOperator,
        ", ;": ai.separator,
        "@": ai.meta,
        TypeName: ai.typeName,
        TypeDefinition: ai.definition(ai.typeName),
        "type enum interface implements namespace module declare": ai.definitionKeyword,
        "abstract global Privacy readonly override": ai.modifier,
        "is keyof unique infer": ai.operatorKeyword,
        JSXAttributeValue: ai.attributeValue,
        JSXText: ai.content,
        "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": ai.angleBracket,
        "JSXIdentifier JSXNameSpacedName": ai.tagName,
        "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": ai.attributeName,
        "JSXBuiltin/JSXIdentifier": ai.standard(ai.tagName)
    }),
    Xs = {
        __proto__: null,
        export: 20,
        as: 25,
        from: 33,
        default: 36,
        async: 41,
        function: 42,
        extends: 54,
        this: 58,
        true: 66,
        false: 66,
        null: 78,
        void: 82,
        typeof: 86,
        super: 102,
        new: 136,
        delete: 148,
        yield: 157,
        await: 161,
        class: 166,
        public: 229,
        private: 229,
        protected: 229,
        readonly: 231,
        instanceof: 250,
        satisfies: 253,
        in: 254,
        const: 256,
        import: 290,
        keyof: 345,
        unique: 349,
        infer: 355,
        is: 391,
        abstract: 411,
        implements: 413,
        type: 415,
        let: 418,
        var: 420,
        using: 423,
        interface: 429,
        enum: 433,
        namespace: 439,
        module: 441,
        declare: 445,
        global: 449,
        for: 468,
        of: 477,
        while: 480,
        with: 484,
        do: 488,
        if: 492,
        else: 494,
        switch: 498,
        case: 504,
        try: 510,
        catch: 514,
        finally: 518,
        return: 522,
        throw: 526,
        break: 530,
        continue: 534,
        debugger: 538
    },
    qs = {
        __proto__: null,
        async: 123,
        get: 125,
        set: 127,
        declare: 189,
        public: 191,
        private: 191,
        protected: 191,
        static: 193,
        abstract: 195,
        override: 197,
        readonly: 203,
        accessor: 205,
        new: 395
    },
    zs = {
        __proto__: null,
        "<": 187
    },
    Ns = LRParser.deserialize({
        version: 14,
        states: "$CdQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#D^O.QQlO'#DdO.bQlO'#DoO%[QlO'#DwO0fQlO'#EPOOQ!0Lf'#EX'#EXO1PQ`O'#EUOOQO'#Em'#EmOOQO'#Ih'#IhO1XQ`O'#GpO1dQ`O'#ElO1iQ`O'#ElO3hQ!0MxO'#JnO6[Q!0MxO'#JoO6uQ`O'#F[O6zQ,UO'#FsOOQ!0Lf'#Fe'#FeO7VO7dO'#FeO7eQMhO'#FzO9RQ`O'#FyOOQ!0Lf'#Jo'#JoOOQ!0Lb'#Jn'#JnO9WQ`O'#GtOOQ['#K['#K[O9cQ`O'#IUO9hQ!0LrO'#IVOOQ['#J['#J[OOQ['#IZ'#IZQ`QlOOQ`QlOOO9pQ!L^O'#DsO9wQlO'#D{O:OQlO'#D}O9^Q`O'#GpO:VQMhO'#CoO:eQ`O'#EkO:pQ`O'#EvO:uQMhO'#FdO;dQ`O'#GpOOQO'#K]'#K]O;iQ`O'#K]O;wQ`O'#GxO;wQ`O'#GyO;wQ`O'#G{O9^Q`O'#HOO<nQ`O'#HRO>VQ`O'#CeO>gQ`O'#H_O>oQ`O'#HeO>oQ`O'#HgO`QlO'#HiO>oQ`O'#HkO>oQ`O'#HnO>tQ`O'#HtO>yQ!0LsO'#HzO%[QlO'#H|O?UQ!0LsO'#IOO?aQ!0LsO'#IQO9hQ!0LrO'#ISO?lQ!0MxO'#CiO@nQpO'#DiQOQ`OOO%[QlO'#D}OAUQ`O'#EQO:VQMhO'#EkOAaQ`O'#EkOAlQ!bO'#FdOOQ['#Cg'#CgOOQ!0Lb'#Dn'#DnOOQ!0Lb'#Jr'#JrO%[QlO'#JrOOQO'#Ju'#JuOOQO'#Id'#IdOBlQpO'#EdOOQ!0Lb'#Ec'#EcOOQ!0Lb'#Jy'#JyOChQ!0MSO'#EdOCrQpO'#ETOOQO'#Jt'#JtODWQpO'#JuOEeQpO'#ETOCrQpO'#EdPErO&2DjO'#CbPOOO)CDy)CDyOOOO'#I['#I[OE}O#tO,59UOOQ!0Lh,59U,59UOOOO'#I]'#I]OF]O&jO,59UOFkQ!L^O'#D`OOOO'#I_'#I_OFrO#@ItO,59xOOQ!0Lf,59x,59xOGQQlO'#I`OGeQ`O'#JpOIdQ!fO'#JpO+}QlO'#JpOIkQ`O,5:OOJRQ`O'#EmOJ`Q`O'#KPOJkQ`O'#KOOJkQ`O'#KOOJsQ`O,5;ZOJxQ`O'#J}OOQ!0Ln,5:Z,5:ZOKPQlO,5:ZOL}Q!0MxO,5:cOMnQ`O,5:kONXQ!0LrO'#J|ON`Q`O'#J{O9WQ`O'#J{ONtQ`O'#J{ON|Q`O,5;YO! RQ`O'#J{O!#WQ!fO'#JoOOQ!0Lh'#Ci'#CiO%[QlO'#EPO!#vQ!fO,5:pOOQS'#Jv'#JvOOQO-E<f-E<fO9^Q`O,5=[O!$^Q`O,5=[O!$cQlO,5;WO!&fQMhO'#EhO!(PQ`O,5;WO!(UQlO'#DvO!(`QpO,5;aO!(hQpO,5;aO%[QlO,5;aOOQ['#FS'#FSOOQ['#FU'#FUO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bOOQ['#FY'#FYO!(vQlO,5;sOOQ!0Lf,5;x,5;xOOQ!0Lf,5;y,5;yOOQ!0Lf,5;{,5;{O%[QlO'#IlO!*yQ!0LrO,5<gO%[QlO,5;bO!&fQMhO,5;bO!+hQMhO,5;bO!-YQMhO'#EZO%[QlO,5;vOOQ!0Lf,5;z,5;zO!-aQ,UO'#FiO!.^Q,UO'#KTO!-xQ,UO'#KTO!.eQ,UO'#KTOOQO'#KT'#KTO!.yQ,UO,5<ROOOW,5<_,5<_O!/[QlO'#FuOOOW'#Ik'#IkO7VO7dO,5<PO!/cQ,UO'#FwOOQ!0Lf,5<P,5<PO!0SQ$IUO'#CvOOQ!0Lh'#Cz'#CzO!0gO#@ItO'#DOO!1TQMjO,5<dO!1[Q`O,5<fO!2wQ(CWO'#GVO!3UQ`O'#GWO!3ZQ`O'#GWO!4yQ(CWO'#G[O!6OQpO'#G`OOQO'#Gk'#GkO!+oQMhO'#GjOOQO'#Gm'#GmO!+oQMhO'#GlO!6qQ$IUO'#JhOOQ!0Lh'#Jh'#JhO!6{Q`O'#JgO!7ZQ`O'#JfO!7cQ`O'#CuOOQ!0Lh'#Cx'#CxO!7kQ`O'#CzOOQ!0Lh'#DS'#DSOOQ!0Lh'#DU'#DUO1SQ`O'#DWO!+oQMhO'#F}O!+oQMhO'#GPO!7pQ`O'#GRO!7uQ`O'#GSO!3ZQ`O'#GYO!+oQMhO'#G_O!7zQ`O'#EnO!8iQ`O,5<eOOQ!0Lb'#Cr'#CrO!8qQ`O'#EoO!9kQpO'#EpOOQ!0Lb'#J}'#J}O!9rQ!0LrO'#K^O9hQ!0LrO,5=`O`QlO,5>pOOQ['#Jd'#JdOOQ[,5>q,5>qOOQ[-E<X-E<XO!;qQ!0MxO,5:_O!9fQpO,5:]O!>[Q!0MxO,5:gO%[QlO,5:gO!@rQ!0MxO,5:iOOQO,5@w,5@wO!AcQMhO,5=[O!AqQ!0LrO'#JeO9RQ`O'#JeO!BSQ!0LrO,59ZO!B_QpO,59ZO!BgQMhO,59ZO:VQMhO,59ZO!BrQ`O,5;WO!BzQ`O'#H^O!C`Q`O'#KaO%[QlO,5;|O!9fQpO,5<OO!ChQ`O,5=wO!CmQ`O,5=wO!CrQ`O,5=wO9hQ!0LrO,5=wO;wQ`O,5=gOOQO'#Cv'#CvO!DQQpO,5=dO!DYQMhO,5=eO!DeQ`O,5=gO!DjQ!bO,5=jO!DrQ`O'#K]O>tQ`O'#HTO9^Q`O'#HVO!DwQ`O'#HVO:VQMhO'#HXO!D|Q`O'#HXOOQ[,5=m,5=mO!ERQ`O'#HYO!EdQ`O'#CoO!EiQ`O,59PO!EsQ`O,59PO!GxQlO,59POOQ[,59P,59PO!HYQ!0LrO,59PO%[QlO,59PO!JeQlO'#HaOOQ['#Hb'#HbOOQ['#Hc'#HcO`QlO,5=yO!J{Q`O,5=yO`QlO,5>PO`QlO,5>RO!KQQ`O,5>TO`QlO,5>VO!KVQ`O,5>YO!K[QlO,5>`OOQ[,5>f,5>fO%[QlO,5>fO9hQ!0LrO,5>hOOQ[,5>j,5>jO# fQ`O,5>jOOQ[,5>l,5>lO# fQ`O,5>lOOQ[,5>n,5>nO#!SQpO'#D[O%[QlO'#JrO#!uQpO'#JrO##PQpO'#DjO##bQpO'#DjO#%sQlO'#DjO#%zQ`O'#JqO#&SQ`O,5:TO#&XQ`O'#EqO#&gQ`O'#KQO#&oQ`O,5;[O#&tQpO'#DjO#'RQpO'#ESOOQ!0Lf,5:l,5:lO%[QlO,5:lO#'YQ`O,5:lO>tQ`O,5;VO!B_QpO,5;VO!BgQMhO,5;VO:VQMhO,5;VO#'bQ`O,5@^O#'gQ07dO,5:pOOQO-E<b-E<bO#(mQ!0MSO,5;OOCrQpO,5:oO#(wQpO,5:oOCrQpO,5;OO!BSQ!0LrO,5:oOOQ!0Lb'#Eg'#EgOOQO,5;O,5;OO%[QlO,5;OO#)UQ!0LrO,5;OO#)aQ!0LrO,5;OO!B_QpO,5:oOOQO,5;U,5;UO#)oQ!0LrO,5;OPOOO'#IY'#IYP#*TO&2DjO,58|POOO,58|,58|OOOO-E<Y-E<YOOQ!0Lh1G.p1G.pOOOO-E<Z-E<ZOOOO,59z,59zO#*`Q!bO,59zOOOO-E<]-E<]OOQ!0Lf1G/d1G/dO#*eQ!fO,5>zO+}QlO,5>zOOQO,5?Q,5?QO#*oQlO'#I`OOQO-E<^-E<^O#*|Q`O,5@[O#+UQ!fO,5@[O#+]Q`O,5@jOOQ!0Lf1G/j1G/jO%[QlO,5@kO#+eQ`O'#IfOOQO-E<d-E<dO#+]Q`O,5@jOOQ!0Lb1G0u1G0uOOQ!0Ln1G/u1G/uOOQ!0Ln1G0V1G0VO%[QlO,5@hO#+yQ!0LrO,5@hO#,[Q!0LrO,5@hO#,cQ`O,5@gO9WQ`O,5@gO#,kQ`O,5@gO#,yQ`O'#IiO#,cQ`O,5@gOOQ!0Lb1G0t1G0tO!(`QpO,5:rO!(kQpO,5:rOOQS,5:t,5:tO#-kQdO,5:tO#-sQMhO1G2vO9^Q`O1G2vOOQ!0Lf1G0r1G0rO#.RQ!0MxO1G0rO#/WQ!0MvO,5;SOOQ!0Lh'#GU'#GUO#/tQ!0MzO'#JhO!$cQlO1G0rO#2PQ!fO'#JsO%[QlO'#JsO#2ZQ`O,5:bOOQ!0Lh'#D['#D[OOQ!0Lf1G0{1G0{O%[QlO1G0{OOQ!0Lf1G1e1G1eO#2`Q`O1G0{O#4tQ!0MxO1G0|O#4{Q!0MxO1G0|O#7cQ!0MxO1G0|O#7jQ!0MxO1G0|O#:QQ!0MxO1G0|O#<hQ!0MxO1G0|O#<oQ!0MxO1G0|O#<vQ!0MxO1G0|O#?^Q!0MxO1G0|O#?eQ!0MxO1G0|O#ArQ?MtO'#CiO#CmQ?MtO1G1_O#CtQ?MtO'#JoO#DXQ!0MxO,5?WOOQ!0Lb-E<j-E<jO#FfQ!0MxO1G0|O#GcQ!0MzO1G0|OOQ!0Lf1G0|1G0|O#HfQMjO'#JxO#HpQ`O,5:uO#HuQ!0MxO1G1bO#IiQ,UO,5<VO#IqQ,UO,5<WO#IyQ,UO'#FnO#JbQ`O'#FmOOQO'#KU'#KUOOQO'#Ij'#IjO#JgQ,UO1G1mOOQ!0Lf1G1m1G1mOOOW1G1x1G1xO#JxQ?MtO'#JnO#KSQ`O,5<aO!(vQlO,5<aOOOW-E<i-E<iOOQ!0Lf1G1k1G1kO#KXQpO'#KTOOQ!0Lf,5<c,5<cO#KaQpO,5<cO#KfQMhO'#DQOOOO'#I^'#I^O#KmO#@ItO,59jOOQ!0Lh,59j,59jO%[QlO1G2OO!7uQ`O'#InO#KxQ`O,5<xOOQ!0Lh,5<u,5<uO!+oQMhO'#IqO#LfQMjO,5=UO!+oQMhO'#IsO#MXQMjO,5=WO!&fQMhO,5=YOOQO1G2Q1G2QO#McQ!dO'#CrO#MvQ(CWO'#EoO#N{QpO'#G`O$ cQ!dO,5<qO$ jQ`O'#KXO9WQ`O'#KXO$ xQ`O,5<sO!+oQMhO,5<rO$ }Q`O'#GXO$!`Q`O,5<rO$!eQ!dO'#GUO$!rQ!dO'#KYO$!|Q`O'#KYO!&fQMhO'#KYO$#RQ`O,5<vO$#WQlO'#JrO$#bQpO'#GaO##bQpO'#GaO$#sQ`O'#GeO!3ZQ`O'#GhO$#xQ!0LrO'#IpO$$TQpO,5<zOOQ!0Lp,5<z,5<zO$$[QpO'#GaO$$iQpO'#GbO$$zQpO'#GbO$%PQMjO,5=UO$%aQMjO,5=WOOQ!0Lh,5=Z,5=ZO!+oQMhO,5@RO!+oQMhO,5@RO$%qQ`O'#IuO$%|Q`O,5@QO$&UQ`O,59aOOQ!0Lh,59f,59fO$&{Q$IYO,59rOOQ!0Lh'#Jl'#JlO$'nQMjO,5<iO$(aQMjO,5<kO@fQ`O,5<mOOQ!0Lh,5<n,5<nO$(kQ`O,5<tO$(pQMjO,5<yO$)QQ`O'#J{O!$cQlO1G2PO$)VQ`O1G2PO9WQ`O'#KOO9WQ`O'#EqO%[QlO'#EqO9WQ`O'#IwO$)[Q!0LrO,5@xOOQ[1G2z1G2zOOQ[1G4[1G4[OOQ!0Lf1G/y1G/yOOQ!0Lf1G/w1G/wO$+^Q!0MxO1G0ROOQ[1G2v1G2vO!&fQMhO1G2vO%[QlO1G2vO#-vQ`O1G2vO$-bQMhO'#EhOOQ!0Lb,5@P,5@PO$-lQ!0LrO,5@POOQ[1G.u1G.uO!BSQ!0LrO1G.uO!B_QpO1G.uO!BgQMhO1G.uO$-}Q`O1G0rO$.SQ`O'#CiO$._Q`O'#KbO$.gQ`O,5=xO$.lQ`O'#KbO$.qQ`O'#KbO$/PQ`O'#I}O$/_Q`O,5@{O$/gQ!fO1G1hOOQ!0Lf1G1j1G1jO9^Q`O1G3cO@fQ`O1G3cO$/nQ`O1G3cO$/sQ`O1G3cOOQ[1G3c1G3cO!DeQ`O1G3RO!&fQMhO1G3OO$/xQ`O1G3OOOQ[1G3P1G3PO!&fQMhO1G3PO$/}Q`O1G3PO$0VQpO'#G}OOQ[1G3R1G3RO!5yQpO'#IyO!DjQ!bO1G3UOOQ[1G3U1G3UOOQ[,5=o,5=oO$0_QMhO,5=qO9^Q`O,5=qO$#sQ`O,5=sO9RQ`O,5=sO!B_QpO,5=sO!BgQMhO,5=sO:VQMhO,5=sO$0mQ`O'#K`O$0xQ`O,5=tOOQ[1G.k1G.kO$0}Q!0LrO1G.kO@fQ`O1G.kO$1YQ`O1G.kO9hQ!0LrO1G.kO$3bQ!fO,5@}O$3oQ`O,5@}O9WQ`O,5@}O$3zQlO,5={O$4RQ`O,5={OOQ[1G3e1G3eO`QlO1G3eOOQ[1G3k1G3kOOQ[1G3m1G3mO>oQ`O1G3oO$4WQlO1G3qO$8[QlO'#HpOOQ[1G3t1G3tO$8iQ`O'#HvO>tQ`O'#HxOOQ[1G3z1G3zO$8qQlO1G3zO9hQ!0LrO1G4QOOQ[1G4S1G4SOOQ!0Lb'#G]'#G]O9hQ!0LrO1G4UO9hQ!0LrO1G4WO$<xQ`O,5@^O!(vQlO,5;]O9WQ`O,5;]O>tQ`O,5:UO!(vQlO,5:UO!B_QpO,5:UO$<}Q?MtO,5:UOOQO,5;],5;]O$=XQpO'#IaO$=oQ`O,5@]OOQ!0Lf1G/o1G/oO$=wQpO'#IgO$>RQ`O,5@lOOQ!0Lb1G0v1G0vO##bQpO,5:UOOQO'#Ic'#IcO$>ZQpO,5:nOOQ!0Ln,5:n,5:nO#']Q`O1G0WOOQ!0Lf1G0W1G0WO%[QlO1G0WOOQ!0Lf1G0q1G0qO>tQ`O1G0qO!B_QpO1G0qO!BgQMhO1G0qOOQ!0Lb1G5x1G5xO!BSQ!0LrO1G0ZOOQO1G0j1G0jO%[QlO1G0jO$>bQ!0LrO1G0jO$>mQ!0LrO1G0jO!B_QpO1G0ZOCrQpO1G0ZO$>{Q!0LrO1G0jOOQO1G0Z1G0ZO$?aQ!0MxO1G0jPOOO-E<W-E<WPOOO1G.h1G.hOOOO1G/f1G/fO$?kQ!bO,5<gO$?sQ!fO1G4fOOQO1G4l1G4lO%[QlO,5>zO$?}Q`O1G5vO$@VQ`O1G6UO$@_Q!fO1G6VO9WQ`O,5?QO$@iQ!0MxO1G6SO%[QlO1G6SO$@yQ!0LrO1G6SO$A[Q`O1G6RO$A[Q`O1G6RO9WQ`O1G6RO$AdQ`O,5?TO9WQ`O,5?TOOQO,5?T,5?TO$AxQ`O,5?TO$)QQ`O,5?TOOQO-E<g-E<gOOQS1G0^1G0^OOQS1G0`1G0`O#-nQ`O1G0`OOQ[7+(b7+(bO!&fQMhO7+(bO%[QlO7+(bO$BWQ`O7+(bO$BcQMhO7+(bO$BqQ!0MzO,5=UO$D|Q!0MzO,5=WO$GXQ!0MzO,5=UO$IjQ!0MzO,5=WO$K{Q!0MzO,59rO$NQQ!0MzO,5<iO%!]Q!0MzO,5<kO%$hQ!0MzO,5<yOOQ!0Lf7+&^7+&^O%&yQ!0MxO7+&^O%'mQlO'#IbO%'zQ`O,5@_O%(SQ!fO,5@_OOQ!0Lf1G/|1G/|O%(^Q`O7+&gOOQ!0Lf7+&g7+&gO%(cQ?MtO,5:cO%[QlO7+&yO%(mQ?MtO,5:_O%(zQ?MtO,5:gO%)UQ?MtO,5:iO%)`QMhO'#IeO%)jQ`O,5@dOOQ!0Lh1G0a1G0aOOQO1G1q1G1qOOQO1G1r1G1rO%)rQ!jO,5<YO!(vQlO,5<XOOQO-E<h-E<hOOQ!0Lf7+'X7+'XOOOW7+'d7+'dOOOW1G1{1G1{O%)}Q`O1G1{OOQ!0Lf1G1}1G1}OOOO,59l,59lO%*SQ!dO,59lOOOO-E<[-E<[OOQ!0Lh1G/U1G/UO%*ZQ!0MxO7+'jOOQ!0Lh,5?Y,5?YO%*}QMhO1G2dP%+UQ`O'#InPOQ!0Lh-E<l-E<lO%+rQMjO,5?]OOQ!0Lh-E<o-E<oO%,eQMjO,5?_OOQ!0Lh-E<q-E<qO%,oQ!dO1G2tO%,vQ!dO'#CrO%-^QMhO'#KOO$#WQlO'#JrOOQ!0Lh1G2]1G2]O%-eQ`O'#ImO%-yQ`O,5@sO%-yQ`O,5@sO%.RQ`O,5@sO%.^Q`O,5@sOOQO1G2_1G2_O%.lQMjO1G2^O!+oQMhO1G2^O%.|Q(CWO'#IoO%/ZQ`O,5@tO!&fQMhO,5@tO%/cQ!dO,5@tOOQ!0Lh1G2b1G2bO%1sQ!fO'#CiO%1}Q`O,5<}OOQ!0Lb,5<{,5<{O%2VQpO,5<{OOQ!0Lb,5<|,5<|OCcQ`O,5<{O%2bQpO,5<{OOQ!0Lb,5=P,5=PO$)QQ`O,5=SOOQO,5?[,5?[OOQO-E<n-E<nOOQ!0Lp1G2f1G2fO##bQpO,5<{O$#WQlO,5<}O%2pQ`O,5<|O%2{QpO,5<|O!+oQMhO'#IqO%3uQMjO1G2pO!+oQMhO'#IsO%4hQMjO1G2rO%4rQMjO1G5mO%4|QMjO1G5mOOQO,5?a,5?aOOQO-E<s-E<sOOQO1G.{1G.{O!9fQpO,59tO%[QlO,59tOOQ!0Lh,5<h,5<hO%5ZQ`O1G2XO!+oQMhO1G2`O%5`Q!0MxO7+'kOOQ!0Lf7+'k7+'kO!$cQlO7+'kO%6SQ`O,5;]OOQ!0Lb,5?c,5?cOOQ!0Lb-E<u-E<uO%6XQ!dO'#KZO#']Q`O7+(bO4UQ!fO7+(bO$BZQ`O7+(bO%6cQ!0MvO'#CiO%6vQ!0MvO,5=QO%7hQ`O,5=QOOQ!0Lb1G5k1G5kOOQ[7+$a7+$aO!BSQ!0LrO7+$aO!B_QpO7+$aO!$cQlO7+&^O%7mQ`O'#I|O%8UQ`O,5@|OOQO1G3d1G3dO9^Q`O,5@|O%8UQ`O,5@|O%8^Q`O,5@|OOQO,5?i,5?iOOQO-E<{-E<{OOQ!0Lf7+'S7+'SO%8cQ`O7+(}O9hQ!0LrO7+(}O9^Q`O7+(}O@fQ`O7+(}OOQ[7+(m7+(mO%8hQ!0MvO7+(jO!&fQMhO7+(jO!D`Q`O7+(kOOQ[7+(k7+(kO!&fQMhO7+(kO%8rQ`O'#K_O%8}Q`O,5=iOOQO,5?e,5?eOOQO-E<w-E<wOOQ[7+(p7+(pO%:aQpO'#HWOOQ[1G3]1G3]O!&fQMhO1G3]O%[QlO1G3]O%:hQ`O1G3]O%:sQMhO1G3]O9hQ!0LrO1G3_O$#sQ`O1G3_O9RQ`O1G3_O!B_QpO1G3_O!BgQMhO1G3_O%;RQ`O'#I{O%;gQ`O,5@zO%;oQpO,5@zOOQ!0Lb1G3`1G3`OOQ[7+$V7+$VO@fQ`O7+$VO9hQ!0LrO7+$VO%;zQ`O7+$VO%[QlO1G6iO%[QlO1G6jO%<PQ!0LrO1G6iO%<ZQlO1G3gO%<bQ`O1G3gO%<gQlO1G3gOOQ[7+)P7+)PO9hQ!0LrO7+)ZO`QlO7+)]OOQ['#Ke'#KeOOQ['#JO'#JOO%<nQlO,5>[OOQ[,5>[,5>[O%[QlO'#HqO%<{Q`O'#HsOOQ[,5>b,5>bO9WQ`O,5>bOOQ[,5>d,5>dOOQ[7+)f7+)fOOQ[7+)l7+)lOOQ[7+)p7+)pOOQ[7+)r7+)rO%=QQpO1G5xO%=lQ?MtO1G0wO%=vQ`O1G0wOOQO1G/p1G/pO%>RQ?MtO1G/pO>tQ`O1G/pO!(vQlO'#DjOOQO,5>{,5>{OOQO-E<_-E<_OOQO,5?R,5?ROOQO-E<e-E<eO!B_QpO1G/pOOQO-E<a-E<aOOQ!0Ln1G0Y1G0YOOQ!0Lf7+%r7+%rO#']Q`O7+%rOOQ!0Lf7+&]7+&]O>tQ`O7+&]O!B_QpO7+&]OOQO7+%u7+%uO$?aQ!0MxO7+&UOOQO7+&U7+&UO%[QlO7+&UO%>]Q!0LrO7+&UO!BSQ!0LrO7+%uO!B_QpO7+%uO%>hQ!0LrO7+&UO%>vQ!0MxO7++nO%[QlO7++nO%?WQ`O7++mO%?WQ`O7++mOOQO1G4o1G4oO9WQ`O1G4oO%?`Q`O1G4oOOQS7+%z7+%zO#']Q`O<<K|O4UQ!fO<<K|O%?nQ`O<<K|OOQ[<<K|<<K|O!&fQMhO<<K|O%[QlO<<K|O%?vQ`O<<K|O%@RQ!0MzO,5?]O%B^Q!0MzO,5?_O%DiQ!0MzO1G2^O%FzQ!0MzO1G2pO%IVQ!0MzO1G2rO%KbQ!fO,5>|O%[QlO,5>|OOQO-E<`-E<`O%KlQ`O1G5yOOQ!0Lf<<JR<<JRO%KtQ?MtO1G0rO%M{Q?MtO1G0|O%NSQ?MtO1G0|O&!TQ?MtO1G0|O&![Q?MtO1G0|O&$]Q?MtO1G0|O&&^Q?MtO1G0|O&&eQ?MtO1G0|O&&lQ?MtO1G0|O&(mQ?MtO1G0|O&(tQ?MtO1G0|O&({Q!0MxO<<JeO&*sQ?MtO1G0|O&+pQ?MvO1G0|O&,sQ?MvO'#JhO&.yQ?MtO1G1bO&/WQ?MtO1G0RO&/bQMjO,5?POOQO-E<c-E<cO!(vQlO'#FpOOQO'#KV'#KVOOQO1G1t1G1tO&/lQ`O1G1sO&/qQ?MtO,5?WOOOW7+'g7+'gOOOO1G/W1G/WO&/{Q!dO1G4tOOQ!0Lh7+(O7+(OP!&fQMhO,5?YO!+oQMhO7+(`O&0SQ`O,5?XO9WQ`O,5?XOOQO-E<k-E<kO&0bQ`O1G6_O&0bQ`O1G6_O&0jQ`O1G6_O&0uQMjO7+'xO&1VQ!dO,5?ZO&1aQ`O,5?ZO!&fQMhO,5?ZOOQO-E<m-E<mO&1fQ!dO1G6`O&1pQ`O1G6`O&1xQ`O1G2iO!&fQMhO1G2iOOQ!0Lb1G2g1G2gOOQ!0Lb1G2h1G2hO%2VQpO1G2gO!B_QpO1G2gOCcQ`O1G2gOOQ!0Lb1G2n1G2nO&1}QpO1G2gO&2]Q`O1G2iO$)QQ`O1G2hOCcQ`O1G2hO$#WQlO1G2iO&2eQ`O1G2hO&3XQMjO,5?]OOQ!0Lh-E<p-E<pO&3zQMjO,5?_OOQ!0Lh-E<r-E<rO!+oQMhO7++XOOQ!0Lh1G/`1G/`O&4UQ`O1G/`OOQ!0Lh7+'s7+'sO&4ZQMjO7+'zO&4kQ!0MxO<<KVOOQ!0Lf<<KV<<KVO&5_Q`O1G0wO!&fQMhO'#IvO&5dQ`O,5@uO&7fQ!fO<<K|O!&fQMhO1G2lOOQ[<<G{<<G{O!BSQ!0LrO<<G{O&7mQ!0MxO<<IxOOQ!0Lf<<Ix<<IxOOQO,5?h,5?hO&8aQ`O,5?hO&8fQ`O,5?hOOQO-E<z-E<zO&8tQ`O1G6hO&8tQ`O1G6hO9^Q`O1G6hO@fQ`O<<LiOOQ[<<Li<<LiO&8|Q`O<<LiO9hQ!0LrO<<LiOOQ[<<LU<<LUO%8hQ!0MvO<<LUOOQ[<<LV<<LVO!D`Q`O<<LVO&9RQpO'#IxO&9^Q`O,5@yO!(vQlO,5@yOOQ[1G3T1G3TOOQO'#Iz'#IzO9hQ!0LrO'#IzO&9fQpO,5=rOOQ[,5=r,5=rO&9mQpO'#EdO&9tQpO'#GcO&9yQ`O7+(wO&:OQ`O7+(wOOQ[7+(w7+(wO!&fQMhO7+(wO%[QlO7+(wO&:WQ`O7+(wOOQ[7+(y7+(yO9hQ!0LrO7+(yO$#sQ`O7+(yO9RQ`O7+(yO!B_QpO7+(yO&:cQ`O,5?gOOQO-E<y-E<yOOQO'#HZ'#HZO&:nQ`O1G6fO9hQ!0LrO<<GqOOQ[<<Gq<<GqO@fQ`O<<GqO&:vQ`O7+,TO&:{Q`O7+,UO%[QlO7+,TO%[QlO7+,UOOQ[7+)R7+)RO&;QQ`O7+)RO&;VQlO7+)RO&;^Q`O7+)ROOQ[<<Lu<<LuOOQ[<<Lw<<LwOOQ[-E<|-E<|OOQ[1G3v1G3vO&;cQ`O,5>]OOQ[,5>_,5>_O&;hQ`O1G3|O9WQ`O7+&cO!(vQlO7+&cOOQO7+%[7+%[O&;mQ?MtO1G6VO>tQ`O7+%[OOQ!0Lf<<I^<<I^OOQ!0Lf<<Iw<<IwO>tQ`O<<IwOOQO<<Ip<<IpO$?aQ!0MxO<<IpO%[QlO<<IpOOQO<<Ia<<IaO!BSQ!0LrO<<IaO&;wQ!0LrO<<IpO&<SQ!0MxO<= YO&<dQ`O<= XOOQO7+*Z7+*ZO9WQ`O7+*ZOOQ[ANAhANAhO&<lQ!fOANAhO!&fQMhOANAhO#']Q`OANAhO4UQ!fOANAhO&<sQ`OANAhO%[QlOANAhO&<{Q!0MzO7+'xO&?^Q!0MzO,5?]O&AiQ!0MzO,5?_O&CtQ!0MzO7+'zO&FVQ!fO1G4hO&FaQ?MtO7+&^O&HeQ?MvO,5=UO&JlQ?MvO,5=WO&J|Q?MvO,5=UO&K^Q?MvO,5=WO&KnQ?MvO,59rO&MtQ?MvO,5<iO' wQ?MvO,5<kO'$]Q?MvO,5<yO'&RQ?MtO7+'jO'&`Q?MtO7+'kO'&mQ`O,5<[OOQO7+'_7+'_OOQ!0Lh7+*`7+*`O'&rQMjO<<KzOOQO1G4s1G4sO'&yQ`O1G4sO''UQ`O1G4sO''dQ`O7++yO''dQ`O7++yO!&fQMhO1G4uO''lQ!dO1G4uO''vQ`O7++zO'(OQ`O7+(TO'(ZQ!dO7+(TOOQ!0Lb7+(R7+(ROOQ!0Lb7+(S7+(SO!B_QpO7+(ROCcQ`O7+(RO'(eQ`O7+(TO!&fQMhO7+(TO$)QQ`O7+(SO'(jQ`O7+(TOCcQ`O7+(SO'(rQMjO<<NsOOQ!0Lh7+$z7+$zO'(|Q!dO,5?bOOQO-E<t-E<tO')WQ!0MvO7+(WOOQ[AN=gAN=gO9^Q`O1G5SOOQO1G5S1G5SO')hQ`O1G5SO')mQ`O7+,SO')mQ`O7+,SO9hQ!0LrOANBTO@fQ`OANBTOOQ[ANBTANBTOOQ[ANApANApOOQ[ANAqANAqO')uQ`O,5?dOOQO-E<v-E<vO'*QQ?MtO1G6eOOQO,5?f,5?fOOQO-E<x-E<xOOQ[1G3^1G3^O'*[Q`O,5<}OOQ[<<Lc<<LcO!&fQMhO<<LcO&9yQ`O<<LcO'*aQ`O<<LcO%[QlO<<LcOOQ[<<Le<<LeO9hQ!0LrO<<LeO$#sQ`O<<LeO9RQ`O<<LeO'*iQpO1G5RO'*tQ`O7+,QOOQ[AN=]AN=]O9hQ!0LrOAN=]OOQ[<= o<= oOOQ[<= p<= pO'*|Q`O<= oO'+RQ`O<= pOOQ[<<Lm<<LmO'+WQ`O<<LmO'+]QlO<<LmOOQ[1G3w1G3wO>tQ`O7+)hO'+dQ`O<<I}O'+oQ?MtO<<I}OOQO<<Hv<<HvOOQ!0LfAN?cAN?cOOQOAN?[AN?[O$?aQ!0MxOAN?[OOQOAN>{AN>{O%[QlOAN?[OOQO<<Mu<<MuOOQ[G27SG27SO!&fQMhOG27SO#']Q`OG27SO'+yQ!fOG27SO4UQ!fOG27SO',QQ`OG27SO',YQ?MtO<<JeO',gQ?MvO1G2^O'.]Q?MvO,5?]O'0`Q?MvO,5?_O'2cQ?MvO1G2pO'4fQ?MvO1G2rO'6iQ?MtO<<KVO'6vQ?MtO<<IxOOQO1G1v1G1vO!+oQMhOANAfOOQO7+*_7+*_O'7TQ`O7+*_O'7`Q`O<= eO'7hQ!dO7+*aOOQ!0Lb<<Ko<<KoO$)QQ`O<<KoOCcQ`O<<KoO'7rQ`O<<KoO!&fQMhO<<KoOOQ!0Lb<<Km<<KmO!B_QpO<<KmO'7}Q!dO<<KoOOQ!0Lb<<Kn<<KnO'8XQ`O<<KoO!&fQMhO<<KoO$)QQ`O<<KnOOQO7+*n7+*nO9^Q`O7+*nO'8^Q`O<= nOOQ[G27oG27oO9hQ!0LrOG27oO!(vQlO1G5OO'8fQ`O7+,PO'8nQ`O1G2iO&9yQ`OANA}OOQ[ANA}ANA}O!&fQMhOANA}O'8sQ`OANA}OOQ[ANBPANBPO9hQ!0LrOANBPO$#sQ`OANBPOOQO'#H['#H[OOQO7+*m7+*mOOQ[G22wG22wOOQ[ANEZANEZOOQ[ANE[ANE[OOQ[ANBXANBXO'8{Q`OANBXOOQ[<<MS<<MSO!(vQlOAN?iOOQOG24vG24vO$?aQ!0MxOG24vO#']Q`OLD,nOOQ[LD,nLD,nO!&fQMhOLD,nO'9QQ!fOLD,nO'9XQ?MvO7+'xO':}Q?MvO,5?]O'=QQ?MvO,5?_O'?TQ?MvO7+'zO'@yQMjOG27QOOQO<<My<<MyOOQ!0LbANAZANAZO$)QQ`OANAZOCcQ`OANAZO'AZQ!dOANAZOOQ!0LbANAXANAXO'AbQ`OANAZO!&fQMhOANAZO'AmQ!dOANAZOOQ!0LbANAYANAYOOQO<<NY<<NYOOQ[LD-ZLD-ZO'AwQ?MtO7+*jOOQO'#Gd'#GdOOQ[G27iG27iO&9yQ`OG27iO!&fQMhOG27iOOQ[G27kG27kO9hQ!0LrOG27kOOQ[G27sG27sO'BRQ?MtOG25TOOQOLD*bLD*bOOQ[!$(!Y!$(!YO#']Q`O!$(!YO!&fQMhO!$(!YO'B]Q!0MzOG27QOOQ!0LbG26uG26uO$)QQ`OG26uO'DnQ`OG26uOCcQ`OG26uO'DyQ!dOG26uO!&fQMhOG26uOOQ[LD-TLD-TO&9yQ`OLD-TOOQ[LD-VLD-VOOQ[!)9Et!)9EtO#']Q`O!)9EtOOQ!0LbLD,aLD,aO$)QQ`OLD,aOCcQ`OLD,aO'EQQ`OLD,aO'E]Q!dOLD,aOOQ[!$(!o!$(!oOOQ[!.K;`!.K;`O'EdQ?MvOG27QOOQ!0Lb!$( {!$( {O$)QQ`O!$( {OCcQ`O!$( {O'GYQ`O!$( {OOQ!0Lb!)9Eg!)9EgO$)QQ`O!)9EgOCcQ`O!)9EgOOQ!0Lb!.K;R!.K;RO$)QQ`O!.K;ROOQ!0Lb!4/0m!4/0mO!(vQlO'#DwO1PQ`O'#EUO'GeQ!fO'#JnO'GlQ!L^O'#DsO'GsQlO'#D{O'GzQ!fO'#CiO'JbQ!fO'#CiO!(vQlO'#D}O'JrQlO,5;WO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO'#IlO'LuQ`O,5<gO!(vQlO,5;bO'L}QMhO,5;bO'NhQMhO,5;bO!(vQlO,5;vO!&fQMhO'#GjO'L}QMhO'#GjO!&fQMhO'#GlO'L}QMhO'#GlO1SQ`O'#DWO1SQ`O'#DWO!&fQMhO'#F}O'L}QMhO'#F}O!&fQMhO'#GPO'L}QMhO'#GPO!&fQMhO'#G_O'L}QMhO'#G_O!(vQlO,5:gO'NoQpO'#D[O'NyQpO'#JrO!(vQlO,5@kO'JrQlO1G0rO( TQ?MtO'#CiO!(vQlO1G2OO!&fQMhO'#IqO'L}QMhO'#IqO!&fQMhO'#IsO'L}QMhO'#IsO( _Q!dO'#CrO!&fQMhO,5<rO'L}QMhO,5<rO'JrQlO1G2PO!(vQlO7+&yO!&fQMhO1G2^O'L}QMhO1G2^O!&fQMhO'#IqO'L}QMhO'#IqO!&fQMhO'#IsO'L}QMhO'#IsO!&fQMhO1G2`O'L}QMhO1G2`O'JrQlO7+'kO'JrQlO7+&^O!&fQMhOANAfO'L}QMhOANAfO( rQ`O'#ElO( wQ`O'#ElO(!PQ`O'#F[O(!UQ`O'#EvO(!ZQ`O'#KPO(!fQ`O'#J}O(!qQ`O,5;WO(!vQMjO,5<dO(!}Q`O'#GWO(#SQ`O'#GWO(#XQ`O,5<eO(#aQ`O,5;WO(#iQ?MtO1G1_O(#pQ`O,5<rO(#uQ`O,5<rO(#zQ`O,5<tO($PQ`O,5<tO($UQ`O1G2PO($ZQ`O1G0rO($`QMjO<<KzO($gQMjO<<KzO7eQMhO'#FzO9RQ`O'#FyOAaQ`O'#EkO!(vQlO,5;sO!3ZQ`O'#GWO!3ZQ`O'#GWO!3ZQ`O'#GYO!3ZQ`O'#GYO!+oQMhO7+(`O!+oQMhO7+(`O%,oQ!dO1G2tO%,oQ!dO1G2tO!&fQMhO,5=YO!&fQMhO,5=Y",
        stateData: "(%k~O'xOS'yOSTOS'zRQ~OPYOQYOSfOY!VOaqOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#t!PO$V|O%e}O%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO&S!WO&Y!XO&[!YO&^!ZO&`![O&c!]O&i!^O&o!_O&q!`O&s!aO&u!bO&w!cO(PSO(RTO(UUO(]VO(k[O(ziO~OWtO~P`OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oa!wOp!nO!P!oO!_!yO!`!vO!a!vO!y;kO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO(Q!lO(RTO(UUO(a!mO(k!sO~O'z!{O~OP]XR]X[]Xa]Xo]X}]X!P]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X'v]X(]]X(n]X(u]X(v]X~O!d%PX~P(qO_!}O(R#PO(S!}O(T#PO~O_#QO(T#PO(U#PO(V#QO~Ou#SO!R#TO(^#TO(_#VO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P;oO(RTO(UUO(]VO(k[O(ziO~O!X#ZO!Y#WO!V(dP!V(rP~P+}O!Z#cO~P`OPYOQYOSfOd!jOe!iOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(RTO(UUO(]VO(k[O(ziO~Om#mO!X#iO!y]O#f#lO#g#iO(P;pO!h(oP~P.iO!i#oO(P#nO~O!u#sO!y]O%e#tO~O#h#uO~O!d#vO#h#uO~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y$_O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~Oa(bX'v(bX's(bX!h(bX!V(bX![(bX%f(bX!d(bX~P1qO#P$dO#]$eO$P$eOP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#s(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX![(cX%f(cX~Oa(cX'v(cX's(cX!V(cX!h(cXs(cX!d(cX~P4UO#]$eO~O$[$hO$^$gO$e$mO~OSfO![$nO$h$oO$j$qO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(P$sO(RTO(UUO(]$uO(u$}O(v%POg(YP~O!i%cO~O!P%fO![%gO(P%eO~O!d%kO~Oa%lO'v%lO~O}%pO~P%[O(Q!lO~P%[O%k%tO~P%[Oh%VO!i%cO(P%eO(Q!lO~Oe%{O!i%cO(P%eO~O#s$RO~O}&QO![%}O!i&PO%g&TO(P%eO(Q!lO(RTO(UUO`)TP~O!u#sO~O%p&VO!P)PX![)PX(P)PX~O(P&WO~O!r&]O#t!PO%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO~Od&bOe&aO!u&_O%e&`O%x&^O~P;|Od&eOeyO![&dO!r&]O!uxO!y]O#t!PO%e}O%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO~Ob&hO#]&kO%g&fO(Q!lO~P=RO!i&lO!r&pO~O!i#oO~O![XO~Oa%lO't&xO'v%lO~Oa%lO't&{O'v%lO~Oa%lO't&}O'v%lO~O's]X!V]Xs]X!h]X&W]X![]X%f]X!d]X~P(qO!_'[O!`'TO!a'TO(Q!lO(RTO(UUO~Op'RO!P'QO!X'UO(a'PO!Z(eP!Z(tP~P@YOk'_O![']O(P%eO~Oe'dO!i%cO(P%eO~O}&QO!i&PO~Op!nO!P!oO!y;kO#Q!pO#R!pO#T!pO#U!pO(Q!lO(RTO(UUO(a!mO(k!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAtOa%lOh%VO!d#vO!i%cO'v%lO(n'mO~O!m'qO#]'oO~PCSOp!nO!P!oO(RTO(UUO(a!mO(k!sO~O![XOp(iX!P(iX!_(iX!`(iX!a(iX!y(iX#Q(iX#R(iX#S(iX#T(iX#U(iX#X(iX#Y(iX(Q(iX(R(iX(U(iX(a(iX(k(iX~O!`'iO!a'iO(Q!lO~PCrO'{'uO'|'uO'}'wO~O_!}O(R'yO(S!}O(T'yO~O_#QO(T'yO(U'yO(V#QO~Os'{O~P%[Ou#SO!R#TO(^#TO(_(OO~O!X(QO!V'SX!V'YX!Y'SX!Y'YX~P+}O!Y(SO!V(dX~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y(SO!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~O!V(dX~PGmO!V(XO~O!V(qX!Y(qX!d(qX!h(qX(n(qX~O#](qX#h#aX!Z(qX~PIpO#](YO!V(sX!Y(sX~O!Y(ZO!V(rX~O!V(^O~O#]$eO~PIpO!Z(_O~P`OR#zO}#yO!P#{O!i#xO(]VOP!ka[!kao!ka!Y!ka!m!ka#O!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#q!ka#r!ka#s!ka#u!ka#w!ka#y!ka#z!ka(n!ka(u!ka(v!ka~Oa!ka'v!ka's!ka!V!ka!h!kas!ka![!ka%f!ka!d!ka~PKWO!h(`O~O!d#vO#](aO(n'mO!Y(pXa(pX'v(pX~O!h(pX~PMsO!P%fO![%gO!y]O#f(fO#g(eO(P%eO~O!Y(gO!h(oX~O!h(iO~O!P%fO![%gO#g(eO(P%eO~OP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#s(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX~O!d#vO!h(cX~P! aOR(kO}(jO!i#xO#P$dO!y!xa!P!xa~O!u!xa%e!xa![!xa#f!xa#g!xa(P!xa~P!#bO!u(oO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~O#h(uO~O!X(wO!h(gP~P%[O(a(yO(k[O~O!P({O!i#xO(a(yO(k[O~OP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![!eO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(P)YO(RTO(UUO(]VO(k[O(z=dO~O!Y$_Oa$oa'v$oa's$oa!h$oa!V$oa![$oa%f$oa!d$oa~O#t)aO~P!&fOh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~Og(lP~P!+oO})fO!d)eO![$]X$Y$]X$[$]X$^$]X$e$]X~O!d)eO![(wX$Y(wX$[(wX$^(wX$e(wX~O})fO~P!-xO})fO![(wX$Y(wX$[(wX$^(wX$e(wX~O![)hO$Y)lO$[)gO$^)gO$e)mO~O!X)pO~P!(vO$[$hO$^$gO$e)tO~Ok$xX}$xX#P$xX'u$xX(u$xX(v$xX~OgjXg$xXkjX!YjX#]jX~P!/nOu)vO(^)wO(_)yO~Ok*SO}){O'u)|O(u$}O(v%PO~Og)zO~P!0rOg*TO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P*VO![*WO!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(RTO(UUO(]$uO(u$}O(v%PO~O!X*ZO(P*UO!h({P~P!1aO#h*]O~O!i*^O~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(P*`O(RTO(UUO(]$uO(u$}O(v%PO~O!X*cO!V(|P~P!3`Oo*oOp!nO!P*eO!_*mO!`*gO!a*gO!i*^O#X*nO%]*iO(Q!lO(RTO(UUO(a!mO~O!Z*lO~P!5TO#P$dOk([X}([X'u([X(u([X(v([X!Y([X#]([X~Og([X#}([X~P!6VOk*tO#]*sOg(ZX!Y(ZX~O!Y*uOg(YX~O(P&WOg(YP~Op*xO~O!i*}O~O(P(sO~Om+RO!P%fO!X#iO![%gO!y]O#f#lO#g#iO(P%eO!h(oP~O!d#vO#h+SO~O!P%fO!X+UO!Y(ZO![%gO(P%eO!V(rP~Op'XO!P+WO!X+VO(RTO(UUO(a(yO~O!Z(tP~P!9VO!Y+XOa)QX'v)QX~OP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~Oa!ga!Y!ga'v!ga's!ga!V!ga!h!gas!ga![!ga%f!ga!d!ga~P!9}OR#zO}#yO!P#{O!i#xO(]VOP!oa[!oao!oa!Y!oa!m!oa#O!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#q!oa#r!oa#s!oa#u!oa#w!oa#y!oa#z!oa(n!oa(u!oa(v!oa~Oa!oa'v!oa's!oa!V!oa!h!oas!oa![!oa%f!oa!d!oa~P!<eOR#zO}#yO!P#{O!i#xO(]VOP!qa[!qao!qa!Y!qa!m!qa#O!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#s!qa#u!qa#w!qa#y!qa#z!qa(n!qa(u!qa(v!qa~Oa!qa'v!qa's!qa!V!qa!h!qas!qa![!qa%f!qa!d!qa~P!>{Oh%VOk+bO![']O%f+aO~O!d+dOa(XX![(XX'v(XX!Y(XX~Oa%lO![XO'v%lO~Oh%VO!i%cO~Oh%VO!i%cO(P%eO~O!d#vO#h(uO~Ob+oO%g+pO(P+lO(RTO(UUO!Z)UP~O!Y+qO`)TX~O[+uO~O`+vO~O![%}O(P%eO(Q!lO`)TP~Oh%VO#]+{O~Oh%VOk,OO![$|O~O![,QO~O},SO![XO~O%k%tO~O!u,XO~Oe,^O~Ob,_O(P#nO(RTO(UUO!Z)SP~Oe%{O~O%g!QO(P&WO~P=RO[,dO`,cO~OPYOQYOSfOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO!fuO!iZO!lYO!mYO!nYO!pvO!uxO!y]O%e}O(RTO(UUO(]VO(k[O(ziO~O![!eO!r!gO$V!kO(P!dO~P!E{O`,cOa%lO'v%lO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oa,iO!rwO#t!OO%i!OO%j!OO%k!OO~P!HeO!i&lO~O&Y,oO~O![,qO~O&k,sO&m,tOP&haQ&haS&haY&haa&had&hae&ham&hao&hap&haq&haw&hay&ha{&ha!P&ha!T&ha!U&ha![&ha!f&ha!i&ha!l&ha!m&ha!n&ha!p&ha!r&ha!u&ha!y&ha#t&ha$V&ha%e&ha%g&ha%i&ha%j&ha%k&ha%n&ha%p&ha%s&ha%t&ha%v&ha&S&ha&Y&ha&[&ha&^&ha&`&ha&c&ha&i&ha&o&ha&q&ha&s&ha&u&ha&w&ha's&ha(P&ha(R&ha(U&ha(]&ha(k&ha(z&ha!Z&ha&a&hab&ha&f&ha~O(P,yO~Oh!bX!Y!OX!Z!OX!d!OX!d!bX!i!bX#]!OX~O!Y!bX!Z!bX~P# kO!d-OO#],}Oh(fX!Y#eX!Z#eX!d(fX!i(fX~O!Y(fX!Z(fX~P#!^Oh%VO!d-QO!i%cO!Y!^X!Z!^X~Op!nO!P!oO(RTO(UUO(a!mO~OP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![!eO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(RTO(UUO(]VO(k[O(z=dO~O(P<fO~P##sO!Y-UO!Z(eX~O!Z-WO~O!d-OO#],}O!Y#eX!Z#eX~O!Y-XO!Z(tX~O!Z-ZO~O!`-[O!a-[O(Q!lO~P##bO!Z-_O~P'_Ok-bO![']O~O!V-gO~Op!xa!_!xa!`!xa!a!xa#Q!xa#R!xa#S!xa#T!xa#U!xa#X!xa#Y!xa(Q!xa(R!xa(U!xa(a!xa(k!xa~P!#bO!m-lO#]-jO~PCSO!`-nO!a-nO(Q!lO~PCrOa%lO#]-jO'v%lO~Oa%lO!d#vO#]-jO'v%lO~Oa%lO!d#vO!m-lO#]-jO'v%lO(n'mO~O'{'uO'|'uO'}-sO~Os-tO~O!V'Sa!Y'Sa~P!9}O!X-xO!V'SX!Y'SX~P%[O!Y(SO!V(da~O!V(da~PGmO!Y(ZO!V(ra~O!P%fO!X-|O![%gO(P%eO!V'YX!Y'YX~O#].OO!Y(pa!h(paa(pa'v(pa~O!d#vO~P#+yO!Y(gO!h(oa~O!P%fO![%gO#g.SO(P%eO~Om.XO!P%fO!X.UO![%gO!y]O#f.WO#g.UO(P%eO!Y']X!h']X~OR.]O!i#xO~Oh%VOk.`O![']O%f._O~Oa#`i!Y#`i'v#`i's#`i!V#`i!h#`is#`i![#`i%f#`i!d#`i~P!9}Ok=pO}){O'u)|O(u$}O(v%PO~O#h#[aa#[a#]#[a'v#[a!Y#[a!h#[a![#[a!V#[a~P#.uO#h([XP([XR([X[([Xa([Xo([X!P([X!i([X!m([X#O([X#k([X#l([X#m([X#n([X#o([X#p([X#q([X#r([X#s([X#u([X#w([X#y([X#z([X'v([X(]([X(n([X!h([X!V([X's([Xs([X![([X%f([X!d([X~P!6VO!Y.mO!h(gX~P!9}O!h.pO~O!V.rO~OP$[OR#zO}#yO!P#{O!i#xO!m$[O(]VO[#jia#jio#ji!Y#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#k#ji~P#2eO#k$OO~P#2eOP$[OR#zOo$aO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO(]VO[#jia#ji!Y#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#o#ji~P#5SO#o$QO~P#5SOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO(]VOa#ji!Y#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#u#ji~P#7qOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO(]VO(v#}Oa#ji!Y#ji#y#ji#z#ji'v#ji(n#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#w$UO~P#:XO#w#ji~P#:XO#u$SO~P#7qOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO(]VO(u#|O(v#}Oa#ji!Y#ji#z#ji'v#ji(n#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#y#ji~P#<}O#y$WO~P#<}OP]XR]X[]Xo]X}]X!P]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X!Y]X!Z]X~O#}]X~P#?lOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO#w;yO#y;{O#z;|O(]VO(n$YO(u#|O(v#}O~O#}.tO~P#AyO#P$dO#]<SO$P<SO#}(cX!Z(cX~P! aOa'`a!Y'`a'v'`a's'`a!h'`a!V'`as'`a!['`a%f'`a!d'`a~P!9}O[#jia#jio#ji!Y#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO(]VO(u#ji(v#ji~P#D{Ok=pO}){O'u)|O(u$}O(v%POP#jiR#ji!P#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji(]#ji~P#D{O!Y.xOg(lX~P!0rOg.zO~Oa$Oi!Y$Oi'v$Oi's$Oi!V$Oi!h$Ois$Oi![$Oi%f$Oi!d$Oi~P!9}O$[.{O$^.{O~O$[.|O$^.|O~O!d)eO#].}O![$bX$Y$bX$[$bX$^$bX$e$bX~O!X/OO~O![)hO$Y/QO$[)gO$^)gO$e/RO~O!Y;}O!Z(bX~P#AyO!Z/SO~O!d)eO$e(wX~O$e/UO~Os/VO~P!&fOu)vO(^)wO(_/YO~O!P/]O~O(u$}Ok%^a}%^a'u%^a(v%^a!Y%^a#]%^a~Og%^a#}%^a~P#K}O(v%POk%`a}%`a'u%`a(u%`a!Y%`a#]%`a~Og%`a#}%`a~P#LpO!YfX!dfX!hfX!h$xX(nfX~P!/nO!X/fO!Y(ZO(P/eO!V(rP!V(|P~P!1aOo*oO!_*mO!`*gO!a*gO!i*^O#X*nO%]*iO(Q!lO(RTO(UUO~Op<cO!P/gO!X+VO!Z*lO(a<bO!Z(tP~P#NZO!h/hO~P#.uO!Y/iO!d#vO(n'mO!h({X~O!h/nO~O!P%fO!X*ZO![%gO(P%eO!h({P~O#h/pO~O!V$xX!Y$xX!d%PX~P!/nO!Y/qO!V(|X~P#.uO!d/sO~O!V/uO~OmkO(P/vO~P.iOh%VOo/{O!d#vO!i%cO(n'mO~O!d+dO~Oa%lO!Y0PO'v%lO~O!Z0RO~P!5TO!`0SO!a0SO(Q!lO~P##bOp!nO!P0TO(RTO(UUO(a!mO~O#X0VO~Og%^a!Y%^a#]%^a#}%^a~P!0rOg%`a!Y%`a#]%`a#}%`a~P!0rO(P&WOg'iX!Y'iX~O!Y*uOg(Ya~Og0`O~OR0aO}0aO!P0bO#P$dOkza'uza(uza(vza!Yza#]za~Ogza#}za~P$&ZO}){O'u)|Ok$qa(u$qa(v$qa!Y$qa#]$qa~Og$qa#}$qa~P$'VO}){O'u)|Ok$sa(u$sa(v$sa!Y$sa#]$sa~Og$sa#}$sa~P$'xO#h0eO~Og%Ra!Y%Ra#]%Ra#}%Ra~P!0rO!d#vO~O#h0hO~O!Y+XOa)Qa'v)Qa~OR#zO}#yO!P#{O!i#xO(]VOP!oi[!oio!oi!Y!oi!m!oi#O!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#q!oi#r!oi#s!oi#u!oi#w!oi#y!oi#z!oi(n!oi(u!oi(v!oi~Oa!oi'v!oi's!oi!V!oi!h!ois!oi![!oi%f!oi!d!oi~P$)gOh%VOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(RTO(UUO(]$uO(u$}O(v%PO~Om0qO(P0pO~P$+}O!d+dOa(Xa![(Xa'v(Xa!Y(Xa~O#h0wO~O[]X!YfX!ZfX~O!Y0xO!Z)UX~O!Z0zO~O[0{O~Ob0}O(P+lO(RTO(UUO~O![%}O(P%eO`'qX!Y'qX~O!Y+qO`)Ta~O!h1QO~P!9}O[1TO~O`1UO~O#]1XO~Ok1[O![$|O~O(a(yO!Z)RP~Oh%VOk1eO![1bO%f1dO~O[1oO!Y1mO!Z)SX~O!Z1pO~O`1rOa%lO'v%lO~O(P#nO(RTO(UUO~O#P$dO#]$eO$P$eOP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX~O#s1uO&W1vOa(cX~P$1eO#]$eO#s1uO&W1vO~Oa1xO~P%[Oa1zO~O&a1}OP&_iQ&_iS&_iY&_ia&_id&_ie&_im&_io&_ip&_iq&_iw&_iy&_i{&_i!P&_i!T&_i!U&_i![&_i!f&_i!i&_i!l&_i!m&_i!n&_i!p&_i!r&_i!u&_i!y&_i#t&_i$V&_i%e&_i%g&_i%i&_i%j&_i%k&_i%n&_i%p&_i%s&_i%t&_i%v&_i&S&_i&Y&_i&[&_i&^&_i&`&_i&c&_i&i&_i&o&_i&q&_i&s&_i&u&_i&w&_i's&_i(P&_i(R&_i(U&_i(]&_i(k&_i(z&_i!Z&_ib&_i&f&_i~Ob2TO!Z2RO&f2SO~P`O![XO!i2VO~O&m,tOP&hiQ&hiS&hiY&hia&hid&hie&him&hio&hip&hiq&hiw&hiy&hi{&hi!P&hi!T&hi!U&hi![&hi!f&hi!i&hi!l&hi!m&hi!n&hi!p&hi!r&hi!u&hi!y&hi#t&hi$V&hi%e&hi%g&hi%i&hi%j&hi%k&hi%n&hi%p&hi%s&hi%t&hi%v&hi&S&hi&Y&hi&[&hi&^&hi&`&hi&c&hi&i&hi&o&hi&q&hi&s&hi&u&hi&w&hi's&hi(P&hi(R&hi(U&hi(]&hi(k&hi(z&hi!Z&hi&a&hib&hi&f&hi~O!V2]O~O!Y!^a!Z!^a~P#AyOp!nO!P!oO!X2cO(a!mO!Y'TX!Z'TX~P@YO!Y-UO!Z(ea~O!Y'ZX!Z'ZX~P!9VO!Y-XO!Z(ta~O!Z2jO~P'_Oa%lO#]2sO'v%lO~Oa%lO!d#vO#]2sO'v%lO~Oa%lO!d#vO!m2wO#]2sO'v%lO(n'mO~Oa%lO'v%lO~P!9}O!Y$_Os$oa~O!V'Si!Y'Si~P!9}O!Y(SO!V(di~O!Y(ZO!V(ri~O!V(si!Y(si~P!9}O!Y(pi!h(pia(pi'v(pi~P!9}O#]2yO!Y(pi!h(pia(pi'v(pi~O!Y(gO!h(oi~O!P%fO![%gO!y]O#f3OO#g2}O(P%eO~O!P%fO![%gO#g2}O(P%eO~Ok3VO![']O%f3UO~Oh%VOk3VO![']O%f3UO~O#h%^aP%^aR%^a[%^aa%^ao%^a!P%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'v%^a(]%^a(n%^a!h%^a!V%^a's%^as%^a![%^a%f%^a!d%^a~P#K}O#h%`aP%`aR%`a[%`aa%`ao%`a!P%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'v%`a(]%`a(n%`a!h%`a!V%`a's%`as%`a![%`a%f%`a!d%`a~P#LpO#h%^aP%^aR%^a[%^aa%^ao%^a!P%^a!Y%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'v%^a(]%^a(n%^a!h%^a!V%^a's%^a#]%^as%^a![%^a%f%^a!d%^a~P#.uO#h%`aP%`aR%`a[%`aa%`ao%`a!P%`a!Y%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'v%`a(]%`a(n%`a!h%`a!V%`a's%`a#]%`as%`a![%`a%f%`a!d%`a~P#.uO#hzaPza[zaazaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza'vza(]za(nza!hza!Vza'szasza![za%fza!dza~P$&ZO#h$qaP$qaR$qa[$qaa$qao$qa!P$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa'v$qa(]$qa(n$qa!h$qa!V$qa's$qas$qa![$qa%f$qa!d$qa~P$'VO#h$saP$saR$sa[$saa$sao$sa!P$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa'v$sa(]$sa(n$sa!h$sa!V$sa's$sas$sa![$sa%f$sa!d$sa~P$'xO#h%RaP%RaR%Ra[%Raa%Rao%Ra!P%Ra!Y%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra'v%Ra(]%Ra(n%Ra!h%Ra!V%Ra's%Ra#]%Ras%Ra![%Ra%f%Ra!d%Ra~P#.uOa#`q!Y#`q'v#`q's#`q!V#`q!h#`qs#`q![#`q%f#`q!d#`q~P!9}O!X3_O!Y'UX!h'UX~P%[O!Y.mO!h(ga~O!Y.mO!h(ga~P!9}O!V3bO~O#}!ka!Z!ka~PKWO#}!ga!Y!ga!Z!ga~P#AyO#}!oa!Z!oa~P!<eO#}!qa!Z!qa~P!>{Og'XX!Y'XX~P!+oO!Y.xOg(la~OSfO![3vO$c3wO~O!Z3{O~Os3|O~P#.uOa$lq!Y$lq'v$lq's$lq!V$lq!h$lqs$lq![$lq%f$lq!d$lq~P!9}O!V4OO~P!&fO!P4PO~O}){O'u)|O(v%POk'ea(u'ea!Y'ea#]'ea~Og'ea#}'ea~P%+ZO}){O'u)|Ok'ga(u'ga(v'ga!Y'ga#]'ga~Og'ga#}'ga~P%+|O(n$YO~P#.uO!VfX!V$xX!YfX!Y$xX!d%PX#]fX~P!/nO(P<lO~P!1aO!P%fO!X4SO![%gO(P%eO!Y'aX!h'aX~O!Y/iO!h({a~O!Y/iO!d#vO!h({a~O!Y/iO!d#vO(n'mO!h({a~Og$zi!Y$zi#]$zi#}$zi~P!0rO!X4[O!V'cX!Y'cX~P!3`O!Y/qO!V(|a~O!Y/qO!V(|a~P#.uOP]XR]X[]Xo]X}]X!P]X!V]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X~O!d%WX#s%WX~P%/mO!d#vO#s4aO~Oh%VO!d#vO!i%cO~Oh%VOo4fO!i%cO(n'mO~Oo4kO!d#vO(n'mO~Op!nO!P4lO(RTO(UUO(a!mO~O(u$}Ok%^i}%^i'u%^i(v%^i!Y%^i#]%^i~Og%^i#}%^i~P%3^O(v%POk%`i}%`i'u%`i(u%`i!Y%`i#]%`i~Og%`i#}%`i~P%4POg(Zi!Y(Zi~P!0rO#]4rOg(Zi!Y(Zi~P!0rO!h4uO~Oa$mq!Y$mq'v$mq's$mq!V$mq!h$mqs$mq![$mq%f$mq!d$mq~P!9}O!V4yO~O!Y4zO![(}X~P#.uOa$xX![$xX%Z]X'v$xX!Y$xX~P!/nO%Z4}OalXklX}lX![lX'ulX'vlX(ulX(vlX!YlX~O%Z4}O~Ob5TO%g5UO(P+lO(RTO(UUO!Y'pX!Z'pX~O!Y0xO!Z)Ua~O[5YO~O`5ZO~Oa%lO'v%lO~P#.uO!Y5cO#]5eO!Z)RX~O!Z5fO~Oo5lOp!nO!P*eO!_!yO!`!vO!a!vO!y;kO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5kO#Y!zO(Q!lO(RTO(UUO(a!mO(k!sO~O!Z5jO~P%9SOk5qO![1bO%f5pO~Oh%VOk5qO![1bO%f5pO~Ob5xO(P#nO(RTO(UUO!Y'oX!Z'oX~O!Y1mO!Z)Sa~O(RTO(UUO(a5zO~O`6OO~O#s6RO&W6SO~PMsO!h6TO~P%[Oa6VO~Oa6VO~P%[Ob2TO!Z6[O&f2SO~P`O!d6^O~O!d6`Oh(fi!Y(fi!Z(fi!d(fi!i(fio(fi(n(fi~O!Y#ei!Z#ei~P#AyO#]6aO!Y#ei!Z#ei~O!Y!^i!Z!^i~P#AyOa%lO#]6jO'v%lO~Oa%lO!d#vO#]6jO'v%lO~O!Y(pq!h(pqa(pq'v(pq~P!9}O!Y(gO!h(oq~O!P%fO![%gO#g6qO(P%eO~O![']O%f6tO~Ok6xO![']O%f6tO~O#h'eaP'eaR'ea['eaa'eao'ea!P'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea'v'ea(]'ea(n'ea!h'ea!V'ea's'eas'ea!['ea%f'ea!d'ea~P%+ZO#h'gaP'gaR'ga['gaa'gao'ga!P'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga'v'ga(]'ga(n'ga!h'ga!V'ga's'gas'ga!['ga%f'ga!d'ga~P%+|O#h$ziP$ziR$zi[$zia$zio$zi!P$zi!Y$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi'v$zi(]$zi(n$zi!h$zi!V$zi's$zi#]$zis$zi![$zi%f$zi!d$zi~P#.uO#h%^iP%^iR%^i[%^ia%^io%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i'v%^i(]%^i(n%^i!h%^i!V%^i's%^is%^i![%^i%f%^i!d%^i~P%3^O#h%`iP%`iR%`i[%`ia%`io%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i'v%`i(]%`i(n%`i!h%`i!V%`i's%`is%`i![%`i%f%`i!d%`i~P%4PO!Y'Ua!h'Ua~P!9}O!Y.mO!h(gi~O#}#`i!Y#`i!Z#`i~P#AyOP$[OR#zO}#yO!P#{O!i#xO!m$[O(]VO[#jio#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#k#ji~P%LRO#k;sO~P%LROP$[OR#zOo<PO}#yO!P#{O!i#xO!m$[O#k;sO#l;tO#m;tO#n;tO(]VO[#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#o#ji~P%NZO#o;uO~P%NZOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO(]VO#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#u#ji~P&!cOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO(]VO(v#}O#y#ji#z#ji#}#ji(n#ji(u#ji!Y#ji!Z#ji~O#w;yO~P&$dO#w#ji~P&$dO#u;wO~P&!cOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO#w;yO(]VO(u#|O(v#}O#z#ji#}#ji(n#ji!Y#ji!Z#ji~O#y#ji~P&&sO#y;{O~P&&sOa#{y!Y#{y'v#{y's#{y!V#{y!h#{ys#{y![#{y%f#{y!d#{y~P!9}O[#jio#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji!Y#ji!Z#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k;sO#l;tO#m;tO#n;tO(]VO(u#ji(v#ji~P&)oOk=qO}){O'u)|O(u$}O(v%POP#jiR#ji!P#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji(]#ji~P&)oO#P$dOP([XR([X[([Xk([Xo([X}([X!P([X!i([X!m([X#O([X#k([X#l([X#m([X#n([X#o([X#p([X#q([X#r([X#s([X#u([X#w([X#y([X#z([X#}([X'u([X(]([X(n([X(u([X(v([X!Y([X!Z([X~O#}$Oi!Y$Oi!Z$Oi~P#AyO#}!oi!Z!oi~P$)gOg'Xa!Y'Xa~P!0rO!Z7[O~O!Y'`a!Z'`a~P#AyO!V7]O~P#.uO!d#vO(n'mO!Y'aa!h'aa~O!Y/iO!h({i~O!Y/iO!d#vO!h({i~Og$zq!Y$zq#]$zq#}$zq~P!0rO!V'ca!Y'ca~P#.uO!d7dO~O!Y/qO!V(|i~P#.uO!Y/qO!V(|i~O!V7gO~Oh%VOo7lO!i%cO(n'mO~O!d#vO#s7nO~Oo7qO!d#vO(n'mO~O}){O'u)|O(v%POk'fa(u'fa!Y'fa#]'fa~Og'fa#}'fa~P&2pO}){O'u)|Ok'ha(u'ha(v'ha!Y'ha#]'ha~Og'ha#}'ha~P&3cO!V7sO~Og$|q!Y$|q#]$|q#}$|q~P!0rOa$my!Y$my'v$my's$my!V$my!h$mys$my![$my%f$my!d$my~P!9}O!d6`O~O!Y4zO![(}a~O![']OP$SaR$Sa[$Sao$Sa}$Sa!P$Sa!Y$Sa!i$Sa!m$Sa#O$Sa#k$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#u$Sa#w$Sa#y$Sa#z$Sa(]$Sa(n$Sa(u$Sa(v$Sa~O%f6tO~P&5lOa#`y!Y#`y'v#`y's#`y!V#`y!h#`ys#`y![#`y%f#`y!d#`y~P!9}O[7xO~Ob7zO(P+lO(RTO(UUO~O!Y0xO!Z)Ui~O`8OO~O(a(yO!Y'lX!Z'lX~O!Y5cO!Z)Ra~O!Z8XO~P%9SO(k!sO~P$$iO#X8YO~O![1bO~O![1bO%f8[O~Ok8_O![1bO%f8[O~O[8dO!Y'oa!Z'oa~O!Y1mO!Z)Si~O!h8hO~O!h8iO~O!h8lO~O!h8lO~P%[Oa8nO~O!d8oO~O!h8pO~O!Y(si!Z(si~P#AyOa%lO#]8xO'v%lO~O!Y(py!h(pya(py'v(py~P!9}O!Y(gO!h(oy~O%f8{O~P&5lO![']O%f8{O~O#h$zqP$zqR$zq[$zqa$zqo$zq!P$zq!Y$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq'v$zq(]$zq(n$zq!h$zq!V$zq's$zq#]$zqs$zq![$zq%f$zq!d$zq~P#.uO#h'faP'faR'fa['faa'fao'fa!P'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa'v'fa(]'fa(n'fa!h'fa!V'fa's'fas'fa!['fa%f'fa!d'fa~P&2pO#h'haP'haR'ha['haa'hao'ha!P'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha'v'ha(]'ha(n'ha!h'ha!V'ha's'has'ha!['ha%f'ha!d'ha~P&3cO#h$|qP$|qR$|q[$|qa$|qo$|q!P$|q!Y$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q'v$|q(]$|q(n$|q!h$|q!V$|q's$|q#]$|qs$|q![$|q%f$|q!d$|q~P#.uO!Y'Ui!h'Ui~P!9}O#}#`q!Y#`q!Z#`q~P#AyO(u$}OP%^aR%^a[%^ao%^a!P%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a(]%^a(n%^a!Y%^a!Z%^a~Ok%^a}%^a'u%^a(v%^a~P&FnO(v%POP%`aR%`a[%`ao%`a!P%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a#}%`a(]%`a(n%`a!Y%`a!Z%`a~Ok%`a}%`a'u%`a(u%`a~P&HuOk=qO}){O'u)|O(v%PO~P&FnOk=qO}){O'u)|O(u$}O~P&HuOR0aO}0aO!P0bO#P$dOPza[zakzaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza#}za'uza(]za(nza(uza(vza!Yza!Zza~O}){O'u)|OP$qaR$qa[$qak$qao$qa!P$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa(]$qa(n$qa(u$qa(v$qa!Y$qa!Z$qa~O}){O'u)|OP$saR$sa[$sak$sao$sa!P$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa#}$sa(]$sa(n$sa(u$sa(v$sa!Y$sa!Z$sa~Ok=qO}){O'u)|O(u$}O(v%PO~OP%RaR%Ra[%Rao%Ra!P%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra#}%Ra(]%Ra(n%Ra!Y%Ra!Z%Ra~P'#zO#}$lq!Y$lq!Z$lq~P#AyO#}$mq!Y$mq!Z$mq~P#AyO!Z9YO~O#}9ZO~P!0rO!d#vO!Y'ai!h'ai~O!d#vO(n'mO!Y'ai!h'ai~O!Y/iO!h({q~O!V'ci!Y'ci~P#.uO!Y/qO!V(|q~Oo9bO!d#vO(n'mO~O[9dO!V9cO~P#.uO!V9cO~O!d#vO#s9jO~Og(Zy!Y(Zy~P!0rO!Y'ja!['ja~P#.uOa%Yq![%Yq'v%Yq!Y%Yq~P#.uO[9mO~O!Y0xO!Z)Uq~O#]9qO!Y'la!Z'la~O!Y5cO!Z)Ri~P#AyO!P9sO~O![1bO%f9vO~O(RTO(UUO(a9{O~O!Y1mO!Z)Sq~O!h:OO~O!h:PO~O!h:QO~O!h:QO~P%[O#]:TO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#AyO%f:YO~P&5lO![']O%f:YO~O#}#{y!Y#{y!Z#{y~P#AyOP$ziR$zi[$zio$zi!P$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi#}$zi(]$zi(n$zi!Y$zi!Z$zi~P'#zO}){O'u)|O(v%POP'eaR'ea['eak'eao'ea!P'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(]'ea(n'ea(u'ea!Y'ea!Z'ea~O}){O'u)|OP'gaR'ga['gak'gao'ga!P'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga#}'ga(]'ga(n'ga(u'ga(v'ga!Y'ga!Z'ga~O(u$}OP%^iR%^i[%^ik%^io%^i}%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i'u%^i(]%^i(n%^i(v%^i!Y%^i!Z%^i~O(v%POP%`iR%`i[%`ik%`io%`i}%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i#}%`i'u%`i(]%`i(n%`i(u%`i!Y%`i!Z%`i~O#}$my!Y$my!Z$my~P#AyO#}#`y!Y#`y!Z#`y~P#AyO!d#vO!Y'aq!h'aq~O!Y/iO!h({y~O!V'cq!Y'cq~P#.uOo:dO!d#vO(n'mO~O[:hO!V:gO~P#.uO!V:gO~O!Y0xO!Z)Uy~O!Y5cO!Z)Rq~O(P:nO~O![1bO%f:qO~O!h:tO~O%f:yO~P&5lOP$zqR$zq[$zqo$zq!P$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq(]$zq(n$zq!Y$zq!Z$zq~P'#zO}){O'u)|O(v%POP'faR'fa['fak'fao'fa!P'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(]'fa(n'fa(u'fa!Y'fa!Z'fa~O}){O'u)|OP'haR'ha['hak'hao'ha!P'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha#}'ha(]'ha(n'ha(u'ha(v'ha!Y'ha!Z'ha~OP$|qR$|q[$|qo$|q!P$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q#}$|q(]$|q(n$|q!Y$|q!Z$|q~P'#zOg%b!Z!Y%b!Z#]%b!Z#}%b!Z~P!0rO!V:}O~P#.uOo;OO!d#vO(n'mO~O[;QO!V:}O~P#.uO!Y'lq!Z'lq~P#AyO!Y#e!Z!Z#e!Z~P#AyO#h%b!ZP%b!ZR%b!Z[%b!Za%b!Zo%b!Z!P%b!Z!Y%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z'v%b!Z(]%b!Z(n%b!Z!h%b!Z!V%b!Z's%b!Z#]%b!Zs%b!Z![%b!Z%f%b!Z!d%b!Z~P#.uOo;YO!d#vO(n'mO~O!V;ZO~P#.uOo;bO!d#vO(n'mO~O!V;cO~P#.uOP%b!ZR%b!Z[%b!Zo%b!Z!P%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z#}%b!Z(]%b!Z(n%b!Z!Y%b!Z!Z%b!Z~P'#zOo;fO!d#vO(n'mO~Os(bX~P1qO}%pO~P!(vO(Q!lO~P!(vO!VfX!YfX#]fX~P%/mOP]XR]X[]Xo]X}]X!P]X!Y]X!YfX!i]X!m]X#O]X#P]X#]]X#]fX#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X~O!dfX!h]X!hfX(nfX~P'HXOP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![XO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(P)YO(RTO(UUO(]VO(k[O(z=dO~O!Y;}O!Z$oa~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<YO!P${O![$|O!f=kO!i$xO#g<`O$V%_O$r<[O$t<^O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~O#t)aO~P'L}Oo!bX(n!bX~P# kOo(fX(n(fX~P#!^O!Z]X!ZfX~P'HXO!VfX!V$xX!YfX!Y$xX#]fX~P!/nO#h;rO~O!d#vO#h;rO~O#]<SO~O#s;vO~O#]<dO!Y(sX!Z(sX~O#]<SO!Y(qX!Z(qX~O#h<eO~Og<gO~P!0rO#h<mO~O#h<nO~O!d#vO#h<oO~O!d#vO#h<eO~O#}<pO~P#AyO#h<qO~O#h<rO~O#h<wO~O#h<xO~O#h<yO~O#h<zO~O#}<{O~P!0rO#}<|O~P!0rO#P#Q#R#T#U#X#f#g#r(z$r$t$w%Z%e%f%g%n%p%s%t%v%x~'zT#l!U'x(Q#mp#k#no}'y$['y(P$^(a~",
        goto: "$6w)YPPPPPP)ZPP)^P)oP+P/RPPPP6XPP6oPP<g@VP@jP@jPPP@jPBnP@jP@jP@jPBrPBwPCfPH`PPPHdPPPPHdKgPPPKmL_PHdPHdPPNmHdPPPHdPHdP!!tHdP!&[!'a!'jP!(^!(b!(^!+oPPPPPPP!,`!'aPP!,p!.bP!1nHdHd!1s!5P!9m!9m!=lPPP!=tHdPPPPPPPPPPP!ATP!BbPPHd!CsPHdPHdHdHdHdHdPHd!EVP!HaP!KgP!Kk!Ku!Ky!KyP!H^P!K}!K}P# TP# XHdHd# _#$dBr@jP@jP@j@jP#%q@j@j#(P@j#*s@j#,{@j@j#-k#/{#/{#0Q#0Z#/{#0fP#/{P@j#1O@j#4u@j@j6XPPP#8rPPP#9]#9]P#9]P#9s#9]PP#9yP#9pP#9p#:^#9p#:x#;O#;R)^#;U)^P#;]#;]#;]P)^P)^P)^P)^PP)^P#;c#;fP#;f)^P#;jP#;mP)^P)^P)^P)^P)^P)^)^PP#;s#;y#<U#<[#<b#<h#<n#<|#=S#=^#=d#=n#=t#>U#>[#>|#?`#?f#?l#?z#@a#BQ#B`#Bg#C}#D]#Ey#FX#F_#Fe#Fk#Fu#F{#GR#G]#Go#GuPPPPPPPPPPP#G{PPPPPPP#Hp#Kw#Ma#Mh#MpPPP$%OP$%X$(Q$.k$.n$.q$/p$/s$/z$0SP$0Y$0]P$0y$0}$1u$3T$3Y$3pPP$3u$3{$4PP$4S$4W$4[$5W$5o$6W$6[$6_$6b$6h$6k$6o$6sR!|RoqOXst!Z#d%k&o&q&r&t,l,q1}2QY!vQ']-^1b5iQ%rvQ%zyQ&R|Q&g!VS'T!e-UQ'c!iS'i!r!yU*g$|*W*kQ+j%{Q+w&TQ,]&aQ-['[Q-f'dQ-n'jQ0S*mQ1l,^R<a;n%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W,i,l,q-b-j-x.O.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3_4l5q6R6S6V6j8_8n8xS#q];k!r)[$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gU*z%[<X<YQ+o%}Q,_&dQ,f&lQ0n+bQ0r+dQ0}+pQ1t,dQ3R.`Q5T0xQ5x1mQ6v3VQ7z5UR9O6x'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g!S!nQ!r!v!y!z$|'T'[']'i'j'k*g*k*m*n-U-[-^-n0S0V1b5i5k%S$ti#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qQ&U|Q'R!eS'X%g-XQ+o%}Q,_&dQ0d*}Q0}+pQ1S+vQ1s,cQ1t,dQ5T0xQ5^1UQ5x1mQ5{1oQ5|1rQ7z5UQ7}5ZQ8g6OQ9p8OQ9|8dR<c*WrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QR,a&h&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=f=g[#]WZ#W#Z'U(Q!b%hm#h#i#l$x%c%f(Z(e(f(g*V*Z*^+U+V+X,h-O-|.S.T.U.W/f/i2V2}3O4S6`6qQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(n#sS+i%z%{Q+m%}Q,W&_Q,[&aS-e'c'dQ.b(oQ0v+jQ0|+pQ1O+qQ1R+uQ1g,XS1k,],^Q2o-fQ5S0xQ5W0{Q5]1TQ5w1lQ7y5UQ7|5YQ9l7xR:k9m!O$zi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m!^%wy!i!u%y%z%{'S'b'c'd'h'r*f+i+j-R-e-f-m/y/|0v2h2o2v4d4e4h7k9fQ+c%uQ+|&XQ,P&YQ,Z&aQ.a(nQ1f,WU1j,[,],^Q3W.bQ5r1gS5v1k1lQ8c5w#d=h#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qo=i<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|W%Ti%V*u=dS&X!Q&fQ&Y!RQ&Z!SR+z&V%T%Si#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qT)w$u)xV*z%[<X<YW'X!e%g*W-XS(z#y#zQ+^%pQ+t&QS.Z(j(kQ1],QQ4s0aR8S5c'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g$i$^c#Y#e%o%q%s(P(V(q(v)O)P)Q)R)S)T)U)V)W)X)Z)])_)d)n+_+s-S-q-v-{-}.l.o.s.u.v.w/Z0f2^2a2q2x3^3c3d3e3f3g3h3i3j3k3l3m3n3o3r3s3z4w5Q6c6i6n6}7O7X7Y8U8r8v9Q9W9X:V:m:u;l=ZT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ'V!eR2d-U!W!nQ!e!r!v!y!z$|'T'[']'i'j'k*W*g*k*m*n-U-[-^-n0S0V1b5i5kR1_,SnqOXst!Z#d%k&o&q&r&t,l,q1}2QQ&v!^Q's!xS(p#u;rQ+g%xQ,U&[Q,V&^Q-c'aQ-p'lS.k(u<eS0g+S<oQ0t+hQ1a,TQ2U,sQ2W,tQ2`-PQ2m-dQ2p-hS4x0h<yQ5O0uS5R0w<zQ6b2bQ6f2nQ6k2uQ7w5PQ8s6dQ8t6gQ8w6lR:S8p$d$]c#Y#e%q%s(P(V(q(v)O)P)Q)R)S)T)U)V)W)X)Z)])_)d)n+_+s-S-q-v-{-}.l.o.s.v.w/Z0f2^2a2q2x3^3c3d3e3f3g3h3i3j3k3l3m3n3o3r3s3z4w5Q6c6i6n6}7O7X7Y8U8r8v9Q9W9X:V:m:u;l=ZS(l#p'fQ(|#zS+]%o.uS.[(k(mR3P.]'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gS#q];kQ&q!XQ&r!YQ&t![Q&u!]R1|,oQ'^!hQ+`%uQ-a'`S.^(n+cQ2k-`W3T.a.b0m0oQ6e2lW6r3Q3S3W4|U8z6s6u6wU:X8|8}9PS:w:W:ZQ;U:xR;^;VU!wQ']-^T5g1b5i!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(g,l,q.T1}2Q]!pQ!r']-^1b5iT#q];k%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xS(z#y#zS.Z(j(k!s=Q$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gU$fd)[,fS(m#p'fU*r%R(t3qU0c*y.g7TQ4|0nQ6s3RQ8}6vR:Z9Om!tQ!r!v!y!z']'i'j'k-^-n1b5i5kQ'q!uS(c#g1wS-l'h'tQ/l*YQ/y*fQ2w-oQ4W/mQ4d/{Q4e/|Q4j0UQ7`4RS7k4f4hS7o4k4mQ9]7aQ9a7gQ9f7lQ9k7qS:c9b9cS:|:d:gS;X:};OS;a;Y;ZS;e;b;cR;h;fQ#wbQ'p!uS(b#g1wS(d#m+RQ+T%dQ+e%vQ+k%|U-k'h'q'tQ.P(cQ/k*YQ/z*fQ/}*hQ0s+fQ1h,YS2t-l-oQ2|.XS4V/l/mQ4`/wS4c/y0UQ4g0OQ5t1iQ6m2wQ7_4RQ7c4WU7j4d4j4mQ7m4iQ8a5uS9[7`7aQ9`7gQ9h7oQ9i7pQ9y8bQ:a9]S:b9a9cQ:j9kQ:s9zS:{:c:gS;W:|:}S;`;X;ZS;d;a;cQ;g;eQ;i;hQ=T=OQ=`=XR=a=YV!wQ']-^%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xS#wz!j!r<}$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gR=T=f%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xQ%dj!^%vy!i!u%y%z%{'S'b'c'd'h'r*f+i+j-R-e-f-m/y/|0v2h2o2v4d4e4h7k9fS%|z!jQ+f%wQ,Y&aW1i,Z,[,],^U5u1j1k1lS8b5v5wQ9z8c!r=O$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ=X=eR=Y=f%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xY#bWZ#W#Z(Q!b%hm#h#i#l$x%c%f(Z(e(f(g*V*Z*^+U+V+X,h-O-|.S.T.U.W/f/i2V2}3O4S6`6qQ,g&l!p=P$Z$n)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gR=S'UU'Y!e%g*WR2f-X%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W,i,l,q-b-j-x.O.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3_4l5q6R6S6V6j8_8n8x!r)[$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ,f&lQ0n+bQ3R.`Q6v3VR9O6x!b$Tc#Y%o(P(V(q(v)W)X)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;l!P;x)Z)n-S.u2^2a3c3l3m3r3z6c7O7X7Y8U8r9Q9W9X:m:u=Z!f$Vc#Y%o(P(V(q(v)T)U)W)X)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;l!T;z)Z)n-S.u2^2a3c3i3j3l3m3r3z6c7O7X7Y8U8r9Q9W9X:m:u=Z!^$Zc#Y%o(P(V(q(v)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;lQ4Q/dz=g)Z)n-S.u2^2a3c3r3z6c7O7X7Y8U8r9Q9W9X:m:u=ZQ=l=nR=m=o'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gS$oh$pR3w.}'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t.}/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gT$kf$qQ$ifS)g$l)kR)s$qT$jf$qT)i$l)k'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t.}/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gT$oh$pQ$rhR)r$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8x!s=e$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g#glOPXZst!Z!`!o#S#d#o#{$n%k&h&k&l&o&q&r&t&x'Q'_({)p*e+W+b,i,l,q-b.`/O/g0T0b1e1u1v1x1z1}2Q2S3V3v4l5q6R6S6V6x8_8n!O%Ri$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m#d(t#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qQ+O%`Q/[){o3q<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!O$yi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mQ*_$zU*h$|*W*kQ+P%aQ0O*i#d=V#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn=W<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|Q=[=hQ=]=iQ=^=jR=_=k!O%Ri$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m#d(t#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qo3q<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|noOXst!Z#d%k&o&q&r&t,l,q1}2QS*b${*VQ,z&{Q,{&}R4Z/q%S%Si#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qQ+}&YQ1Z,PQ5a1YR8R5bV*j$|*W*kU*j$|*W*kT5h1b5iS/w*e/gQ4i0TT7p4l9sQ+e%vQ/}*hQ0s+fQ1h,YQ5t1iQ8a5uQ9y8bR:s9z!O%Oi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mr*O$v)b*P*q+Q/o0[0]3t4X4v7^7r:`=U=b=cS0W*p0X#d<T#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn<U<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!b<h(r)`*X*a.c.f.j/W/d/t0l1W3Z3}4Y4^5`6y6|7e7h7t7v9_9g:e:i:z;P;[=n=o`<i3p7P7S7W9R:[:_;_S<s.e3[T<t7R9U!O%Qi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mv*Q$v)b*R*p+Q/`/o0[0]3t4X4n4v7^7r:`=U=b=cS0Y*q0Z#d<V#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn<W<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!f<j(r)`*X*a.d.e.j/W/d/t0l1W3X3Z3}4Y4^5`6y6z6|7e7h7t7v9_9g:e:i:z;P;[=n=od<k3p7Q7R7W9R9S:[:]:_;_S<u.f3]T<v7S9VrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QQ&c!UR,i&lrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QR&c!UQ,R&ZR1V+zsnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QQ1c,WS5o1f1gU8Z5m5n5rS9u8]8^S:o9t9wQ;R:pR;];SQ&j!VR,b&fR5{1oR9|8dS&O|&TR1O+qQ&o!WR,l&pR,r&uT2O,q2QR,v&vQ,u&vR2X,vQ'v!{R-r'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)x$uR/X)xQ#UVR'}#UQ#XWU(T#X(U-yQ(U#YR-y(VQ-V'VR2e-VQ.n(vS3`.n3aR3a.oQ-^']R2i-^Y!rQ']-^1b5iR'g!rQ.y)bR3u.yU#_W%f*VU([#_(]-zQ(]#`R-z(WQ-Y'YR2g-Yt`OXst!V!Z#d%k&f&h&o&q&r&t,l,q1}2QS#hZ%cU#r`#h.TR.T(gQ(h#jQ.Q(dW.Y(h.Q2z6oQ2z.RR6o2{Q)k$lR/P)kQ$phR)q$pQ$`cU)^$`-u<OQ-u;lR<O)nQ/j*YW4T/j4U7b9^U4U/k/l/mS7b4V4WR9^7c$])}$v(r)`)b*X*a*p*q*{*|+Q.e.f.h.i.j/W/`/b/d/o/t0[0]0l1W3X3Y3Z3p3t3}4X4Y4^4n4p4v5`6y6z6{6|7R7S7U7V7W7^7e7h7r7t7v9R9S9T9_9g:[:]:^:_:`:e:i:z;P;[;_=U=b=c=n=oQ/r*aU4]/r4_7fQ4_/tR7f4^S*k$|*WR0Q*kr*P$v)b*p*q+Q/o0[0]3t4X4v7^7r:`=U=b=c!b.c(r)`*X*a.e.f.j/W/d/t0l1W3Z3}4Y4^5`6y6|7e7h7t7v9_9g:e:i:z;P;[=n=oU/a*P.c7Pa7P3p7R7S7W9R:[:_;_Q0X*pQ3[.eU4o0X3[9UR9U7Rv*R$v)b*p*q+Q/`/o0[0]3t4X4n4v7^7r:`=U=b=c!f.d(r)`*X*a.e.f.j/W/d/t0l1W3X3Z3}4Y4^5`6y6z6|7e7h7t7v9_9g:e:i:z;P;[=n=oU/c*R.d7Qe7Q3p7R7S7W9R9S:[:]:_;_Q0Z*qQ3].fU4q0Z3]9VR9V7SQ*v%UR0_*vQ4{0lR7u4{Q+Y%iR0k+YQ5d1]S8T5d9rR9r8UQ,T&[R1`,TQ5i1bR8W5iQ1n,_S5y1n8eR8e5{Q0y+mW5V0y5X7{9nQ5X0|Q7{5WR9n7|Q+r&OR1P+rQ2Q,qR6Z2QYrOXst#dQ&s!ZQ+[%kQ,k&oQ,m&qQ,n&rQ,p&tQ1{,lS2O,q2QR6Y1}Q%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Z%jQ+g%xQ+y&UQ,a&jQ,x&yW-i'h'p'q'tQ-p'lQ0P*jQ0t+hS1q,b,eQ2Y,wQ2Z,zQ2[,{Q2p-hW2r-k-l-o-qQ5O0uQ5[1SQ5_1WQ5s1hQ5}1sQ6X1|U6h2q2t2wQ6k2uQ7w5PQ8P5^Q8Q5`Q8V5hQ8`5tQ8f5|S8u6i6mQ8w6lQ9o7}Q9x8aQ9}8gQ:U8vQ:l9pQ:r9yQ:v:VR;T:sQ%xyQ'a!iQ'l!uU+h%y%z%{Q-P'SU-d'b'c'dS-h'h'rQ/x*fS0u+i+jQ2b-RS2n-e-fQ2u-mS4b/y/|Q5P0vQ6d2hQ6g2oQ6l2vU7i4d4e4hQ9e7kR:f9fS$wi=dR*w%VU%Ui%V=dR0^*uQ$viS(r#v+dS)`$b$cQ)b$dQ*X$xS*a${*VQ*p%OQ*q%QQ*{%]Q*|%^Q+Q%bQ.e<TQ.f<VQ.h<ZQ.i<]Q.j<_Q/W)vQ/`*OQ/b*QQ/d*SQ/o*]S/t*c/fQ0[*sQ0]*tl0l+a,O._1[1d3U5p6t8[8{9v:Y:q:yQ1W+{Q3X<hQ3Y<jQ3Z<mS3p<Q<RQ3t.xS3}/]4PQ4X/pQ4Y/qQ4^/sQ4n0WQ4p0YQ4v0eQ5`1XQ6y<qQ6z<sQ6{<uQ6|<wQ7R<UQ7S<WQ7U<[Q7V<^Q7W<`Q7^4QQ7e4[Q7h4aQ7r4rQ7t4zQ7v4}Q9R<nQ9S<iQ9T<kQ9_7dQ9g7nQ:[<rQ:]<tQ:^<vQ:_<xQ:`9ZQ:e9dQ:i9jQ:z<{Q;P:hQ;[;QQ;_<|Q=U=dQ=b=lQ=c=mQ=n=pR=o=qQ*y%[Q.g<XR7T<YnpOXst!Z#d%k&o&q&r&t,l,q1}2QQ!fPS#fZ#oQ&y!`W'e!o*e0T4lQ'|#SQ(}#{Q)o$nS,e&h&kQ,j&lQ,w&xS,|'Q/gQ-`'_Q.q({Q/T)pQ0i+WQ0o+bQ1y,iQ2l-bQ3S.`Q3y/OQ4t0bQ5n1eQ6P1uQ6Q1vQ6U1xQ6W1zQ6]2SQ6w3VQ7Z3vQ8^5qQ8j6RQ8k6SQ8m6VQ9P6xQ9w8_R:R8n#[cOPXZst!Z!`!o#d#o#{%k&h&k&l&o&q&r&t&x'Q'_({*e+W+b,i,l,q-b.`/g0T0b1e1u1v1x1z1}2Q2S3V4l5q6R6S6V6x8_8nQ#YWQ#eYQ%ouQ%qvS%sw!gS(P#W(SQ(V#ZQ(q#uQ(v#xQ)O$OQ)P$PQ)Q$QQ)R$RQ)S$SQ)T$TQ)U$UQ)V$VQ)W$WQ)X$XQ)Z$ZQ)]$_Q)_$aQ)d$eW)n$n)p/O3vQ+_%rQ+s&PS-S'U2cQ-q'oS-v(Q-xQ-{(YQ-}(aQ.l(uQ.o(wQ.s;jQ.u;mQ.v;nQ.w;qQ/Z)zQ0f+SQ2^,}Q2a-QQ2q-jQ2x.OQ3^.mQ3c;rQ3d;sQ3e;tQ3f;uQ3g;vQ3h;wQ3i;xQ3j;yQ3k;zQ3l;{Q3m;|Q3n.tQ3o<PQ3r<SQ3s<aQ3z;}Q4w0hQ5Q0wQ6c<dQ6i2sQ6n2yQ6}3_Q7O<eQ7X<gQ7Y<oQ8U5eQ8r6aQ8v6jQ9Q<pQ9W<yQ9X<zQ:V8xQ:m9qQ:u:TQ;l#SR=Z=gR#[WR'W!el!tQ!r!v!y!z']'i'j'k-^-n1b5i5kS'S!e-UU*f$|*W*kS-R'T'[S/|*g*mQ0U*nQ2h-[Q4h0SR4m0VR(x#xQ!fQT-]']-^]!qQ!r']-^1b5iQ#p]R'f;kR)c$dY!uQ']-^1b5iQ'h!rS'r!v!yS't!z5kS-m'i'jQ-o'kR2v-nT#kZ%cS#jZ%cS%im,hU(d#h#i#lS.R(e(fQ.V(gQ0j+XQ2{.SU2|.T.U.WS6p2}3OR8y6qd#^W#W#Z%f(Q(Z*V+U-|/fr#gZm#h#i#l%c(e(f(g+X.S.T.U.W2}3O6qS*Y$x*^Q/m*ZQ1w,hQ2_-OQ4R/iQ6_2VQ7a4SQ8q6`T=R'U+VV#aW%f*VU#`W%f*VS(R#W(ZU(W#Z+U/fS-T'U+VT-w(Q-|V'Z!e%g*WQ$lfR)u$qT)j$l)kR3x.}T*[$x*^T*d${*VQ0m+aQ1Y,OQ3Q._Q5b1[Q5m1dQ6u3UQ8]5pQ8|6tQ9t8[Q:W8{Q:p9vQ:x:YQ;S:qR;V:ynqOXst!Z#d%k&o&q&r&t,l,q1}2QQ&i!VR,a&ftmOXst!U!V!Z#d%k&f&o&q&r&t,l,q1}2QR,h&lT%jm,hR1^,QR,`&dQ&S|R+x&TR+n%}T&m!W&pT&n!W&pT2P,q2Q",
        nodeNames: "âš  ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
        maxTerm: 377,
        context: Ds,
        nodeProps: [
            ["isolate", -8, 5, 6, 14, 34, 36, 48, 50, 52, ""],
            ["group", -26, 9, 17, 19, 65, 204, 208, 212, 213, 215, 218, 221, 231, 233, 239, 241, 243, 245, 248, 254, 260, 262, 264, 266, 268, 270, 271, "Statement", -34, 13, 14, 29, 32, 33, 39, 48, 51, 52, 54, 59, 67, 69, 73, 77, 79, 81, 82, 107, 108, 117, 118, 135, 138, 140, 141, 142, 143, 144, 146, 147, 166, 167, 169, "Expression", -23, 28, 30, 34, 38, 40, 42, 171, 173, 175, 176, 178, 179, 180, 182, 183, 184, 186, 187, 188, 198, 200, 202, 203, "Type", -3, 85, 100, 106, "ClassItem"],
            ["openedBy", 23, "<", 35, "InterpolationStart", 53, "[", 57, "{", 70, "(", 159, "JSXStartCloseTag"],
            ["closedBy", 24, ">", 37, "InterpolationEnd", 47, "]", 58, "}", 71, ")", 164, "JSXEndTag"]
        ],
        propSources: [Is],
        skippedNodes: [0, 5, 6, 274],
        repeatNodeCount: 37,
        tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(V!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(V!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(SpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(SpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Sp(V!b'x0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(T#S$h&j'y0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Sp(V!b'y0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!m),Q(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(R':f$h&j(V!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(V!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(V!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(V!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(V!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Sp(V!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Sp(V!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(V!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(V!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(SpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(SpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Sp(V!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(k%1l(Sp(V!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Sp(V!b$[#t(P,2j(a$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Sp(V!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Sp(V!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(v+JY$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(U';W$h&j(SpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(SpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(SpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(SpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(SpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!i/.^$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!h!Lf$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Sp(V!b(Q%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Sp(V!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Sp(V!bo+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Sp(V!b}.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Sp(V!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(V!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(V!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(V!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(V!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(V!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(V!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Sp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Sp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Sp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Sp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(SpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(SpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Sp(V!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Sp(V!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Sp(V!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Sp(V!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Sp(V!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Sp(V!b'z0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Sp(V!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(V!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(V!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(SpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(SpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Sp(V!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$h&j#})Lv(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#O-<U(Sp(V!b(z7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#p(Ch$e#|$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(n(Ct$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!y$Ip$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!P0,v$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!V#)l$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Sp(V!b(]+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Sp(V!b(P,2j$^#t(a$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Sp(V!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X![#Hb(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(u+JY$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!Z(CdsBr$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!n7`$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Sp(V!b'x0/l$[#t(P,2j(a$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Sp(V!b'y0/l$[#t(P,2j(a$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
        tokenizers: [Vs, Zs, _s, Bs, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, Ls, new LocalTokenGroup("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOu~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(_~~", 141, 336), new LocalTokenGroup("j~RQYZXz{^~^O'|~~aP!P!Qd~iO'}~~", 25, 319)],
        topRules: {
            Script: [0, 7],
            SingleExpression: [1, 272],
            SingleClassItem: [2, 273]
        },
        dialects: {
            jsx: 0,
            ts: 14980
        },
        dynamicPrecedences: {
            77: 1,
            79: 1,
            91: 1,
            167: 1,
            196: 1
        },
        specialized: [{
            term: 323,
            get: e => Xs[e] || -1
        }, {
            term: 339,
            get: e => qs[e] || -1
        }, {
            term: 92,
            get: e => zs[e] || -1
        }],
        tokenPrec: 15004
    }),
    Ys = [snippetCompletion("function ${name}(${params}) {\n\t${}\n}", {
        label: "function",
        detail: "definition",
        type: "keyword"
    }), snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}", {
        label: "for",
        detail: "loop",
        type: "keyword"
    }), snippetCompletion("for (let ${name} of ${collection}) {\n\t${}\n}", {
        label: "for",
        detail: "of loop",
        type: "keyword"
    }), snippetCompletion("do {\n\t${}\n} while (${})", {
        label: "do",
        detail: "loop",
        type: "keyword"
    }), snippetCompletion("while (${}) {\n\t${}\n}", {
        label: "while",
        detail: "loop",
        type: "keyword"
    }), snippetCompletion("try {\n\t${}\n} catch (${error}) {\n\t${}\n}", {
        label: "try",
        detail: "/ catch block",
        type: "keyword"
    }), snippetCompletion("if (${}) {\n\t${}\n}", {
        label: "if",
        detail: "block",
        type: "keyword"
    }), snippetCompletion("if (${}) {\n\t${}\n} else {\n\t${}\n}", {
        label: "if",
        detail: "/ else block",
        type: "keyword"
    }), snippetCompletion("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}", {
        label: "class",
        detail: "definition",
        type: "keyword"
    }), snippetCompletion('import {${names}} from "${module}"\n${}', {
        label: "import",
        detail: "named",
        type: "keyword"
    }), snippetCompletion('import ${name} from "${module}"\n${}', {
        label: "import",
        detail: "default",
        type: "keyword"
    })],
    js = Ys.concat([snippetCompletion("interface ${name} {\n\t${}\n}", {
        label: "interface",
        detail: "definition",
        type: "keyword"
    }), snippetCompletion("type ${name} = ${type}", {
        label: "type",
        detail: "definition",
        type: "keyword"
    }), snippetCompletion("enum ${name} {\n\t${}\n}", {
        label: "enum",
        detail: "definition",
        type: "keyword"
    })]),
    Ws = new NodeWeakMap,
    Us = new Set(["Script", "Block", "FunctionExpression", "FunctionDeclaration", "ArrowFunction", "MethodDeclaration", "ForStatement"]);

function defID(e) {
    return (t, n) => {
        let o = t.node.getChild("VariableDefinition");
        return o && n(o, e), !0
    }
}
const Fs = ["FunctionDeclaration"],
    Gs = {
        FunctionDeclaration: defID("function"),
        ClassDeclaration: defID("class"),
        ClassExpression: () => !0,
        EnumDeclaration: defID("constant"),
        TypeAliasDeclaration: defID("type"),
        NamespaceDeclaration: defID("namespace"),
        VariableDefinition(e, t) {
            e.matchContext(Fs) || t(e, "variable")
        },
        TypeDefinition(e, t) {
            t(e, "type")
        },
        __proto__: null
    };

function getScope(e, t) {
    let n = Ws.get(t);
    if (n) return n;
    let o = [],
        h = !0;

    function def(t, n) {
        let h = e.sliceString(t.from, t.to);
        o.push({
            label: h,
            type: n
        })
    }
    return t.cursor(Bn.IncludeAnonymous).iterate((t => {
        if (h) h = !1;
        else if (t.name) {
            let e = Gs[t.name];
            if (e && e(t, def) || Us.has(t.name)) return !1
        } else if (t.to - t.from > 8192) {
            for (let n of getScope(e, t.node)) o.push(n);
            return !1
        }
    })), Ws.set(t, o), o
}
const Hs = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/,
    Ks = ["TemplateString", "String", "RegExp", "LineComment", "BlockComment", "VariableDefinition", "TypeDefinition", "Label", "PropertyDefinition", "PropertyName", "PrivatePropertyDefinition", "PrivatePropertyName", ".", "?."];

function localCompletionSource(e) {
    let t = syntaxTree(e.state).resolveInner(e.pos, -1);
    if (Ks.indexOf(t.name) > -1) return null;
    let n = "VariableName" == t.name || t.to - t.from < 20 && Hs.test(e.state.sliceDoc(t.from, t.to));
    if (!n && !e.explicit) return null;
    let o = [];
    for (let n = t; n; n = n.parent) Us.has(n.name) && (o = o.concat(getScope(e.state.doc, n)));
    return {
        options: o,
        from: n ? t.from : e.pos,
        validFor: Hs
    }
}
const Js = LRLanguage.define({
        name: "javascript",
        parser: Ns.configure({
            props: [Oi.add({
                IfStatement: continuedIndent({
                    except: /^\s*({|else\b)/
                }),
                TryStatement: continuedIndent({
                    except: /^\s*({|catch\b|finally\b)/
                }),
                LabeledStatement: e => e.baseIndent,
                SwitchBody: e => {
                    let t = e.textAfter,
                        n = /^\s*\}/.test(t),
                        o = /^\s*(case|default)\b/.test(t);
                    return e.baseIndent + (n ? 0 : o ? 1 : 2) * e.unit
                },
                Block: delimitedIndent({
                    closing: "}"
                }),
                ArrowFunction: e => e.baseIndent + e.unit,
                "TemplateString BlockComment": () => null,
                "Statement Property": continuedIndent({
                    except: /^{/
                }),
                JSXElement(e) {
                    let t = /^\s*<\//.test(e.textAfter);
                    return e.lineIndent(e.node.from) + (t ? 0 : e.unit)
                },
                JSXEscape(e) {
                    let t = /\s*\}/.test(e.textAfter);
                    return e.lineIndent(e.node.from) + (t ? 0 : e.unit)
                },
                "JSXOpenTag JSXSelfClosingTag": e => e.column(e.node.from) + e.unit
            }), wi.add({
                "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": foldInside,
                BlockComment: e => ({
                    from: e.from + 2,
                    to: e.to - 2
                })
            })]
        }),
        languageData: {
            closeBrackets: {
                brackets: ["(", "[", "{", "'", '"', "`"]
            },
            commentTokens: {
                line: "//",
                block: {
                    open: "/*",
                    close: "*/"
                }
            },
            indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
            wordChars: "$"
        }
    }),
    ea = {
        test: e => /^JSX/.test(e.name),
        facet: defineLanguageFacet({
            commentTokens: {
                block: {
                    open: "{/*",
                    close: "*/}"
                }
            }
        })
    },
    ta = Js.configure({
        dialect: "ts"
    }, "typescript"),
    na = Js.configure({
        dialect: "jsx",
        props: [hi.add((e => e.isTop ? [ea] : void 0))]
    }),
    ia = Js.configure({
        dialect: "jsx ts",
        props: [hi.add((e => e.isTop ? [ea] : void 0))]
    }, "typescript");
let kwCompletion = e => ({
    label: e,
    type: "keyword"
});
const ra = "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(kwCompletion),
    oa = ra.concat(["declare", "implements", "private", "protected", "public"].map(kwCompletion));

function javascript(e = {}) {
    let t = e.jsx ? e.typescript ? ia : na : e.typescript ? ta : Js,
        n = e.typescript ? js.concat(oa) : Ys.concat(ra);
    return new LanguageSupport(t, [Js.data.of({
        autocomplete: (o = Ks, h = completeFromList(n), e => {
            for (let t = syntaxTree(e.state).resolveInner(e.pos, -1); t; t = t.parent) {
                if (o.indexOf(t.name) > -1) return null;
                if (t.type.isTop) break
            }
            return h(e)
        })
    }), Js.data.of({
        autocomplete: localCompletionSource
    }), e.jsx ? aa : []]);
    var o, h
}

function elementName$1(e, t, n = e.length) {
    for (let o = null == t ? void 0 : t.firstChild; o; o = o.nextSibling)
        if ("JSXIdentifier" == o.name || "JSXBuiltin" == o.name || "JSXNamespacedName" == o.name || "JSXMemberExpression" == o.name) return e.sliceString(o.from, Math.min(o.to, n));
    return ""
}
const sa = "object" == typeof navigator && /Android\b/.test(navigator.userAgent),
    aa = EditorView.inputHandler.of(((e, t, n, o, h) => {
        if ((sa ? e.composing : e.compositionStarted) || e.state.readOnly || t != n || ">" != o && "/" != o || !Js.isActiveAt(e.state, t, -1)) return !1;
        let p = h(),
            {
                state: f
            } = p,
            g = f.changeByRange((e => {
                var t;
                let n, {
                        head: h
                    } = e,
                    p = syntaxTree(f).resolveInner(h - 1, -1);
                if ("JSXStartTag" == p.name && (p = p.parent), f.doc.sliceString(h - 1, h) != o || "JSXAttributeValue" == p.name && p.to > h);
                else {
                    if (">" == o && "JSXFragmentTag" == p.name) return {
                        range: e,
                        changes: {
                            from: h,
                            insert: "</>"
                        }
                    };
                    if ("/" == o && "JSXStartCloseTag" == p.name) {
                        let e = p.parent,
                            o = e.parent;
                        if (o && e.from == h - 2 && ((n = elementName$1(f.doc, o.firstChild, h)) || "JSXFragmentTag" == (null === (t = o.firstChild) || void 0 === t ? void 0 : t.name))) {
                            let e = `${n}>`;
                            return {
                                range: EditorSelection.cursor(h + e.length, -1),
                                changes: {
                                    from: h,
                                    insert: e
                                }
                            }
                        }
                    } else if (">" == o) {
                        let t = function(e) {
                            for (;;) {
                                if ("JSXOpenTag" == e.name || "JSXSelfClosingTag" == e.name || "JSXFragmentTag" == e.name) return e;
                                if ("JSXEscape" == e.name || !e.parent) return null;
                                e = e.parent
                            }
                        }(p);
                        if (t && "JSXOpenTag" == t.name && !/^\/?>|^<\//.test(f.doc.sliceString(h, h + 2)) && (n = elementName$1(f.doc, t, h))) return {
                            range: e,
                            changes: {
                                from: h,
                                insert: `</${n}>`
                            }
                        }
                    }
                }
                return {
                    range: e
                }
            }));
        return !g.changes.empty && (e.dispatch([p, f.update(g, {
            userEvent: "input.complete",
            scrollIntoView: !0
        })]), !0)
    })),
    la = ["_blank", "_self", "_top", "_parent"],
    ca = ["ascii", "utf-8", "utf-16", "latin1", "latin1"],
    ha = ["get", "post", "put", "delete"],
    da = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"],
    ua = ["true", "false"],
    pa = {},
    fa = {
        a: {
            attrs: {
                href: null,
                ping: null,
                type: null,
                media: null,
                target: la,
                hreflang: null
            }
        },
        abbr: pa,
        address: pa,
        area: {
            attrs: {
                alt: null,
                coords: null,
                href: null,
                target: null,
                ping: null,
                media: null,
                hreflang: null,
                type: null,
                shape: ["default", "rect", "circle", "poly"]
            }
        },
        article: pa,
        aside: pa,
        audio: {
            attrs: {
                src: null,
                mediagroup: null,
                crossorigin: ["anonymous", "use-credentials"],
                preload: ["none", "metadata", "auto"],
                autoplay: ["autoplay"],
                loop: ["loop"],
                controls: ["controls"]
            }
        },
        b: pa,
        base: {
            attrs: {
                href: null,
                target: la
            }
        },
        bdi: pa,
        bdo: pa,
        blockquote: {
            attrs: {
                cite: null
            }
        },
        body: pa,
        br: pa,
        button: {
            attrs: {
                form: null,
                formaction: null,
                name: null,
                value: null,
                autofocus: ["autofocus"],
                disabled: ["autofocus"],
                formenctype: da,
                formmethod: ha,
                formnovalidate: ["novalidate"],
                formtarget: la,
                type: ["submit", "reset", "button"]
            }
        },
        canvas: {
            attrs: {
                width: null,
                height: null
            }
        },
        caption: pa,
        center: pa,
        cite: pa,
        code: pa,
        col: {
            attrs: {
                span: null
            }
        },
        colgroup: {
            attrs: {
                span: null
            }
        },
        command: {
            attrs: {
                type: ["command", "checkbox", "radio"],
                label: null,
                icon: null,
                radiogroup: null,
                command: null,
                title: null,
                disabled: ["disabled"],
                checked: ["checked"]
            }
        },
        data: {
            attrs: {
                value: null
            }
        },
        datagrid: {
            attrs: {
                disabled: ["disabled"],
                multiple: ["multiple"]
            }
        },
        datalist: {
            attrs: {
                data: null
            }
        },
        dd: pa,
        del: {
            attrs: {
                cite: null,
                datetime: null
            }
        },
        details: {
            attrs: {
                open: ["open"]
            }
        },
        dfn: pa,
        div: pa,
        dl: pa,
        dt: pa,
        em: pa,
        embed: {
            attrs: {
                src: null,
                type: null,
                width: null,
                height: null
            }
        },
        eventsource: {
            attrs: {
                src: null
            }
        },
        fieldset: {
            attrs: {
                disabled: ["disabled"],
                form: null,
                name: null
            }
        },
        figcaption: pa,
        figure: pa,
        footer: pa,
        form: {
            attrs: {
                action: null,
                name: null,
                "accept-charset": ca,
                autocomplete: ["on", "off"],
                enctype: da,
                method: ha,
                novalidate: ["novalidate"],
                target: la
            }
        },
        h1: pa,
        h2: pa,
        h3: pa,
        h4: pa,
        h5: pa,
        h6: pa,
        head: {
            children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
        },
        header: pa,
        hgroup: pa,
        hr: pa,
        html: {
            attrs: {
                manifest: null
            }
        },
        i: pa,
        iframe: {
            attrs: {
                src: null,
                srcdoc: null,
                name: null,
                width: null,
                height: null,
                sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
                seamless: ["seamless"]
            }
        },
        img: {
            attrs: {
                alt: null,
                src: null,
                ismap: null,
                usemap: null,
                width: null,
                height: null,
                crossorigin: ["anonymous", "use-credentials"]
            }
        },
        input: {
            attrs: {
                alt: null,
                dirname: null,
                form: null,
                formaction: null,
                height: null,
                list: null,
                max: null,
                maxlength: null,
                min: null,
                name: null,
                pattern: null,
                placeholder: null,
                size: null,
                src: null,
                step: null,
                value: null,
                width: null,
                accept: ["audio/*", "video/*", "image/*"],
                autocomplete: ["on", "off"],
                autofocus: ["autofocus"],
                checked: ["checked"],
                disabled: ["disabled"],
                formenctype: da,
                formmethod: ha,
                formnovalidate: ["novalidate"],
                formtarget: la,
                multiple: ["multiple"],
                readonly: ["readonly"],
                required: ["required"],
                type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month", "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio", "file", "submit", "image", "reset", "button"]
            }
        },
        ins: {
            attrs: {
                cite: null,
                datetime: null
            }
        },
        kbd: pa,
        keygen: {
            attrs: {
                challenge: null,
                form: null,
                name: null,
                autofocus: ["autofocus"],
                disabled: ["disabled"],
                keytype: ["RSA"]
            }
        },
        label: {
            attrs: {
                for: null,
                form: null
            }
        },
        legend: pa,
        li: {
            attrs: {
                value: null
            }
        },
        link: {
            attrs: {
                href: null,
                type: null,
                hreflang: null,
                media: null,
                sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
            }
        },
        map: {
            attrs: {
                name: null
            }
        },
        mark: pa,
        menu: {
            attrs: {
                label: null,
                type: ["list", "context", "toolbar"]
            }
        },
        meta: {
            attrs: {
                content: null,
                charset: ca,
                name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
                "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
            }
        },
        meter: {
            attrs: {
                value: null,
                min: null,
                low: null,
                high: null,
                max: null,
                optimum: null
            }
        },
        nav: pa,
        noscript: pa,
        object: {
            attrs: {
                data: null,
                type: null,
                name: null,
                usemap: null,
                form: null,
                width: null,
                height: null,
                typemustmatch: ["typemustmatch"]
            }
        },
        ol: {
            attrs: {
                reversed: ["reversed"],
                start: null,
                type: ["1", "a", "A", "i", "I"]
            },
            children: ["li", "script", "template", "ul", "ol"]
        },
        optgroup: {
            attrs: {
                disabled: ["disabled"],
                label: null
            }
        },
        option: {
            attrs: {
                disabled: ["disabled"],
                label: null,
                selected: ["selected"],
                value: null
            }
        },
        output: {
            attrs: {
                for: null,
                form: null,
                name: null
            }
        },
        p: pa,
        param: {
            attrs: {
                name: null,
                value: null
            }
        },
        pre: pa,
        progress: {
            attrs: {
                value: null,
                max: null
            }
        },
        q: {
            attrs: {
                cite: null
            }
        },
        rp: pa,
        rt: pa,
        ruby: pa,
        samp: pa,
        script: {
            attrs: {
                type: ["text/javascript"],
                src: null,
                async: ["async"],
                defer: ["defer"],
                charset: ca
            }
        },
        section: pa,
        select: {
            attrs: {
                form: null,
                name: null,
                size: null,
                autofocus: ["autofocus"],
                disabled: ["disabled"],
                multiple: ["multiple"]
            }
        },
        slot: {
            attrs: {
                name: null
            }
        },
        small: pa,
        source: {
            attrs: {
                src: null,
                type: null,
                media: null
            }
        },
        span: pa,
        strong: pa,
        style: {
            attrs: {
                type: ["text/css"],
                media: null,
                scoped: null
            }
        },
        sub: pa,
        summary: pa,
        sup: pa,
        table: pa,
        tbody: pa,
        td: {
            attrs: {
                colspan: null,
                rowspan: null,
                headers: null
            }
        },
        template: pa,
        textarea: {
            attrs: {
                dirname: null,
                form: null,
                maxlength: null,
                name: null,
                placeholder: null,
                rows: null,
                cols: null,
                autofocus: ["autofocus"],
                disabled: ["disabled"],
                readonly: ["readonly"],
                required: ["required"],
                wrap: ["soft", "hard"]
            }
        },
        tfoot: pa,
        th: {
            attrs: {
                colspan: null,
                rowspan: null,
                headers: null,
                scope: ["row", "col", "rowgroup", "colgroup"]
            }
        },
        thead: pa,
        time: {
            attrs: {
                datetime: null
            }
        },
        title: pa,
        tr: pa,
        track: {
            attrs: {
                src: null,
                label: null,
                default: null,
                kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
                srclang: null
            }
        },
        ul: {
            children: ["li", "script", "template", "ul", "ol"]
        },
        var: pa,
        video: {
            attrs: {
                src: null,
                poster: null,
                width: null,
                height: null,
                crossorigin: ["anonymous", "use-credentials"],
                preload: ["auto", "metadata", "none"],
                autoplay: ["autoplay"],
                mediagroup: ["movie"],
                muted: ["muted"],
                controls: ["controls"]
            }
        },
        wbr: pa
    },
    ga = {
        accesskey: null,
        class: null,
        contenteditable: ua,
        contextmenu: null,
        dir: ["ltr", "rtl", "auto"],
        draggable: ["true", "false", "auto"],
        dropzone: ["copy", "move", "link", "string:", "file:"],
        hidden: ["hidden"],
        id: null,
        inert: ["inert"],
        itemid: null,
        itemprop: null,
        itemref: null,
        itemscope: ["itemscope"],
        itemtype: null,
        lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
        spellcheck: ua,
        autocorrect: ua,
        autocapitalize: ua,
        style: null,
        tabindex: null,
        title: null,
        translate: ["yes", "no"],
        rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
        role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
        "aria-activedescendant": null,
        "aria-atomic": ua,
        "aria-autocomplete": ["inline", "list", "both", "none"],
        "aria-busy": ua,
        "aria-checked": ["true", "false", "mixed", "undefined"],
        "aria-controls": null,
        "aria-describedby": null,
        "aria-disabled": ua,
        "aria-dropeffect": null,
        "aria-expanded": ["true", "false", "undefined"],
        "aria-flowto": null,
        "aria-grabbed": ["true", "false", "undefined"],
        "aria-haspopup": ua,
        "aria-hidden": ua,
        "aria-invalid": ["true", "false", "grammar", "spelling"],
        "aria-label": null,
        "aria-labelledby": null,
        "aria-level": null,
        "aria-live": ["off", "polite", "assertive"],
        "aria-multiline": ua,
        "aria-multiselectable": ua,
        "aria-owns": null,
        "aria-posinset": null,
        "aria-pressed": ["true", "false", "mixed", "undefined"],
        "aria-readonly": ua,
        "aria-relevant": null,
        "aria-required": ua,
        "aria-selected": ["true", "false", "undefined"],
        "aria-setsize": null,
        "aria-sort": ["ascending", "descending", "none", "other"],
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null,
        "aria-valuetext": null
    },
    ma = "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((e => "on" + e));
for (let ch of ma) ga[ch] = null;
class Schema {
    constructor(e, t) {
        this.tags = Object.assign(Object.assign({}, fa), e), this.globalAttrs = Object.assign(Object.assign({}, ga), t), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs)
    }
}

function elementName(e, t, n = e.length) {
    if (!t) return "";
    let o = t.firstChild,
        h = o && o.getChild("TagName");
    return h ? e.sliceString(h.from, Math.min(h.to, n)) : ""
}

function findParentElement(e, t = !1) {
    for (; e; e = e.parent)
        if ("Element" == e.name) {
            if (!t) return e;
            t = !1
        }
    return null
}

function allowedChildren(e, t, n) {
    let o = n.tags[elementName(e, findParentElement(t))];
    return (null == o ? void 0 : o.children) || n.allTags
}

function openTags(e, t) {
    let n = [];
    for (let o = findParentElement(t); o && !o.type.isTop; o = findParentElement(o.parent)) {
        let h = elementName(e, o);
        if (h && "CloseTag" == o.lastChild.name) break;
        h && n.indexOf(h) < 0 && ("EndTag" == t.name || t.from >= o.firstChild.to) && n.push(h)
    }
    return n
}
Schema.default = new Schema;
const Oa = /^[:\-\.\w\u00b7-\uffff]*$/;

function completeTag(e, t, n, o, h) {
    let p = /\s*>/.test(e.sliceDoc(h, h + 5)) ? "" : ">",
        f = findParentElement(n, !0);
    return {
        from: o,
        to: h,
        options: allowedChildren(e.doc, f, t).map((e => ({
            label: e,
            type: "type"
        }))).concat(openTags(e.doc, n).map(((e, t) => ({
            label: "/" + e,
            apply: "/" + e + p,
            type: "type",
            boost: 99 - t
        })))),
        validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
    }
}

function completeCloseTag(e, t, n, o) {
    let h = /\s*>/.test(e.sliceDoc(o, o + 5)) ? "" : ">";
    return {
        from: n,
        to: o,
        options: openTags(e.doc, t).map(((e, t) => ({
            label: e,
            apply: e + h,
            type: "type",
            boost: 99 - t
        }))),
        validFor: Oa
    }
}

function htmlCompletionFor(e, t) {
    let {
        state: n,
        pos: o
    } = t, h = syntaxTree(n).resolveInner(o, -1), p = h.resolve(o);
    for (let e, t = o; p == h && (e = h.childBefore(t));) {
        let n = e.lastChild;
        if (!n || !n.type.isError || n.from < n.to) break;
        p = h = e, t = n.from
    }
    return "TagName" == h.name ? h.parent && /CloseTag$/.test(h.parent.name) ? completeCloseTag(n, h, h.from, o) : completeTag(n, e, h, h.from, o) : "StartTag" == h.name ? completeTag(n, e, h, o, o) : "StartCloseTag" == h.name || "IncompleteCloseTag" == h.name ? completeCloseTag(n, h, o, o) : "OpenTag" == h.name || "SelfClosingTag" == h.name || "AttributeName" == h.name ? function(e, t, n, o, h) {
        let p = findParentElement(n),
            f = p ? t.tags[elementName(e.doc, p)] : null,
            g = f && f.attrs ? Object.keys(f.attrs) : [];
        return {
            from: o,
            to: h,
            options: (f && !1 === f.globalAttrs ? g : g.length ? g.concat(t.globalAttrNames) : t.globalAttrNames).map((e => ({
                label: e,
                type: "property"
            }))),
            validFor: Oa
        }
    }(n, e, h, "AttributeName" == h.name ? h.from : o, o) : "Is" == h.name || "AttributeValue" == h.name || "UnquotedAttributeValue" == h.name ? function(e, t, n, o, h) {
        var p;
        let f, g = null === (p = n.parent) || void 0 === p ? void 0 : p.getChild("AttributeName"),
            y = [];
        if (g) {
            let p = e.sliceDoc(g.from, g.to),
                w = t.globalAttrs[p];
            if (!w) {
                let o = findParentElement(n),
                    h = o ? t.tags[elementName(e.doc, o)] : null;
                w = (null == h ? void 0 : h.attrs) && h.attrs[p]
            }
            if (w) {
                let t = e.sliceDoc(o, h).toLowerCase(),
                    n = '"',
                    p = '"';
                /^['"]/.test(t) ? (f = '"' == t[0] ? /^[^"]*$/ : /^[^']*$/, n = "", p = e.sliceDoc(h, h + 1) == t[0] ? "" : t[0], t = t.slice(1), o++) : f = /^[^\s<>='"]*$/;
                for (let e of w) y.push({
                    label: e,
                    apply: n + e + p,
                    type: "constant"
                })
            }
        }
        return {
            from: o,
            to: h,
            options: y,
            validFor: f
        }
    }(n, e, h, "Is" == h.name ? o : h.from, o) : !t.explicit || "Element" != p.name && "Text" != p.name && "Document" != p.name ? null : function(e, t, n, o) {
        let h = [],
            p = 0;
        for (let o of allowedChildren(e.doc, n, t)) h.push({
            label: "<" + o,
            type: "type"
        });
        for (let t of openTags(e.doc, n)) h.push({
            label: "</" + t + ">",
            type: "type",
            boost: 99 - p++
        });
        return {
            from: o,
            to: o,
            options: h,
            validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
        }
    }(n, e, h, o)
}

function htmlCompletionSourceWith(e) {
    let {
        extraTags: t,
        extraGlobalAttributes: n
    } = e, o = n || t ? new Schema(t, n) : Schema.default;
    return e => htmlCompletionFor(o, e)
}
const ya = Js.parser.configure({
        top: "SingleExpression"
    }),
    wa = [{
        tag: "script",
        attrs: e => "text/typescript" == e.type || "ts" == e.lang,
        parser: ta.parser
    }, {
        tag: "script",
        attrs: e => "text/babel" == e.type || "text/jsx" == e.type,
        parser: na.parser
    }, {
        tag: "script",
        attrs: e => "text/typescript-jsx" == e.type,
        parser: ia.parser
    }, {
        tag: "script",
        attrs: e => /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(e.type),
        parser: ya
    }, {
        tag: "script",
        attrs: e => !e.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(e.type),
        parser: Js.parser
    }, {
        tag: "style",
        attrs: e => (!e.lang || "css" == e.lang) && (!e.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(e.type)),
        parser: Ms.parser
    }],
    ba = [{
        name: "style",
        parser: Ms.parser.configure({
            top: "Styles"
        })
    }].concat(ma.map((e => ({
        name: e,
        parser: Js.parser
    })))),
    Sa = LRLanguage.define({
        name: "html",
        parser: us.configure({
            props: [Oi.add({
                Element(e) {
                    let t = /^(\s*)(<\/)?/.exec(e.textAfter);
                    return e.node.to <= e.pos + t[0].length ? e.continue() : e.lineIndent(e.node.from) + (t[2] ? 0 : e.unit)
                },
                "OpenTag CloseTag SelfClosingTag": e => e.column(e.node.from) + e.unit,
                Document(e) {
                    if (e.pos + /\s*/.exec(e.textAfter)[0].length < e.node.to) return e.continue();
                    let t, n = null;
                    for (let t = e.node;;) {
                        let e = t.lastChild;
                        if (!e || "Element" != e.name || e.to != t.to) break;
                        n = t = e
                    }
                    return n && (!(t = n.lastChild) || "CloseTag" != t.name && "SelfClosingTag" != t.name) ? e.lineIndent(n.from) + e.unit : null
                }
            }), wi.add({
                Element(e) {
                    let t = e.firstChild,
                        n = e.lastChild;
                    return t && "OpenTag" == t.name ? {
                        from: t.to,
                        to: "CloseTag" == n.name ? n.from : e.to
                    } : null
                }
            }), Bi.add({
                "OpenTag CloseTag": e => e.getChild("TagName")
            })]
        }),
        languageData: {
            commentTokens: {
                block: {
                    open: "\x3c!--",
                    close: "--\x3e"
                }
            },
            indentOnInput: /^\s*<\/\w+\W$/,
            wordChars: "-._"
        }
    }),
    xa = Sa.configure({
        wrap: configureNesting(wa, ba)
    });

function html(e = {}) {
    let t, n = "";
    !1 === e.matchClosingTags && (n = "noMatch"), !0 === e.selfClosingTags && (n = (n ? n + " " : "") + "selfClosing"), (e.nestedLanguages && e.nestedLanguages.length || e.nestedAttributes && e.nestedAttributes.length) && (t = configureNesting((e.nestedLanguages || []).concat(wa), (e.nestedAttributes || []).concat(ba)));
    let o = t ? Sa.configure({
        wrap: t,
        dialect: n
    }) : n ? xa.configure({
        dialect: n
    }) : xa;
    return new LanguageSupport(o, [xa.data.of({
        autocomplete: htmlCompletionSourceWith(e)
    }), !1 !== e.autoCloseTags ? va : [], javascript().support, new LanguageSupport(Ms, Ms.data.of({
        autocomplete: As
    })).support])
}
const ka = new Set("area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")),
    va = EditorView.inputHandler.of(((e, t, n, o, h) => {
        if (e.composing || e.state.readOnly || t != n || ">" != o && "/" != o || !xa.isActiveAt(e.state, t, -1)) return !1;
        let p = h(),
            {
                state: f
            } = p,
            g = f.changeByRange((e => {
                var t, n, h;
                let p, g = f.doc.sliceString(e.from - 1, e.to) == o,
                    {
                        head: y
                    } = e,
                    w = syntaxTree(f).resolveInner(y, -1);
                if (g && ">" == o && "EndTag" == w.name) {
                    let o = w.parent;
                    if ("CloseTag" != (null === (n = null === (t = o.parent) || void 0 === t ? void 0 : t.lastChild) || void 0 === n ? void 0 : n.name) && (p = elementName(f.doc, o.parent, y)) && !ka.has(p)) {
                        return {
                            range: e,
                            changes: {
                                from: y,
                                to: y + (">" === f.doc.sliceString(y, y + 1) ? 1 : 0),
                                insert: `</${p}>`
                            }
                        }
                    }
                } else if (g && "/" == o && "IncompleteCloseTag" == w.name) {
                    let e = w.parent;
                    if (w.from == y - 2 && "CloseTag" != (null === (h = e.lastChild) || void 0 === h ? void 0 : h.name) && (p = elementName(f.doc, e, y)) && !ka.has(p)) {
                        let e = y + (">" === f.doc.sliceString(y, y + 1) ? 1 : 0),
                            t = `${p}>`;
                        return {
                            range: EditorSelection.cursor(y + t.length, -1),
                            changes: {
                                from: y,
                                to: e,
                                insert: t
                            }
                        }
                    }
                }
                return {
                    range: e
                }
            }));
        return !g.changes.empty && (e.dispatch([p, f.update(g, {
            userEvent: "input.complete",
            scrollIntoView: !0
        })]), !0)
    }));
class CompositeBlock {
    static create(e, t, n, o, h) {
        return new CompositeBlock(e, t, n, o + (o << 8) + e + (t << 4) | 0, h, [], [])
    }
    constructor(e, t, n, o, h, p, f) {
        this.type = e, this.value = t, this.from = n, this.hash = o, this.end = h, this.children = p, this.positions = f, this.hashProp = [
            [NodeProp.contextHash, o]
        ]
    }
    addChild(e, t) {
        e.prop(NodeProp.contextHash) != this.hash && (e = new Tree(e.type, e.children, e.positions, e.length, this.hashProp)), this.children.push(e), this.positions.push(t)
    }
    toTree(e, t = this.end) {
        let n = this.children.length - 1;
        return n >= 0 && (t = Math.max(t, this.positions[n] + this.children[n].length + this.from)), new Tree(e.types[this.type], this.children, this.positions, t - this.from).balance({
            makeTree: (e, t, n) => new Tree(NodeType.none, e, t, n, this.hashProp)
        })
    }
}
var Pa;
! function(e) {
    e[e.Document = 1] = "Document", e[e.CodeBlock = 2] = "CodeBlock", e[e.FencedCode = 3] = "FencedCode", e[e.Blockquote = 4] = "Blockquote", e[e.HorizontalRule = 5] = "HorizontalRule", e[e.BulletList = 6] = "BulletList", e[e.OrderedList = 7] = "OrderedList", e[e.ListItem = 8] = "ListItem", e[e.ATXHeading1 = 9] = "ATXHeading1", e[e.ATXHeading2 = 10] = "ATXHeading2", e[e.ATXHeading3 = 11] = "ATXHeading3", e[e.ATXHeading4 = 12] = "ATXHeading4", e[e.ATXHeading5 = 13] = "ATXHeading5", e[e.ATXHeading6 = 14] = "ATXHeading6", e[e.SetextHeading1 = 15] = "SetextHeading1", e[e.SetextHeading2 = 16] = "SetextHeading2", e[e.HTMLBlock = 17] = "HTMLBlock", e[e.LinkReference = 18] = "LinkReference", e[e.Paragraph = 19] = "Paragraph", e[e.CommentBlock = 20] = "CommentBlock", e[e.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", e[e.Escape = 22] = "Escape", e[e.Entity = 23] = "Entity", e[e.HardBreak = 24] = "HardBreak", e[e.Emphasis = 25] = "Emphasis", e[e.StrongEmphasis = 26] = "StrongEmphasis", e[e.Link = 27] = "Link", e[e.Image = 28] = "Image", e[e.InlineCode = 29] = "InlineCode", e[e.HTMLTag = 30] = "HTMLTag", e[e.Comment = 31] = "Comment", e[e.ProcessingInstruction = 32] = "ProcessingInstruction", e[e.Autolink = 33] = "Autolink", e[e.HeaderMark = 34] = "HeaderMark", e[e.QuoteMark = 35] = "QuoteMark", e[e.ListMark = 36] = "ListMark", e[e.LinkMark = 37] = "LinkMark", e[e.EmphasisMark = 38] = "EmphasisMark", e[e.CodeMark = 39] = "CodeMark", e[e.CodeText = 40] = "CodeText", e[e.CodeInfo = 41] = "CodeInfo", e[e.LinkTitle = 42] = "LinkTitle", e[e.LinkLabel = 43] = "LinkLabel", e[e.URL = 44] = "URL"
}(Pa || (Pa = {}));
class LeafBlock {
    constructor(e, t) {
        this.start = e, this.content = t, this.marks = [], this.parsers = []
    }
}
class Line {
    constructor() {
        this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1
    }
    forward() {
        this.basePos > this.pos && this.forwardInner()
    }
    forwardInner() {
        let e = this.skipSpace(this.basePos);
        this.indent = this.countIndent(e, this.pos, this.indent), this.pos = e, this.next = e == this.text.length ? -1 : this.text.charCodeAt(e)
    }
    skipSpace(e) {
        return skipSpace(this.text, e)
    }
    reset(e) {
        for (this.text = e, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length;) this.markers.pop()
    }
    moveBase(e) {
        this.basePos = e, this.baseIndent = this.countIndent(e, this.pos, this.indent)
    }
    moveBaseColumn(e) {
        this.baseIndent = e, this.basePos = this.findColumn(e)
    }
    addMarker(e) {
        this.markers.push(e)
    }
    countIndent(e, t = 0, n = 0) {
        for (let o = t; o < e; o++) n += 9 == this.text.charCodeAt(o) ? 4 - n % 4 : 1;
        return n
    }
    findColumn(e) {
        let t = 0;
        for (let n = 0; t < this.text.length && n < e; t++) n += 9 == this.text.charCodeAt(t) ? 4 - n % 4 : 1;
        return t
    }
    scrub() {
        if (!this.baseIndent) return this.text;
        let e = "";
        for (let t = 0; t < this.basePos; t++) e += " ";
        return e + this.text.slice(this.basePos)
    }
}

function skipForList(e, t, n) {
    if (n.pos == n.text.length || e != t.block && n.indent >= t.stack[n.depth + 1].value + n.baseIndent) return !0;
    if (n.indent >= n.baseIndent + 4) return !1;
    let o = (e.type == Pa.OrderedList ? isOrderedList : isBulletList)(n, t, !1);
    return o > 0 && (e.type != Pa.BulletList || isHorizontalRule(n, t, !1) < 0) && n.text.charCodeAt(n.pos + o - 1) == e.value
}
const Ca = {
    [Pa.Blockquote]: (e, t, n) => 62 == n.next && (n.markers.push(elt(Pa.QuoteMark, t.lineStart + n.pos, t.lineStart + n.pos + 1)), n.moveBase(n.pos + (space(n.text.charCodeAt(n.pos + 1)) ? 2 : 1)), e.end = t.lineStart + n.text.length, !0),
    [Pa.ListItem]: (e, t, n) => !(n.indent < n.baseIndent + e.value && n.next > -1) && (n.moveBaseColumn(n.baseIndent + e.value), !0),
    [Pa.OrderedList]: skipForList,
    [Pa.BulletList]: skipForList,
    [Pa.Document]: () => !0
};

function space(e) {
    return 32 == e || 9 == e || 10 == e || 13 == e
}

function skipSpace(e, t = 0) {
    for (; t < e.length && space(e.charCodeAt(t));) t++;
    return t
}

function skipSpaceBack(e, t, n) {
    for (; t > n && space(e.charCodeAt(t - 1));) t--;
    return t
}

function isFencedCode(e) {
    if (96 != e.next && 126 != e.next) return -1;
    let t = e.pos + 1;
    for (; t < e.text.length && e.text.charCodeAt(t) == e.next;) t++;
    if (t < e.pos + 3) return -1;
    if (96 == e.next)
        for (let n = t; n < e.text.length; n++)
            if (96 == e.text.charCodeAt(n)) return -1;
    return t
}

function isBlockquote(e) {
    return 62 != e.next ? -1 : 32 == e.text.charCodeAt(e.pos + 1) ? 2 : 1
}

function isHorizontalRule(e, t, n) {
    if (42 != e.next && 45 != e.next && 95 != e.next) return -1;
    let o = 1;
    for (let t = e.pos + 1; t < e.text.length; t++) {
        let n = e.text.charCodeAt(t);
        if (n == e.next) o++;
        else if (!space(n)) return -1
    }
    return n && 45 == e.next && isSetextUnderline(e) > -1 && e.depth == t.stack.length && t.parser.leafBlockParsers.indexOf(Ma.SetextHeading) > -1 || o < 3 ? -1 : 1
}

function inList(e, t) {
    for (let n = e.stack.length - 1; n >= 0; n--)
        if (e.stack[n].type == t) return !0;
    return !1
}

function isBulletList(e, t, n) {
    return 45 != e.next && 43 != e.next && 42 != e.next || e.pos != e.text.length - 1 && !space(e.text.charCodeAt(e.pos + 1)) || !(!n || inList(t, Pa.BulletList) || e.skipSpace(e.pos + 2) < e.text.length) ? -1 : 1
}

function isOrderedList(e, t, n) {
    let o = e.pos,
        h = e.next;
    for (; h >= 48 && h <= 57;) {
        if (o++, o == e.text.length) return -1;
        h = e.text.charCodeAt(o)
    }
    return o == e.pos || o > e.pos + 9 || 46 != h && 41 != h || o < e.text.length - 1 && !space(e.text.charCodeAt(o + 1)) || n && !inList(t, Pa.OrderedList) && (e.skipSpace(o + 1) == e.text.length || o > e.pos + 1 || 49 != e.next) ? -1 : o + 1 - e.pos
}

function isAtxHeading(e) {
    if (35 != e.next) return -1;
    let t = e.pos + 1;
    for (; t < e.text.length && 35 == e.text.charCodeAt(t);) t++;
    if (t < e.text.length && 32 != e.text.charCodeAt(t)) return -1;
    let n = t - e.pos;
    return n > 6 ? -1 : n
}

function isSetextUnderline(e) {
    if (45 != e.next && 61 != e.next || e.indent >= e.baseIndent + 4) return -1;
    let t = e.pos + 1;
    for (; t < e.text.length && e.text.charCodeAt(t) == e.next;) t++;
    let n = t;
    for (; t < e.text.length && space(e.text.charCodeAt(t));) t++;
    return t == e.text.length ? n : -1
}
const Qa = /^[ \t]*$/,
    Ta = /-->/,
    $a = /\?>/,
    Ea = [
        [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
        [/^\s*<!--/, Ta],
        [/^\s*<\?/, $a],
        [/^\s*<![A-Z]/, />/],
        [/^\s*<!\[CDATA\[/, /\]\]>/],
        [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, Qa],
        [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, Qa]
    ];

function isHTMLBlock(e, t, n) {
    if (60 != e.next) return -1;
    let o = e.text.slice(e.pos);
    for (let e = 0, t = Ea.length - (n ? 1 : 0); e < t; e++)
        if (Ea[e][0].test(o)) return e;
    return -1
}

function getListIndent(e, t) {
    let n = e.countIndent(t, e.pos, e.indent),
        o = e.countIndent(e.skipSpace(t), t, n);
    return o >= n + 5 ? n + 1 : o
}

function addCodeText(e, t, n) {
    let o = e.length - 1;
    o >= 0 && e[o].to == t && e[o].type == Pa.CodeText ? e[o].to = n : e.push(elt(Pa.CodeText, t, n))
}
const Aa = {
    LinkReference: void 0,
    IndentedCode(e, t) {
        let n = t.baseIndent + 4;
        if (t.indent < n) return !1;
        let o = t.findColumn(n),
            h = e.lineStart + o,
            p = e.lineStart + t.text.length,
            f = [],
            g = [];
        for (addCodeText(f, h, p); e.nextLine() && t.depth >= e.stack.length;)
            if (t.pos == t.text.length) {
                addCodeText(g, e.lineStart - 1, e.lineStart);
                for (let e of t.markers) g.push(e)
            } else {
                if (t.indent < n) break; {
                    if (g.length) {
                        for (let e of g) e.type == Pa.CodeText ? addCodeText(f, e.from, e.to) : f.push(e);
                        g = []
                    }
                    addCodeText(f, e.lineStart - 1, e.lineStart);
                    for (let e of t.markers) f.push(e);
                    p = e.lineStart + t.text.length;
                    let n = e.lineStart + t.findColumn(t.baseIndent + 4);
                    n < p && addCodeText(f, n, p)
                }
            }
        return g.length && (g = g.filter((e => e.type != Pa.CodeText)), g.length && (t.markers = g.concat(t.markers))), e.addNode(e.buffer.writeElements(f, -h).finish(Pa.CodeBlock, p - h), h), !0
    },
    FencedCode(e, t) {
        let n = isFencedCode(t);
        if (n < 0) return !1;
        let o = e.lineStart + t.pos,
            h = t.next,
            p = n - t.pos,
            f = t.skipSpace(n),
            g = skipSpaceBack(t.text, t.text.length, f),
            y = [elt(Pa.CodeMark, o, o + p)];
        f < g && y.push(elt(Pa.CodeInfo, e.lineStart + f, e.lineStart + g));
        for (let n = !0, o = !0, f = !1; e.nextLine() && t.depth >= e.stack.length; n = !1) {
            let g = t.pos;
            if (t.indent - t.baseIndent < 4)
                for (; g < t.text.length && t.text.charCodeAt(g) == h;) g++;
            if (g - t.pos >= p && t.skipSpace(g) == t.text.length) {
                for (let e of t.markers) y.push(e);
                o && f && addCodeText(y, e.lineStart - 1, e.lineStart), y.push(elt(Pa.CodeMark, e.lineStart + t.pos, e.lineStart + g)), e.nextLine();
                break
            } {
                f = !0, n || (addCodeText(y, e.lineStart - 1, e.lineStart), o = !1);
                for (let e of t.markers) y.push(e);
                let h = e.lineStart + t.basePos,
                    p = e.lineStart + t.text.length;
                h < p && (addCodeText(y, h, p), o = !1)
            }
        }
        return e.addNode(e.buffer.writeElements(y, -o).finish(Pa.FencedCode, e.prevLineEnd() - o), o), !0
    },
    Blockquote(e, t) {
        let n = isBlockquote(t);
        return !(n < 0) && (e.startContext(Pa.Blockquote, t.pos), e.addNode(Pa.QuoteMark, e.lineStart + t.pos, e.lineStart + t.pos + 1), t.moveBase(t.pos + n), null)
    },
    HorizontalRule(e, t) {
        if (isHorizontalRule(t, e, !1) < 0) return !1;
        let n = e.lineStart + t.pos;
        return e.nextLine(), e.addNode(Pa.HorizontalRule, n), !0
    },
    BulletList(e, t) {
        let n = isBulletList(t, e, !1);
        if (n < 0) return !1;
        e.block.type != Pa.BulletList && e.startContext(Pa.BulletList, t.basePos, t.next);
        let o = getListIndent(t, t.pos + 1);
        return e.startContext(Pa.ListItem, t.basePos, o - t.baseIndent), e.addNode(Pa.ListMark, e.lineStart + t.pos, e.lineStart + t.pos + n), t.moveBaseColumn(o), null
    },
    OrderedList(e, t) {
        let n = isOrderedList(t, e, !1);
        if (n < 0) return !1;
        e.block.type != Pa.OrderedList && e.startContext(Pa.OrderedList, t.basePos, t.text.charCodeAt(t.pos + n - 1));
        let o = getListIndent(t, t.pos + n);
        return e.startContext(Pa.ListItem, t.basePos, o - t.baseIndent), e.addNode(Pa.ListMark, e.lineStart + t.pos, e.lineStart + t.pos + n), t.moveBaseColumn(o), null
    },
    ATXHeading(e, t) {
        let n = isAtxHeading(t);
        if (n < 0) return !1;
        let o = t.pos,
            h = e.lineStart + o,
            p = skipSpaceBack(t.text, t.text.length, o),
            f = p;
        for (; f > o && t.text.charCodeAt(f - 1) == t.next;) f--;
        f != p && f != o && space(t.text.charCodeAt(f - 1)) || (f = t.text.length);
        let g = e.buffer.write(Pa.HeaderMark, 0, n).writeElements(e.parser.parseInline(t.text.slice(o + n + 1, f), h + n + 1), -h);
        f < t.text.length && g.write(Pa.HeaderMark, f - o, p - o);
        let y = g.finish(Pa.ATXHeading1 - 1 + n, t.text.length - o);
        return e.nextLine(), e.addNode(y, h), !0
    },
    HTMLBlock(e, t) {
        let n = isHTMLBlock(t, 0, !1);
        if (n < 0) return !1;
        let o = e.lineStart + t.pos,
            h = Ea[n][1],
            p = [],
            f = h != Qa;
        for (; !h.test(t.text) && e.nextLine();) {
            if (t.depth < e.stack.length) {
                f = !1;
                break
            }
            for (let e of t.markers) p.push(e)
        }
        f && e.nextLine();
        let g = h == Ta ? Pa.CommentBlock : h == $a ? Pa.ProcessingInstructionBlock : Pa.HTMLBlock,
            y = e.prevLineEnd();
        return e.addNode(e.buffer.writeElements(p, -o).finish(g, y - o), o), !0
    },
    SetextHeading: void 0
};
class LinkReferenceParser {
    constructor(e) {
        this.stage = 0, this.elts = [], this.pos = 0, this.start = e.start, this.advance(e.content)
    }
    nextLine(e, t, n) {
        if (-1 == this.stage) return !1;
        let o = n.content + "\n" + t.scrub(),
            h = this.advance(o);
        return h > -1 && h < o.length && this.complete(e, n, h)
    }
    finish(e, t) {
        return (2 == this.stage || 3 == this.stage) && skipSpace(t.content, this.pos) == t.content.length && this.complete(e, t, t.content.length)
    }
    complete(e, t, n) {
        return e.addLeafElement(t, elt(Pa.LinkReference, this.start, this.start + n, this.elts)), !0
    }
    nextStage(e) {
        return e ? (this.pos = e.to - this.start, this.elts.push(e), this.stage++, !0) : (!1 === e && (this.stage = -1), !1)
    }
    advance(e) {
        for (;;) {
            if (-1 == this.stage) return -1;
            if (0 == this.stage) {
                if (!this.nextStage(parseLinkLabel(e, this.pos, this.start, !0))) return -1;
                if (58 != e.charCodeAt(this.pos)) return this.stage = -1;
                this.elts.push(elt(Pa.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++
            } else {
                if (1 != this.stage) {
                    if (2 == this.stage) {
                        let t = skipSpace(e, this.pos),
                            n = 0;
                        if (t > this.pos) {
                            let o = parseLinkTitle(e, t, this.start);
                            if (o) {
                                let t = lineEnd(e, o.to - this.start);
                                t > 0 && (this.nextStage(o), n = t)
                            }
                        }
                        return n || (n = lineEnd(e, this.pos)), n > 0 && n < e.length ? n : -1
                    }
                    return lineEnd(e, this.pos)
                }
                if (!this.nextStage(parseURL(e, skipSpace(e, this.pos), this.start))) return -1
            }
        }
    }
}

function lineEnd(e, t) {
    for (; t < e.length; t++) {
        let n = e.charCodeAt(t);
        if (10 == n) break;
        if (!space(n)) return -1
    }
    return t
}
class SetextHeadingParser {
    nextLine(e, t, n) {
        let o = t.depth < e.stack.length ? -1 : isSetextUnderline(t),
            h = t.next;
        if (o < 0) return !1;
        let p = elt(Pa.HeaderMark, e.lineStart + t.pos, e.lineStart + o);
        return e.nextLine(), e.addLeafElement(n, elt(61 == h ? Pa.SetextHeading1 : Pa.SetextHeading2, n.start, e.prevLineEnd(), [...e.parser.parseInline(n.content, n.start), p])), !0
    }
    finish() {
        return !1
    }
}
const Ma = {
        LinkReference: (e, t) => 91 == t.content.charCodeAt(0) ? new LinkReferenceParser(t) : null,
        SetextHeading: () => new SetextHeadingParser
    },
    Ra = [(e, t) => isAtxHeading(t) >= 0, (e, t) => isFencedCode(t) >= 0, (e, t) => isBlockquote(t) >= 0, (e, t) => isBulletList(t, e, !0) >= 0, (e, t) => isOrderedList(t, e, !0) >= 0, (e, t) => isHorizontalRule(t, e, !0) >= 0, (e, t) => isHTMLBlock(t, 0, !0) >= 0],
    Da = {
        text: "",
        end: 0
    };
class BlockContext {
    constructor(e, t, n, o) {
        this.parser = e, this.input = t, this.ranges = o, this.line = new Line, this.atEnd = !1, this.reusePlaceholders = new Map, this.stoppedAt = null, this.rangeI = 0, this.to = o[o.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = o[0].from, this.block = CompositeBlock.create(Pa.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = n.length ? new FragmentCursor(n, t) : null, this.readLine()
    }
    get parsedPos() {
        return this.absoluteLineStart
    }
    advance() {
        if (null != this.stoppedAt && this.absoluteLineStart > this.stoppedAt) return this.finish();
        let {
            line: e
        } = this;
        for (;;) {
            for (let t = 0;;) {
                let n = e.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
                for (; t < e.markers.length && (!n || e.markers[t].from < n.end);) {
                    let n = e.markers[t++];
                    this.addNode(n.type, n.from, n.to)
                }
                if (!n) break;
                this.finishContext()
            }
            if (e.pos < e.text.length) break;
            if (!this.nextLine()) return this.finish()
        }
        if (this.fragments && this.reuseFragment(e.basePos)) return null;
        e: for (;;) {
            for (let t of this.parser.blockParsers)
                if (t) {
                    let n = t(this, e);
                    if (0 != n) {
                        if (1 == n) return null;
                        e.forward();
                        continue e
                    }
                }
            break
        }
        let t = new LeafBlock(this.lineStart + e.pos, e.text.slice(e.pos));
        for (let e of this.parser.leafBlockParsers)
            if (e) {
                let n = e(this, t);
                n && t.parsers.push(n)
            }
        e: for (; this.nextLine() && e.pos != e.text.length;) {
            if (e.indent < e.baseIndent + 4)
                for (let n of this.parser.endLeafBlock)
                    if (n(this, e, t)) break e;
            for (let n of t.parsers)
                if (n.nextLine(this, e, t)) return null;
            t.content += "\n" + e.scrub();
            for (let n of e.markers) t.marks.push(n)
        }
        return this.finishLeaf(t), null
    }
    stopAt(e) {
        if (null != this.stoppedAt && this.stoppedAt < e) throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = e
    }
    reuseFragment(e) {
        if (!this.fragments.moveTo(this.absoluteLineStart + e, this.absoluteLineStart) || !this.fragments.matches(this.block.hash)) return !1;
        let t = this.fragments.takeNodes(this);
        return !!t && (this.absoluteLineStart += t, this.lineStart = toRelative(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0)
    }
    get depth() {
        return this.stack.length
    }
    parentType(e = this.depth - 1) {
        return this.parser.nodeSet.types[this.stack[e].type]
    }
    nextLine() {
        return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0)
    }
    peekLine() {
        return this.scanLine(this.absoluteLineEnd + 1).text
    }
    moveRangeI() {
        for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to;) this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from)
    }
    scanLine(e) {
        let t = Da;
        if (t.end = e, e >= this.to) t.text = "";
        else if (t.text = this.lineChunkAt(e), t.end += t.text.length, this.ranges.length > 1) {
            let e = this.absoluteLineStart,
                n = this.rangeI;
            for (; this.ranges[n].to < t.end;) {
                n++;
                let o = this.ranges[n].from,
                    h = this.lineChunkAt(o);
                t.end = o + h.length, t.text = t.text.slice(0, this.ranges[n - 1].to - e) + h, e = t.end - t.text.length
            }
        }
        return t
    }
    readLine() {
        let {
            line: e
        } = this, {
            text: t,
            end: n
        } = this.scanLine(this.absoluteLineStart);
        for (this.absoluteLineEnd = n, e.reset(t); e.depth < this.stack.length; e.depth++) {
            let t = this.stack[e.depth],
                n = this.parser.skipContextMarkup[t.type];
            if (!n) throw new Error("Unhandled block context " + Pa[t.type]);
            let o = this.line.markers.length;
            if (!n(t, this, e)) {
                this.line.markers.length > o && (t.end = this.line.markers[this.line.markers.length - 1].to), e.forward();
                break
            }
            e.forward()
        }
    }
    lineChunkAt(e) {
        let t, n = this.input.chunk(e);
        if (this.input.lineChunks) t = "\n" == n ? "" : n;
        else {
            let e = n.indexOf("\n");
            t = e < 0 ? n : n.slice(0, e)
        }
        return e + t.length > this.to ? t.slice(0, this.to - e) : t
    }
    prevLineEnd() {
        return this.atEnd ? this.lineStart : this.lineStart - 1
    }
    startContext(e, t, n = 0) {
        this.block = CompositeBlock.create(e, n, this.lineStart + t, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block)
    }
    startComposite(e, t, n = 0) {
        this.startContext(this.parser.getNodeType(e), t, n)
    }
    addNode(e, t, n) {
        "number" == typeof e && (e = new Tree(this.parser.nodeSet.types[e], Va, Va, (null != n ? n : this.prevLineEnd()) - t)), this.block.addChild(e, t - this.block.from)
    }
    addElement(e) {
        this.block.addChild(e.toTree(this.parser.nodeSet), e.from - this.block.from)
    }
    addLeafElement(e, t) {
        this.addNode(this.buffer.writeElements(injectMarks(t.children, e.marks), -t.from).finish(t.type, t.to - t.from), t.from)
    }
    finishContext() {
        let e = this.stack.pop(),
            t = this.stack[this.stack.length - 1];
        t.addChild(e.toTree(this.parser.nodeSet), e.from - t.from), this.block = t
    }
    finish() {
        for (; this.stack.length > 1;) this.finishContext();
        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart))
    }
    addGaps(e) {
        return this.ranges.length > 1 ? injectGaps(this.ranges, 0, e.topNode, this.ranges[0].from, this.reusePlaceholders) : e
    }
    finishLeaf(e) {
        for (let t of e.parsers)
            if (t.finish(this, e)) return;
        let t = injectMarks(this.parser.parseInline(e.content, e.start), e.marks);
        this.addNode(this.buffer.writeElements(t, -e.start).finish(Pa.Paragraph, e.content.length), e.start)
    }
    elt(e, t, n, o) {
        return "string" == typeof e ? elt(this.parser.getNodeType(e), t, n, o) : new TreeElement(e, t)
    }
    get buffer() {
        return new Za(this.parser.nodeSet)
    }
}

function injectGaps(e, t, n, o, h) {
    let p = e[t].to,
        f = [],
        g = [],
        y = n.from + o;

    function movePastNext(n, h) {
        for (; h ? n >= p : n > p;) {
            let h = e[t + 1].from - p;
            o += h, n += h, t++, p = e[t].to
        }
    }
    for (let w = n.firstChild; w; w = w.nextSibling) {
        movePastNext(w.from + o, !0);
        let n, b = w.from + o,
            S = h.get(w.tree);
        S ? n = S : w.to + o > p ? (n = injectGaps(e, t, w, o, h), movePastNext(w.to + o, !1)) : n = w.toTree(), f.push(n), g.push(b - y)
    }
    return movePastNext(n.to + o, !1), new Tree(n.type, f, g, n.to + o - y, n.tree ? n.tree.propValues : void 0)
}
class MarkdownParser extends Parser {
    constructor(e, t, n, o, h, p, f, g, y) {
        super(), this.nodeSet = e, this.blockParsers = t, this.leafBlockParsers = n, this.blockNames = o, this.endLeafBlock = h, this.skipContextMarkup = p, this.inlineParsers = f, this.inlineNames = g, this.wrappers = y, this.nodeTypes = Object.create(null);
        for (let t of e.types) this.nodeTypes[t.name] = t.id
    }
    createParse(e, t, n) {
        let o = new BlockContext(this, e, t, n);
        for (let h of this.wrappers) o = h(o, e, t, n);
        return o
    }
    configure(e) {
        let t = resolveConfig(e);
        if (!t) return this;
        let {
            nodeSet: n,
            skipContextMarkup: o
        } = this, h = this.blockParsers.slice(), p = this.leafBlockParsers.slice(), f = this.blockNames.slice(), g = this.inlineParsers.slice(), y = this.inlineNames.slice(), w = this.endLeafBlock.slice(), b = this.wrappers;
        if (nonEmpty(t.defineNodes)) {
            o = Object.assign({}, o);
            let e, h = n.types.slice();
            for (let n of t.defineNodes) {
                let {
                    name: t,
                    block: p,
                    composite: f,
                    style: g
                } = "string" == typeof n ? {
                    name: n
                } : n;
                if (h.some((e => e.name == t))) continue;
                f && (o[h.length] = (e, t, n) => f(t, n, e.value));
                let y = h.length,
                    w = f ? ["Block", "BlockContext"] : p ? y >= Pa.ATXHeading1 && y <= Pa.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
                h.push(NodeType.define({
                    id: y,
                    name: t,
                    props: w && [
                        [NodeProp.group, w]
                    ]
                })), g && (e || (e = {}), Array.isArray(g) || g instanceof Tag ? e[t] = g : Object.assign(e, g))
            }
            n = new NodeSet(h), e && (n = n.extend(styleTags(e)))
        }
        if (nonEmpty(t.props) && (n = n.extend(...t.props)), nonEmpty(t.remove))
            for (let e of t.remove) {
                let t = this.blockNames.indexOf(e),
                    n = this.inlineNames.indexOf(e);
                t > -1 && (h[t] = p[t] = void 0), n > -1 && (g[n] = void 0)
            }
        if (nonEmpty(t.parseBlock))
            for (let e of t.parseBlock) {
                let t = f.indexOf(e.name);
                if (t > -1) h[t] = e.parse, p[t] = e.leaf;
                else {
                    let t = e.before ? findName(f, e.before) : e.after ? findName(f, e.after) + 1 : f.length - 1;
                    h.splice(t, 0, e.parse), p.splice(t, 0, e.leaf), f.splice(t, 0, e.name)
                }
                e.endLeaf && w.push(e.endLeaf)
            }
        if (nonEmpty(t.parseInline))
            for (let e of t.parseInline) {
                let t = y.indexOf(e.name);
                if (t > -1) g[t] = e.parse;
                else {
                    let t = e.before ? findName(y, e.before) : e.after ? findName(y, e.after) + 1 : y.length - 1;
                    g.splice(t, 0, e.parse), y.splice(t, 0, e.name)
                }
            }
        return t.wrap && (b = b.concat(t.wrap)), new MarkdownParser(n, h, p, f, w, o, g, y, b)
    }
    getNodeType(e) {
        let t = this.nodeTypes[e];
        if (null == t) throw new RangeError(`Unknown node type '${e}'`);
        return t
    }
    parseInline(e, t) {
        let n = new InlineContext(this, e, t);
        e: for (let e = t; e < n.end;) {
            let t = n.char(e);
            for (let o of this.inlineParsers)
                if (o) {
                    let h = o(n, t, e);
                    if (h >= 0) {
                        e = h;
                        continue e
                    }
                }
            e++
        }
        return n.resolveMarkers(0)
    }
}

function nonEmpty(e) {
    return null != e && e.length > 0
}

function resolveConfig(e) {
    if (!Array.isArray(e)) return e;
    if (0 == e.length) return null;
    let t = resolveConfig(e[0]);
    if (1 == e.length) return t;
    let n = resolveConfig(e.slice(1));
    if (!n || !t) return t || n;
    let conc = (e, t) => (e || Va).concat(t || Va),
        o = t.wrap,
        h = n.wrap;
    return {
        props: conc(t.props, n.props),
        defineNodes: conc(t.defineNodes, n.defineNodes),
        parseBlock: conc(t.parseBlock, n.parseBlock),
        parseInline: conc(t.parseInline, n.parseInline),
        remove: conc(t.remove, n.remove),
        wrap: o ? h ? (e, t, n, p) => o(h(e, t, n, p), t, n, p) : o : h
    }
}

function findName(e, t) {
    let n = e.indexOf(t);
    if (n < 0) throw new RangeError(`Position specified relative to unknown parser ${t}`);
    return n
}
let La = [NodeType.none];
for (let hh, dh = 1; hh = Pa[dh]; dh++) La[dh] = NodeType.define({
    id: dh,
    name: hh,
    props: dh >= Pa.Escape ? [] : [
        [NodeProp.group, dh in Ca ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]
    ],
    top: "Document" == hh
});
const Va = [];
let Za = class {
    constructor(e) {
        this.nodeSet = e, this.content = [], this.nodes = []
    }
    write(e, t, n, o = 0) {
        return this.content.push(e, t, n, 4 + 4 * o), this
    }
    writeElements(e, t = 0) {
        for (let n of e) n.writeTo(this, t);
        return this
    }
    finish(e, t) {
        return Tree.build({
            buffer: this.content,
            nodeSet: this.nodeSet,
            reused: this.nodes,
            topID: e,
            length: t
        })
    }
};
class Element {
    constructor(e, t, n, o = Va) {
        this.type = e, this.from = t, this.to = n, this.children = o
    }
    writeTo(e, t) {
        let n = e.content.length;
        e.writeElements(this.children, t), e.content.push(this.type, this.from + t, this.to + t, e.content.length + 4 - n)
    }
    toTree(e) {
        return new Za(e).writeElements(this.children, -this.from).finish(this.type, this.to - this.from)
    }
}
class TreeElement {
    constructor(e, t) {
        this.tree = e, this.from = t
    }
    get to() {
        return this.from + this.tree.length
    }
    get type() {
        return this.tree.type.id
    }
    get children() {
        return Va
    }
    writeTo(e, t) {
        e.nodes.push(this.tree), e.content.push(e.nodes.length - 1, this.from + t, this.to + t, -1)
    }
    toTree() {
        return this.tree
    }
}

function elt(e, t, n, o) {
    return new Element(e, t, n, o)
}
const _a = {
        resolve: "Emphasis",
        mark: "EmphasisMark"
    },
    Ba = {
        resolve: "Emphasis",
        mark: "EmphasisMark"
    },
    Ia = {},
    Xa = {};
class InlineDelimiter {
    constructor(e, t, n, o) {
        this.type = e, this.from = t, this.to = n, this.side = o
    }
}
const qa = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let za = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
    za = new RegExp("[\\p{S}|\\p{P}]", "u")
} catch (uh) {}
const Na = {
    Escape(e, t, n) {
        if (92 != t || n == e.end - 1) return -1;
        let o = e.char(n + 1);
        for (let t = 0; t < 32; t++)
            if (qa.charCodeAt(t) == o) return e.append(elt(Pa.Escape, n, n + 2));
        return -1
    },
    Entity(e, t, n) {
        if (38 != t) return -1;
        let o = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(e.slice(n + 1, n + 31));
        return o ? e.append(elt(Pa.Entity, n, n + 1 + o[0].length)) : -1
    },
    InlineCode(e, t, n) {
        if (96 != t || n && 96 == e.char(n - 1)) return -1;
        let o = n + 1;
        for (; o < e.end && 96 == e.char(o);) o++;
        let h = o - n,
            p = 0;
        for (; o < e.end; o++)
            if (96 == e.char(o)) {
                if (p++, p == h && 96 != e.char(o + 1)) return e.append(elt(Pa.InlineCode, n, o + 1, [elt(Pa.CodeMark, n, n + h), elt(Pa.CodeMark, o + 1 - h, o + 1)]))
            } else p = 0;
        return -1
    },
    HTMLTag(e, t, n) {
        if (60 != t || n == e.end - 1) return -1;
        let o = e.slice(n + 1, e.end),
            h = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(o);
        if (h) return e.append(elt(Pa.Autolink, n, n + 1 + h[0].length, [elt(Pa.LinkMark, n, n + 1), elt(Pa.URL, n + 1, n + h[0].length), elt(Pa.LinkMark, n + h[0].length, n + 1 + h[0].length)]));
        let p = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(o);
        if (p) return e.append(elt(Pa.Comment, n, n + 1 + p[0].length));
        let f = /^\?[^]*?\?>/.exec(o);
        if (f) return e.append(elt(Pa.ProcessingInstruction, n, n + 1 + f[0].length));
        let g = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(o);
        return g ? e.append(elt(Pa.HTMLTag, n, n + 1 + g[0].length)) : -1
    },
    Emphasis(e, t, n) {
        if (95 != t && 42 != t) return -1;
        let o = n + 1;
        for (; e.char(o) == t;) o++;
        let h = e.slice(n - 1, n),
            p = e.slice(o, o + 1),
            f = za.test(h),
            g = za.test(p),
            y = /\s|^$/.test(h),
            w = /\s|^$/.test(p),
            b = !w && (!g || y || f),
            S = !y && (!f || w || g),
            k = b && (42 == t || !S || f),
            v = S && (42 == t || !b || g);
        return e.append(new InlineDelimiter(95 == t ? _a : Ba, n, o, (k ? 1 : 0) | (v ? 2 : 0)))
    },
    HardBreak(e, t, n) {
        if (92 == t && 10 == e.char(n + 1)) return e.append(elt(Pa.HardBreak, n, n + 2));
        if (32 == t) {
            let t = n + 1;
            for (; 32 == e.char(t);) t++;
            if (10 == e.char(t) && t >= n + 2) return e.append(elt(Pa.HardBreak, n, t + 1))
        }
        return -1
    },
    Link: (e, t, n) => 91 == t ? e.append(new InlineDelimiter(Ia, n, n + 1, 1)) : -1,
    Image: (e, t, n) => 33 == t && 91 == e.char(n + 1) ? e.append(new InlineDelimiter(Xa, n, n + 2, 1)) : -1,
    LinkEnd(e, t, n) {
        if (93 != t) return -1;
        for (let t = e.parts.length - 1; t >= 0; t--) {
            let o = e.parts[t];
            if (o instanceof InlineDelimiter && (o.type == Ia || o.type == Xa)) {
                if (!o.side || e.skipSpace(o.to) == n && !/[(\[]/.test(e.slice(n + 1, n + 2))) return e.parts[t] = null, -1;
                let h = e.takeContent(t),
                    p = e.parts[t] = finishLink(e, h, o.type == Ia ? Pa.Link : Pa.Image, o.from, n + 1);
                if (o.type == Ia)
                    for (let n = 0; n < t; n++) {
                        let t = e.parts[n];
                        t instanceof InlineDelimiter && t.type == Ia && (t.side = 0)
                    }
                return p.to
            }
        }
        return -1
    }
};

function finishLink(e, t, n, o, h) {
    let {
        text: p
    } = e, f = e.char(h), g = h;
    if (t.unshift(elt(Pa.LinkMark, o, o + (n == Pa.Image ? 2 : 1))), t.push(elt(Pa.LinkMark, h - 1, h)), 40 == f) {
        let n, o = e.skipSpace(h + 1),
            f = parseURL(p, o - e.offset, e.offset);
        f && (o = e.skipSpace(f.to), o != f.to && (n = parseLinkTitle(p, o - e.offset, e.offset), n && (o = e.skipSpace(n.to)))), 41 == e.char(o) && (t.push(elt(Pa.LinkMark, h, h + 1)), g = o + 1, f && t.push(f), n && t.push(n), t.push(elt(Pa.LinkMark, o, g)))
    } else if (91 == f) {
        let n = parseLinkLabel(p, h - e.offset, e.offset, !1);
        n && (t.push(n), g = n.to)
    }
    return elt(n, o, g, t)
}

function parseURL(e, t, n) {
    if (60 == e.charCodeAt(t)) {
        for (let o = t + 1; o < e.length; o++) {
            let h = e.charCodeAt(o);
            if (62 == h) return elt(Pa.URL, t + n, o + 1 + n);
            if (60 == h || 10 == h) return !1
        }
        return null
    } {
        let o = 0,
            h = t;
        for (let t = !1; h < e.length; h++) {
            let n = e.charCodeAt(h);
            if (space(n)) break;
            if (t) t = !1;
            else if (40 == n) o++;
            else if (41 == n) {
                if (!o) break;
                o--
            } else 92 == n && (t = !0)
        }
        return h > t ? elt(Pa.URL, t + n, h + n) : h == e.length && null
    }
}

function parseLinkTitle(e, t, n) {
    let o = e.charCodeAt(t);
    if (39 != o && 34 != o && 40 != o) return !1;
    let h = 40 == o ? 41 : o;
    for (let o = t + 1, p = !1; o < e.length; o++) {
        let f = e.charCodeAt(o);
        if (p) p = !1;
        else {
            if (f == h) return elt(Pa.LinkTitle, t + n, o + 1 + n);
            92 == f && (p = !0)
        }
    }
    return null
}

function parseLinkLabel(e, t, n, o) {
    for (let h = !1, p = t + 1, f = Math.min(e.length, p + 999); p < f; p++) {
        let f = e.charCodeAt(p);
        if (h) h = !1;
        else {
            if (93 == f) return !o && elt(Pa.LinkLabel, t + n, p + 1 + n);
            if (o && !space(f) && (o = !1), 91 == f) return !1;
            92 == f && (h = !0)
        }
    }
    return null
}
class InlineContext {
    constructor(e, t, n) {
        this.parser = e, this.text = t, this.offset = n, this.parts = []
    }
    char(e) {
        return e >= this.end ? -1 : this.text.charCodeAt(e - this.offset)
    }
    get end() {
        return this.offset + this.text.length
    }
    slice(e, t) {
        return this.text.slice(e - this.offset, t - this.offset)
    }
    append(e) {
        return this.parts.push(e), e.to
    }
    addDelimiter(e, t, n, o, h) {
        return this.append(new InlineDelimiter(e, t, n, (o ? 1 : 0) | (h ? 2 : 0)))
    }
    get hasOpenLink() {
        for (let e = this.parts.length - 1; e >= 0; e--) {
            let t = this.parts[e];
            if (t instanceof InlineDelimiter && (t.type == Ia || t.type == Xa)) return !0
        }
        return !1
    }
    addElement(e) {
        return this.append(e)
    }
    resolveMarkers(e) {
        for (let t = e; t < this.parts.length; t++) {
            let n = this.parts[t];
            if (!(n instanceof InlineDelimiter && n.type.resolve && 2 & n.side)) continue;
            let o, h = n.type == _a || n.type == Ba,
                p = n.to - n.from,
                f = t - 1;
            for (; f >= e; f--) {
                let e = this.parts[f];
                if (e instanceof InlineDelimiter && 1 & e.side && e.type == n.type && !(h && (1 & n.side || 2 & e.side) && (e.to - e.from + p) % 3 == 0 && ((e.to - e.from) % 3 || p % 3))) {
                    o = e;
                    break
                }
            }
            if (!o) continue;
            let g = n.type.resolve,
                y = [],
                w = o.from,
                b = n.to;
            if (h) {
                let e = Math.min(2, o.to - o.from, p);
                w = o.to - e, b = n.from + e, g = 1 == e ? "Emphasis" : "StrongEmphasis"
            }
            o.type.mark && y.push(this.elt(o.type.mark, w, o.to));
            for (let e = f + 1; e < t; e++) this.parts[e] instanceof Element && y.push(this.parts[e]), this.parts[e] = null;
            n.type.mark && y.push(this.elt(n.type.mark, n.from, b));
            let S = this.elt(g, w, b, y);
            this.parts[f] = h && o.from != w ? new InlineDelimiter(o.type, o.from, w, o.side) : null, (this.parts[t] = h && n.to != b ? new InlineDelimiter(n.type, b, n.to, n.side) : null) ? this.parts.splice(t, 0, S) : this.parts[t] = S
        }
        let t = [];
        for (let n = e; n < this.parts.length; n++) {
            let e = this.parts[n];
            e instanceof Element && t.push(e)
        }
        return t
    }
    findOpeningDelimiter(e) {
        for (let t = this.parts.length - 1; t >= 0; t--) {
            let n = this.parts[t];
            if (n instanceof InlineDelimiter && n.type == e && 1 & n.side) return t
        }
        return null
    }
    takeContent(e) {
        let t = this.resolveMarkers(e);
        return this.parts.length = e, t
    }
    getDelimiterAt(e) {
        let t = this.parts[e];
        return t instanceof InlineDelimiter ? t : null
    }
    skipSpace(e) {
        return skipSpace(this.text, e - this.offset) + this.offset
    }
    elt(e, t, n, o) {
        return "string" == typeof e ? elt(this.parser.getNodeType(e), t, n, o) : new TreeElement(e, t)
    }
}

function injectMarks(e, t) {
    if (!t.length) return e;
    if (!e.length) return t;
    let n = e.slice(),
        o = 0;
    for (let e of t) {
        for (; o < n.length && n[o].to < e.to;) o++;
        if (o < n.length && n[o].from < e.from) {
            let t = n[o];
            t instanceof Element && (n[o] = new Element(t.type, t.from, t.to, injectMarks(t.children, [e])))
        } else n.splice(o++, 0, e)
    }
    return n
}
InlineContext.linkStart = Ia, InlineContext.imageStart = Xa;
const Ya = [Pa.CodeBlock, Pa.ListItem, Pa.OrderedList, Pa.BulletList];
class FragmentCursor {
    constructor(e, t) {
        this.fragments = e, this.input = t, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, e.length && (this.fragment = e[this.i++])
    }
    nextFragment() {
        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1
    }
    moveTo(e, t) {
        for (; this.fragment && this.fragment.to <= e;) this.nextFragment();
        if (!this.fragment || this.fragment.from > (e ? e - 1 : 0)) return !1;
        if (this.fragmentEnd < 0) {
            let e = this.fragment.to;
            for (; e > 0 && "\n" != this.input.read(e - 1, e);) e--;
            this.fragmentEnd = e ? e - 1 : 0
        }
        let n = this.cursor;
        n || (n = this.cursor = this.fragment.tree.cursor(), n.firstChild());
        let o = e + this.fragment.offset;
        for (; n.to <= o;)
            if (!n.parent()) return !1;
        for (;;) {
            if (n.from >= o) return this.fragment.from <= t;
            if (!n.childAfter(o)) return !1
        }
    }
    matches(e) {
        let t = this.cursor.tree;
        return t && t.prop(NodeProp.contextHash) == e
    }
    takeNodes(e) {
        let t = this.cursor,
            n = this.fragment.offset,
            o = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0),
            h = e.absoluteLineStart,
            p = h,
            f = e.block.children.length,
            g = p,
            y = f;
        for (;;) {
            if (t.to - n > o) {
                if (t.type.isAnonymous && t.firstChild()) continue;
                break
            }
            let h = toRelative(t.from - n, e.ranges);
            if (t.to - n <= e.ranges[e.rangeI].to) e.addNode(t.tree, h);
            else {
                let n = new Tree(e.parser.nodeSet.types[Pa.Paragraph], [], [], 0, e.block.hashProp);
                e.reusePlaceholders.set(n, t.tree), e.addNode(n, h)
            }
            if (t.type.is("Block") && (Ya.indexOf(t.type.id) < 0 ? (p = t.to - n, f = e.block.children.length) : (p = g, f = y), g = t.to - n, y = e.block.children.length), !t.nextSibling()) break
        }
        for (; e.block.children.length > f;) e.block.children.pop(), e.block.positions.pop();
        return p - h
    }
}

function toRelative(e, t) {
    let n = e;
    for (let o = 1; o < t.length; o++) {
        let h = t[o - 1].to,
            p = t[o].from;
        h < e && (n -= p - h)
    }
    return n
}
const ja = styleTags({
        "Blockquote/...": ai.quote,
        HorizontalRule: ai.contentSeparator,
        "ATXHeading1/... SetextHeading1/...": ai.heading1,
        "ATXHeading2/... SetextHeading2/...": ai.heading2,
        "ATXHeading3/...": ai.heading3,
        "ATXHeading4/...": ai.heading4,
        "ATXHeading5/...": ai.heading5,
        "ATXHeading6/...": ai.heading6,
        "Comment CommentBlock": ai.comment,
        Escape: ai.escape,
        Entity: ai.character,
        "Emphasis/...": ai.emphasis,
        "StrongEmphasis/...": ai.strong,
        "Link/... Image/...": ai.link,
        "OrderedList/... BulletList/...": ai.list,
        "BlockQuote/...": ai.quote,
        "InlineCode CodeText": ai.monospace,
        "URL Autolink": ai.url,
        "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": ai.processingInstruction,
        "CodeInfo LinkLabel": ai.labelName,
        LinkTitle: ai.string,
        Paragraph: ai.content
    }),
    Wa = new MarkdownParser(new NodeSet(La).extend(ja), Object.keys(Aa).map((e => Aa[e])), Object.keys(Aa).map((e => Ma[e])), Object.keys(Aa), Ra, Ca, Object.keys(Na).map((e => Na[e])), Object.keys(Na), []);

function leftOverSpace(e, t, n) {
    let o = [];
    for (let h = e.firstChild, p = t;; h = h.nextSibling) {
        let e = h ? h.from : n;
        if (e > p && o.push({
                from: p,
                to: e
            }), !h) break;
        p = h.to
    }
    return o
}
const Ua = {
        resolve: "Strikethrough",
        mark: "StrikethroughMark"
    },
    Fa = {
        defineNodes: [{
            name: "Strikethrough",
            style: {
                "Strikethrough/...": ai.strikethrough
            }
        }, {
            name: "StrikethroughMark",
            style: ai.processingInstruction
        }],
        parseInline: [{
            name: "Strikethrough",
            parse(e, t, n) {
                if (126 != t || 126 != e.char(n + 1) || 126 == e.char(n + 2)) return -1;
                let o = e.slice(n - 1, n),
                    h = e.slice(n + 2, n + 3),
                    p = /\s|^$/.test(o),
                    f = /\s|^$/.test(h),
                    g = za.test(o),
                    y = za.test(h);
                return e.addDelimiter(Ua, n, n + 2, !f && (!y || p || g), !p && (!g || f || y))
            },
            after: "Emphasis"
        }]
    };

function parseRow(e, t, n = 0, o, h = 0) {
    let p = 0,
        f = !0,
        g = -1,
        y = -1,
        w = !1,
        parseCell = () => {
            o.push(e.elt("TableCell", h + g, h + y, e.parser.parseInline(t.slice(g, y), h + g)))
        };
    for (let b = n; b < t.length; b++) {
        let n = t.charCodeAt(b);
        124 != n || w ? (w || 32 != n && 9 != n) && (g < 0 && (g = b), y = b + 1) : ((!f || g > -1) && p++, f = !1, o && (g > -1 && parseCell(), o.push(e.elt("TableDelimiter", b + h, b + h + 1))), g = y = -1), w = !w && 92 == n
    }
    return g > -1 && (p++, o && parseCell()), p
}

function hasPipe(e, t) {
    for (let n = t; n < e.length; n++) {
        let t = e.charCodeAt(n);
        if (124 == t) return !0;
        92 == t && n++
    }
    return !1
}
const Ga = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class TableParser {
    constructor() {
        this.rows = null
    }
    nextLine(e, t, n) {
        if (null == this.rows) {
            let o;
            if (this.rows = !1, (45 == t.next || 58 == t.next || 124 == t.next) && Ga.test(o = t.text.slice(t.pos))) {
                let h = [];
                parseRow(e, n.content, 0, h, n.start) == parseRow(e, o, t.pos) && (this.rows = [e.elt("TableHeader", n.start, n.start + n.content.length, h), e.elt("TableDelimiter", e.lineStart + t.pos, e.lineStart + t.text.length)])
            }
        } else if (this.rows) {
            let n = [];
            parseRow(e, t.text, t.pos, n, e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + t.pos, e.lineStart + t.text.length, n))
        }
        return !1
    }
    finish(e, t) {
        return !!this.rows && (e.addLeafElement(t, e.elt("Table", t.start, t.start + t.content.length, this.rows)), !0)
    }
}
const Ha = {
    defineNodes: [{
        name: "Table",
        block: !0
    }, {
        name: "TableHeader",
        style: {
            "TableHeader/...": ai.heading
        }
    }, "TableRow", {
        name: "TableCell",
        style: ai.content
    }, {
        name: "TableDelimiter",
        style: ai.processingInstruction
    }],
    parseBlock: [{
        name: "Table",
        leaf: (e, t) => hasPipe(t.content, 0) ? new TableParser : null,
        endLeaf(e, t, n) {
            if (n.parsers.some((e => e instanceof TableParser)) || !hasPipe(t.text, t.basePos)) return !1;
            let o = e.peekLine();
            return Ga.test(o) && parseRow(e, t.text, t.basePos) == parseRow(e, o, t.basePos)
        },
        before: "SetextHeading"
    }]
};
class TaskParser {
    nextLine() {
        return !1
    }
    finish(e, t) {
        return e.addLeafElement(t, e.elt("Task", t.start, t.start + t.content.length, [e.elt("TaskMarker", t.start, t.start + 3), ...e.parser.parseInline(t.content.slice(3), t.start + 3)])), !0
    }
}
const Ka = {
        defineNodes: [{
            name: "Task",
            block: !0,
            style: ai.list
        }, {
            name: "TaskMarker",
            style: ai.atom
        }],
        parseBlock: [{
            name: "TaskList",
            leaf: (e, t) => /^\[[ xX]\][ \t]/.test(t.content) && "ListItem" == e.parentType().name ? new TaskParser : null,
            after: "SetextHeading"
        }]
    },
    Ja = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy,
    el = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy,
    tl = /[\w-]+\.[\w-]+($|\/)/,
    nl = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy,
    il = /\/[a-zA-Z\d@.]+/gy;

function count(e, t, n, o) {
    let h = 0;
    for (let p = t; p < n; p++) e[p] == o && h++;
    return h
}

function autolinkEmailEnd(e, t) {
    nl.lastIndex = t;
    let n = nl.exec(e);
    if (!n) return -1;
    let o = n[0][n[0].length - 1];
    return "_" == o || "-" == o ? -1 : t + n[0].length - ("." == o ? 1 : 0)
}
const rl = {
        parseInline: [{
            name: "Autolink",
            parse(e, t, n) {
                let o = n - e.offset;
                if (o && /\w/.test(e.text[o - 1])) return -1;
                Ja.lastIndex = o;
                let h = Ja.exec(e.text),
                    p = -1;
                if (!h) return -1;
                if (h[1] || h[2]) {
                    if (p = function(e, t) {
                            el.lastIndex = t;
                            let n = el.exec(e);
                            if (!n || tl.exec(n[0])[0].indexOf("_") > -1) return -1;
                            let o = t + n[0].length;
                            for (;;) {
                                let n, h = e[o - 1];
                                if (/[?!.,:*_~]/.test(h) || ")" == h && count(e, t, o, ")") > count(e, t, o, "(")) o--;
                                else {
                                    if (";" != h || !(n = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(e.slice(t, o)))) break;
                                    o = t + n.index
                                }
                            }
                            return o
                        }(e.text, o + h[0].length), p > -1 && e.hasOpenLink) {
                        p = o + /([^\[\]]|\[[^\]]*\])*/.exec(e.text.slice(o, p))[0].length
                    }
                } else h[3] ? p = autolinkEmailEnd(e.text, o) : (p = autolinkEmailEnd(e.text, o + h[0].length), p > -1 && "xmpp:" == h[0] && (il.lastIndex = p, h = il.exec(e.text), h && (p = h.index + h[0].length)));
                return p < 0 ? -1 : (e.addElement(e.elt("URL", n, p + e.offset)), p + e.offset)
            }
        }]
    },
    ol = [Ha, Ka, Fa, rl];

function parseSubSuper(e, t, n) {
    return (o, h, p) => {
        if (h != e || o.char(p + 1) == e) return -1;
        let f = [o.elt(n, p, p + 1)];
        for (let h = p + 1; h < o.end; h++) {
            let g = o.char(h);
            if (g == e) return o.addElement(o.elt(t, p, h + 1, f.concat(o.elt(n, h, h + 1))));
            if (92 == g && f.push(o.elt("Escape", h, 2 + h++)), space(g)) break
        }
        return -1
    }
}
const sl = {
        defineNodes: [{
            name: "Superscript",
            style: ai.special(ai.content)
        }, {
            name: "SuperscriptMark",
            style: ai.processingInstruction
        }],
        parseInline: [{
            name: "Superscript",
            parse: parseSubSuper(94, "Superscript", "SuperscriptMark")
        }]
    },
    al = {
        defineNodes: [{
            name: "Subscript",
            style: ai.special(ai.content)
        }, {
            name: "SubscriptMark",
            style: ai.processingInstruction
        }],
        parseInline: [{
            name: "Subscript",
            parse: parseSubSuper(126, "Subscript", "SubscriptMark")
        }]
    },
    ll = {
        defineNodes: [{
            name: "Emoji",
            style: ai.character
        }],
        parseInline: [{
            name: "Emoji",
            parse(e, t, n) {
                let o;
                return 58 == t && (o = /^[a-zA-Z_0-9]+:/.exec(e.slice(n + 1, e.end))) ? e.addElement(e.elt("Emoji", n, n + 1 + o[0].length)) : -1
            }
        }]
    },
    cl = defineLanguageFacet({
        commentTokens: {
            block: {
                open: "\x3c!--",
                close: "--\x3e"
            }
        }
    }),
    hl = new NodeProp,
    dl = Wa.configure({
        props: [wi.add((e => !e.is("Block") || e.is("Document") || null != isHeading(e) || function(e) {
            return "OrderedList" == e.name || "BulletList" == e.name
        }(e) ? void 0 : (e, t) => ({
            from: t.doc.lineAt(e.from).to,
            to: e.to
        }))), hl.add(isHeading), Oi.add({
            Document: () => null
        }), ci.add({
            Document: cl
        })]
    });

function isHeading(e) {
    let t = /^(?:ATX|Setext)Heading(\d)$/.exec(e.name);
    return t ? +t[1] : void 0
}

function findSectionEnd(e, t) {
    let n = e;
    for (;;) {
        let e, o = n.nextSibling;
        if (!o || null != (e = isHeading(o.type)) && e <= t) break;
        n = o
    }
    return n.to
}
const ul = yi.of(((e, t, n) => {
    for (let o = syntaxTree(e).resolveInner(n, -1); o && !(o.from < t); o = o.parent) {
        let e = o.type.prop(hl);
        if (null == e) continue;
        let t = findSectionEnd(o, e);
        if (t > n) return {
            from: n,
            to: t
        }
    }
    return null
}));

function mkLang(e) {
    return new Language(cl, e, [], "markdown")
}
const pl = mkLang(dl),
    fl = mkLang(dl.configure([ol, al, sl, ll, {
        props: [wi.add({
            Table: (e, t) => ({
                from: t.doc.lineAt(e.from).to,
                to: e.to
            })
        })]
    }]));
class Context {
    constructor(e, t, n, o, h, p, f) {
        this.node = e, this.from = t, this.to = n, this.spaceBefore = o, this.spaceAfter = h, this.type = p, this.item = f
    }
    blank(e, t = !0) {
        let n = this.spaceBefore + ("Blockquote" == this.node.name ? ">" : "");
        if (null != e) {
            for (; n.length < e;) n += " ";
            return n
        }
        for (let e = this.to - this.from - n.length - this.spaceAfter.length; e > 0; e--) n += " ";
        return n + (t ? this.spaceAfter : "")
    }
    marker(e, t) {
        let n = "OrderedList" == this.node.name ? String(+itemNumber(this.item, e)[2] + t) : "";
        return this.spaceBefore + n + this.type + this.spaceAfter
    }
}

function getContext(e, t) {
    let n = [],
        o = [];
    for (let t = e; t; t = t.parent) {
        if ("FencedCode" == t.name) return o;
        "ListItem" != t.name && "Blockquote" != t.name || n.push(t)
    }
    for (let e = n.length - 1; e >= 0; e--) {
        let h, p = n[e],
            f = t.lineAt(p.from),
            g = p.from - f.from;
        if ("Blockquote" == p.name && (h = /^ *>( ?)/.exec(f.text.slice(g)))) o.push(new Context(p, g, g + h[0].length, "", h[1], ">", null));
        else if ("ListItem" == p.name && "OrderedList" == p.parent.name && (h = /^( *)\d+([.)])( *)/.exec(f.text.slice(g)))) {
            let e = h[3],
                t = h[0].length;
            e.length >= 4 && (e = e.slice(0, e.length - 4), t -= 4), o.push(new Context(p.parent, g, g + t, h[1], e, h[2], p))
        } else if ("ListItem" == p.name && "BulletList" == p.parent.name && (h = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(f.text.slice(g)))) {
            let e = h[4],
                t = h[0].length;
            e.length > 4 && (e = e.slice(0, e.length - 4), t -= 4);
            let n = h[2];
            h[3] && (n += h[3].replace(/[xX]/, " ")), o.push(new Context(p.parent, g, g + t, h[1], e, n, p))
        }
    }
    return o
}

function itemNumber(e, t) {
    return /^(\s*)(\d+)(?=[.)])/.exec(t.sliceString(e.from, e.from + 10))
}

function renumberList(e, t, n, o = 0) {
    for (let h = -1, p = e;;) {
        if ("ListItem" == p.name) {
            let e = itemNumber(p, t),
                f = +e[2];
            if (h >= 0) {
                if (f != h + 1) return;
                n.push({
                    from: p.from + e[1].length,
                    to: p.from + e[0].length,
                    insert: String(h + 2 + o)
                })
            }
            h = f
        }
        let e = p.nextSibling;
        if (!e) break;
        p = e
    }
}

function normalizeIndent(e, t) {
    let n = /^[ \t]*/.exec(e)[0].length;
    if (!n || "\t" != t.facet(mi)) return e;
    let o = "";
    for (let t = countColumn(e, 4, n); t > 0;) t >= 4 ? (o += "\t", t -= 4) : (o += " ", t--);
    return o + e.slice(n)
}
const insertNewlineContinueMarkupCommand = (e = {}) => ({
    state: t,
    dispatch: n
}) => {
    let o = syntaxTree(t),
        {
            doc: h
        } = t,
        p = null,
        f = t.changeByRange((n => {
            if (!n.empty || !fl.isActiveAt(t, n.from, -1) && !fl.isActiveAt(t, n.from, 1)) return p = {
                range: n
            };
            let f = n.from,
                g = h.lineAt(f),
                y = getContext(o.resolveInner(f, -1), h);
            for (; y.length && y[y.length - 1].from > f - g.from;) y.pop();
            if (!y.length) return p = {
                range: n
            };
            let w = y[y.length - 1];
            if (w.to - w.spaceAfter.length > f - g.from) return p = {
                range: n
            };
            let b = f >= w.to - w.spaceAfter.length && !/\S/.test(g.text.slice(w.to));
            if (w.item && b) {
                let n = w.node.firstChild,
                    o = w.node.getChild("ListItem", "ListItem");
                if (n.to >= f || o && o.to < f || g.from > 0 && !/[^\s>]/.test(h.lineAt(g.from - 1).text) || !1 === e.nonTightLists) {
                    let e, t = y.length > 1 ? y[y.length - 2] : null,
                        n = "";
                    t && t.item ? (e = g.from + t.from, n = t.marker(h, 1)) : e = g.from + (t ? t.to : 0);
                    let o = [{
                        from: e,
                        to: f,
                        insert: n
                    }];
                    return "OrderedList" == w.node.name && renumberList(w.item, h, o, -2), t && "OrderedList" == t.node.name && renumberList(t.item, h, o), {
                        range: EditorSelection.cursor(e + n.length),
                        changes: o
                    }
                } {
                    let e = blankLine(y, t, g);
                    return {
                        range: EditorSelection.cursor(f + e.length + 1),
                        changes: {
                            from: g.from,
                            insert: e + t.lineBreak
                        }
                    }
                }
            }
            if ("Blockquote" == w.node.name && b && g.from) {
                let e = h.lineAt(g.from - 1),
                    o = />\s*$/.exec(e.text);
                if (o && o.index == w.from) {
                    let h = t.changes([{
                        from: e.from + o.index,
                        to: e.to
                    }, {
                        from: g.from + w.from,
                        to: g.to
                    }]);
                    return {
                        range: n.map(h),
                        changes: h
                    }
                }
            }
            let S = [];
            "OrderedList" == w.node.name && renumberList(w.item, h, S);
            let k = w.item && w.item.from < g.from,
                v = "";
            if (!k || /^[\s\d.)\-+*>]*/.exec(g.text)[0].length >= w.to)
                for (let e = 0, t = y.length - 1; e <= t; e++) v += e != t || k ? y[e].blank(e < t ? countColumn(g.text, 4, y[e + 1].from) - v.length : null) : y[e].marker(h, 1);
            let P = f;
            for (; P > g.from && /\s/.test(g.text.charAt(P - g.from - 1));) P--;
            return v = normalizeIndent(v, t),
                function(e, t) {
                    if ("OrderedList" != e.name && "BulletList" != e.name) return !1;
                    let n = e.firstChild,
                        o = e.getChild("ListItem", "ListItem");
                    if (!o) return !1;
                    let h = t.lineAt(n.to),
                        p = t.lineAt(o.from),
                        f = /^[\s>]*$/.test(h.text);
                    return h.number + (f ? 0 : 1) < p.number
                }(w.node, t.doc) && (v = blankLine(y, t, g) + t.lineBreak + v), S.push({
                    from: P,
                    to: f,
                    insert: t.lineBreak + v
                }), {
                    range: EditorSelection.cursor(P + v.length + 1),
                    changes: S
                }
        }));
    return !p && (n(t.update(f, {
        scrollIntoView: !0,
        userEvent: "input"
    })), !0)
};

function isMark(e) {
    return "QuoteMark" == e.name || "ListMark" == e.name
}

function blankLine(e, t, n) {
    let o = "";
    for (let t = 0, h = e.length - 2; t <= h; t++) o += e[t].blank(t < h ? countColumn(n.text, 4, e[t + 1].from) - o.length : null, t < h);
    return normalizeIndent(o, t)
}
const gl = [{
        key: "Enter",
        run: insertNewlineContinueMarkupCommand()
    }, {
        key: "Backspace",
        run: ({
            state: e,
            dispatch: t
        }) => {
            let n = syntaxTree(e),
                o = null,
                h = e.changeByRange((t => {
                    let h = t.from,
                        {
                            doc: p
                        } = e;
                    if (t.empty && fl.isActiveAt(e, t.from)) {
                        let t = p.lineAt(h),
                            o = getContext(function(e, t) {
                                let n = e.resolveInner(t, -1),
                                    o = t;
                                isMark(n) && (o = n.from, n = n.parent);
                                for (let e; e = n.childBefore(o);)
                                    if (isMark(e)) o = e.from;
                                    else {
                                        if ("OrderedList" != e.name && "BulletList" != e.name) break;
                                        n = e.lastChild, o = n.to
                                    }
                                return n
                            }(n, h), p);
                        if (o.length) {
                            let n = o[o.length - 1],
                                p = n.to - n.spaceAfter.length + (n.spaceAfter ? 1 : 0);
                            if (h - t.from > p && !/\S/.test(t.text.slice(p, h - t.from))) return {
                                range: EditorSelection.cursor(t.from + p),
                                changes: {
                                    from: t.from + p,
                                    to: h
                                }
                            };
                            if (h - t.from == p && (!n.item || t.from <= n.item.from || !/\S/.test(t.text.slice(0, n.to)))) {
                                let o = t.from + n.from;
                                if (n.item && n.node.from < n.item.from && /\S/.test(t.text.slice(n.from, n.to))) {
                                    let h = n.blank(countColumn(t.text, 4, n.to) - countColumn(t.text, 4, n.from));
                                    return o == t.from && (h = normalizeIndent(h, e)), {
                                        range: EditorSelection.cursor(o + h.length),
                                        changes: {
                                            from: o,
                                            to: t.from + n.to,
                                            insert: h
                                        }
                                    }
                                }
                                if (o < h) return {
                                    range: EditorSelection.cursor(o),
                                    changes: {
                                        from: o,
                                        to: h
                                    }
                                }
                            }
                        }
                    }
                    return o = {
                        range: t
                    }
                }));
            return !o && (t(e.update(h, {
                scrollIntoView: !0,
                userEvent: "delete"
            })), !0)
        }
    }],
    ml = html({
        matchClosingTags: !1
    });

function markdown(e = {}) {
    let {
        codeLanguages: t,
        defaultCodeLanguage: n,
        addKeymap: o = !0,
        base: {
            parser: h
        } = pl,
        completeHTMLTags: p = !0,
        pasteURLAsLink: f = !0,
        htmlTagLanguage: g = ml
    } = e;
    if (!(h instanceof MarkdownParser)) throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
    let y, w = e.extensions ? [e.extensions] : [],
        S = [g.support, ul];
    f && S.push(wl), n instanceof LanguageSupport ? (S.push(n.support), y = n.language) : n && (y = n);
    let k = t || y ? (v = t, P = y, e => {
        if (e && v) {
            let t = null;
            if (e = /\S*/.exec(e)[0], t = "function" == typeof v ? v(e) : LanguageDescription.matchLanguageName(v, e, !0), t instanceof LanguageDescription) return t.support ? t.support.language.parser : ParseContext.getSkippingParser(t.load());
            if (t) return t.parser
        }
        return P ? P.parser : null
    }) : void 0;
    var v, P;
    w.push(function(e) {
        let {
            codeParser: t,
            htmlParser: n
        } = e, o = parseMixed(((e, o) => {
            let h = e.type.id;
            if (!t || h != Pa.CodeBlock && h != Pa.FencedCode) {
                if (n && (h == Pa.HTMLBlock || h == Pa.HTMLTag || h == Pa.CommentBlock)) return {
                    parser: n,
                    overlay: leftOverSpace(e.node, e.from, e.to)
                }
            } else {
                let n = "";
                if (h == Pa.FencedCode) {
                    let t = e.node.getChild(Pa.CodeInfo);
                    t && (n = o.read(t.from, t.to))
                }
                let p = t(n);
                if (p) return {
                    parser: p,
                    overlay: e => e.type.id == Pa.CodeText,
                    bracketed: h == Pa.FencedCode
                }
            }
            return null
        }));
        return {
            wrap: o
        }
    }({
        codeParser: k,
        htmlParser: g.language.parser
    })), o && S.push(b.high(Qt.of(gl)));
    let C = mkLang(h.configure(w));
    return p && S.push(C.data.of({
        autocomplete: htmlTagCompletion
    })), new LanguageSupport(C, S)
}

function htmlTagCompletion(e) {
    let {
        state: t,
        pos: n
    } = e, o = /<[:\-\.\w\u00b7-\uffff]*$/.exec(t.sliceDoc(n - 25, n));
    if (!o) return null;
    let h = syntaxTree(t).resolveInner(n, -1);
    for (; h && !h.type.isTop;) {
        if ("CodeBlock" == h.name || "FencedCode" == h.name || "ProcessingInstructionBlock" == h.name || "CommentBlock" == h.name || "Link" == h.name || "Image" == h.name) return null;
        h = h.parent
    }
    return {
        from: n - o[0].length,
        to: n,
        options: htmlTagCompletions(),
        validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
    }
}
let Ol = null;

function htmlTagCompletions() {
    if (Ol) return Ol;
    let e = (t = new CompletionContext(EditorState.create({
        extensions: ml
    }), 0, !0), htmlCompletionFor(Schema.default, t));
    var t;
    return Ol = e ? e.options : []
}
const yl = /code|horizontalrule|html|link|comment|processing|escape|entity|image|mark|url/i,
    wl = EditorView.domEventHandlers({
        paste: (e, t) => {
            var n;
            let {
                main: o
            } = t.state.selection;
            if (o.empty) return !1;
            let h = null === (n = e.clipboardData) || void 0 === n ? void 0 : n.getData("text/plain");
            if (!h || !/^(https?:\/\/|mailto:|xmpp:|www\.)/.test(h)) return !1;
            if (/^www\./.test(h) && (h = "https://" + h), !fl.isActiveAt(t.state, o.from, 1)) return !1;
            let p = syntaxTree(t.state),
                f = !1;
            return p.iterate({
                from: o.from,
                to: o.to,
                enter: e => {
                    (e.from > o.from || yl.test(e.name)) && (f = !0)
                },
                leave: e => {
                    e.to < o.to && (f = !0)
                }
            }), !f && (t.dispatch({
                changes: [{
                    from: o.from,
                    insert: "["
                }, {
                    from: o.to,
                    insert: `](${h})`
                }],
                userEvent: "input.paste",
                scrollIntoView: !0
            }), !0)
        }
    }),
    bl = "#e06c75",
    Sl = "#abb2bf",
    xl = "#7d8799",
    kl = "#d19a66",
    vl = "#2c313a",
    Pl = "#282c34",
    Cl = "#353a42",
    Ql = "#528bff",
    Tl = [EditorView.theme({
        "&": {
            color: Sl,
            backgroundColor: Pl
        },
        ".cm-content": {
            caretColor: Ql
        },
        ".cm-cursor, .cm-dropCursor": {
            borderLeftColor: Ql
        },
        "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": {
            backgroundColor: "#3E4451"
        },
        ".cm-panels": {
            backgroundColor: "#21252b",
            color: Sl
        },
        ".cm-panels.cm-panels-top": {
            borderBottom: "2px solid black"
        },
        ".cm-panels.cm-panels-bottom": {
            borderTop: "2px solid black"
        },
        ".cm-searchMatch": {
            backgroundColor: "#72a1ff59",
            outline: "1px solid #457dff"
        },
        ".cm-searchMatch.cm-searchMatch-selected": {
            backgroundColor: "#6199ff2f"
        },
        ".cm-activeLine": {
            backgroundColor: "#6699ff0b"
        },
        ".cm-selectionMatch": {
            backgroundColor: "#aafe661a"
        },
        "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
            backgroundColor: "#bad0f847"
        },
        ".cm-gutters": {
            backgroundColor: Pl,
            color: xl,
            border: "none"
        },
        ".cm-activeLineGutter": {
            backgroundColor: vl
        },
        ".cm-foldPlaceholder": {
            backgroundColor: "transparent",
            border: "none",
            color: "#ddd"
        },
        ".cm-tooltip": {
            border: "none",
            backgroundColor: Cl
        },
        ".cm-tooltip .cm-tooltip-arrow:before": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
        },
        ".cm-tooltip .cm-tooltip-arrow:after": {
            borderTopColor: Cl,
            borderBottomColor: Cl
        },
        ".cm-tooltip-autocomplete": {
            "& > ul > li[aria-selected]": {
                backgroundColor: vl,
                color: Sl
            }
        }
    }, {
        dark: !0
    }), syntaxHighlighting(HighlightStyle.define([{
        tag: ai.keyword,
        color: "#c678dd"
    }, {
        tag: [ai.name, ai.deleted, ai.character, ai.propertyName, ai.macroName],
        color: bl
    }, {
        tag: [ai.function(ai.variableName), ai.labelName],
        color: "#61afef"
    }, {
        tag: [ai.color, ai.constant(ai.name), ai.standard(ai.name)],
        color: kl
    }, {
        tag: [ai.definition(ai.name), ai.separator],
        color: Sl
    }, {
        tag: [ai.typeName, ai.className, ai.number, ai.changed, ai.annotation, ai.modifier, ai.self, ai.namespace],
        color: "#e5c07b"
    }, {
        tag: [ai.operator, ai.operatorKeyword, ai.url, ai.escape, ai.regexp, ai.link, ai.special(ai.string)],
        color: "#56b6c2"
    }, {
        tag: [ai.meta, ai.comment],
        color: xl
    }, {
        tag: ai.strong,
        fontWeight: "bold"
    }, {
        tag: ai.emphasis,
        fontStyle: "italic"
    }, {
        tag: ai.strikethrough,
        textDecoration: "line-through"
    }, {
        tag: ai.link,
        color: xl,
        textDecoration: "underline"
    }, {
        tag: ai.heading,
        fontWeight: "bold",
        color: bl
    }, {
        tag: [ai.atom, ai.bool, ai.special(ai.variableName)],
        color: kl
    }, {
        tag: [ai.processingInstruction, ai.string, ai.inserted],
        color: "#98c379"
    }, {
        tag: ai.invalid,
        color: "#ffffff"
    }]))],
    create$5 = () => new Map,
    copy = e => {
        const t = create$5();
        return e.forEach(((e, n) => {
            t.set(n, e)
        })), t
    },
    setIfUndefined = (e, t, n) => {
        let o = e.get(t);
        return void 0 === o && e.set(t, o = n()), o
    },
    create$4 = () => new Set,
    last = e => e[e.length - 1],
    appendTo = (e, t) => {
        for (let n = 0; n < t.length; n++) e.push(t[n])
    },
    $l = Array.from,
    El = Array.isArray;
class ObservableV2 {
    constructor() {
        this._observers = create$5()
    }
    on(e, t) {
        return setIfUndefined(this._observers, e, create$4).add(t), t
    }
    once(e, t) {
        const _f = (...n) => {
            this.off(e, _f), t(...n)
        };
        this.on(e, _f)
    }
    off(e, t) {
        const n = this._observers.get(e);
        void 0 !== n && (n.delete(t), 0 === n.size && this._observers.delete(e))
    }
    emit(e, t) {
        return $l((this._observers.get(e) || create$5()).values()).forEach((e => e(...t)))
    }
    destroy() {
        this._observers = create$5()
    }
}
class Observable {
    constructor() {
        this._observers = create$5()
    }
    on(e, t) {
        setIfUndefined(this._observers, e, create$4).add(t)
    }
    once(e, t) {
        const _f = (...n) => {
            this.off(e, _f), t(...n)
        };
        this.on(e, _f)
    }
    off(e, t) {
        const n = this._observers.get(e);
        void 0 !== n && (n.delete(t), 0 === n.size && this._observers.delete(e))
    }
    emit(e, t) {
        return $l((this._observers.get(e) || create$5()).values()).forEach((e => e(...t)))
    }
    destroy() {
        this._observers = create$5()
    }
}
const Al = Math.floor,
    Ml = Math.abs,
    min = (e, t) => e < t ? e : t,
    max = (e, t) => e > t ? e : t,
    Rl = Math.pow,
    isNegativeZero = e => 0 !== e ? e < 0 : 1 / e < 0,
    Dl = 64,
    Ll = 128,
    Vl = 127,
    Zl = Number.MAX_SAFE_INTEGER,
    _l = Number.isInteger || (e => "number" == typeof e && isFinite(e) && Al(e) === e),
    Bl = String.fromCharCode,
    Il = /^\s*/g,
    Xl = /([A-Z])/g,
    fromCamelCase = (e, t) => (e => e.replace(Il, ""))(e.replace(Xl, (e => `${t}${(e=>e.toLowerCase())(e)}`))),
    ql = "undefined" != typeof TextEncoder ? new TextEncoder : null,
    zl = ql ? e => ql.encode(e) : e => {
        const t = unescape(encodeURIComponent(e)),
            n = t.length,
            o = new Uint8Array(n);
        for (let e = 0; e < n; e++) o[e] = t.codePointAt(e);
        return o
    };
let Nl = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8", {
    fatal: !0,
    ignoreBOM: !0
});
Nl && 1 === Nl.decode(new Uint8Array).length && (Nl = null);
const repeat = (e, t) => ((e, t) => {
    const n = new Array(e);
    for (let o = 0; o < e; o++) n[o] = t(o, n);
    return n
})(t, (() => e)).join("");
class Encoder {
    constructor() {
        this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = []
    }
}
const createEncoder = () => new Encoder,
    length$1 = e => {
        let t = e.cpos;
        for (let n = 0; n < e.bufs.length; n++) t += e.bufs[n].length;
        return t
    },
    toUint8Array = e => {
        const t = new Uint8Array(length$1(e));
        let n = 0;
        for (let o = 0; o < e.bufs.length; o++) {
            const h = e.bufs[o];
            t.set(h, n), n += h.length
        }
        return t.set(new Uint8Array(e.cbuf.buffer, 0, e.cpos), n), t
    },
    write = (e, t) => {
        const n = e.cbuf.length;
        e.cpos === n && (e.bufs.push(e.cbuf), e.cbuf = new Uint8Array(2 * n), e.cpos = 0), e.cbuf[e.cpos++] = t
    },
    Yl = write,
    writeVarUint = (e, t) => {
        for (; t > Vl;) write(e, Ll | Vl & t), t = Al(t / 128);
        write(e, Vl & t)
    },
    writeVarInt = (e, t) => {
        const n = isNegativeZero(t);
        for (n && (t = -t), write(e, (t > 63 ? Ll : 0) | (n ? Dl : 0) | 63 & t), t = Al(t / 64); t > 0;) write(e, (t > Vl ? Ll : 0) | Vl & t), t = Al(t / 128)
    },
    jl = new Uint8Array(3e4),
    Wl = jl.length / 3,
    Ul = ql && ql.encodeInto ? (e, t) => {
        if (t.length < Wl) {
            const n = ql.encodeInto(t, jl).written || 0;
            writeVarUint(e, n);
            for (let t = 0; t < n; t++) write(e, jl[t])
        } else writeVarUint8Array(e, zl(t))
    } : (e, t) => {
        const n = unescape(encodeURIComponent(t)),
            o = n.length;
        writeVarUint(e, o);
        for (let t = 0; t < o; t++) write(e, n.codePointAt(t))
    },
    writeUint8Array = (e, t) => {
        const n = e.cbuf.length,
            o = e.cpos,
            h = min(n - o, t.length),
            p = t.length - h;
        e.cbuf.set(t.subarray(0, h), o), e.cpos += h, p > 0 && (e.bufs.push(e.cbuf), e.cbuf = new Uint8Array(max(2 * n, p)), e.cbuf.set(t.subarray(h)), e.cpos = p)
    },
    writeVarUint8Array = (e, t) => {
        writeVarUint(e, t.byteLength), writeUint8Array(e, t)
    },
    writeOnDataView = (e, t) => {
        ((e, t) => {
            const n = e.cbuf.length;
            n - e.cpos < t && (e.bufs.push(new Uint8Array(e.cbuf.buffer, 0, e.cpos)), e.cbuf = new Uint8Array(2 * max(n, t)), e.cpos = 0)
        })(e, t);
        const n = new DataView(e.cbuf.buffer, e.cpos, t);
        return e.cpos += t, n
    },
    Fl = new DataView(new ArrayBuffer(4)),
    writeAny = (e, t) => {
        switch (typeof t) {
            case "string":
                write(e, 119), Ul(e, t);
                break;
            case "number":
                _l(t) && Ml(t) <= 2147483647 ? (write(e, 125), writeVarInt(e, t)) : (n = t, Fl.setFloat32(0, n), Fl.getFloat32(0) === n ? (write(e, 124), ((e, t) => {
                    writeOnDataView(e, 4).setFloat32(0, t, !1)
                })(e, t)) : (write(e, 123), ((e, t) => {
                    writeOnDataView(e, 8).setFloat64(0, t, !1)
                })(e, t)));
                break;
            case "bigint":
                write(e, 122), ((e, t) => {
                    writeOnDataView(e, 8).setBigInt64(0, t, !1)
                })(e, t);
                break;
            case "object":
                if (null === t) write(e, 126);
                else if (El(t)) {
                    write(e, 117), writeVarUint(e, t.length);
                    for (let n = 0; n < t.length; n++) writeAny(e, t[n])
                } else if (t instanceof Uint8Array) write(e, 116), writeVarUint8Array(e, t);
                else {
                    write(e, 118);
                    const n = Object.keys(t);
                    writeVarUint(e, n.length);
                    for (let o = 0; o < n.length; o++) {
                        const h = n[o];
                        Ul(e, h), writeAny(e, t[h])
                    }
                }
                break;
            case "boolean":
                write(e, t ? 120 : 121);
                break;
            default:
                write(e, 127)
        }
        var n
    };
class RleEncoder extends Encoder {
    constructor(e) {
        super(), this.w = e, this.s = null, this.count = 0
    }
    write(e) {
        this.s === e ? this.count++ : (this.count > 0 && writeVarUint(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e)
    }
}
const flushUintOptRleEncoder = e => {
    e.count > 0 && (writeVarInt(e.encoder, 1 === e.count ? e.s : -e.s), e.count > 1 && writeVarUint(e.encoder, e.count - 2))
};
class UintOptRleEncoder {
    constructor() {
        this.encoder = new Encoder, this.s = 0, this.count = 0
    }
    write(e) {
        this.s === e ? this.count++ : (flushUintOptRleEncoder(this), this.count = 1, this.s = e)
    }
    toUint8Array() {
        return flushUintOptRleEncoder(this), toUint8Array(this.encoder)
    }
}
const flushIntDiffOptRleEncoder = e => {
    if (e.count > 0) {
        const t = 2 * e.diff + (1 === e.count ? 0 : 1);
        writeVarInt(e.encoder, t), e.count > 1 && writeVarUint(e.encoder, e.count - 2)
    }
};
class IntDiffOptRleEncoder {
    constructor() {
        this.encoder = new Encoder, this.s = 0, this.count = 0, this.diff = 0
    }
    write(e) {
        this.diff === e - this.s ? (this.s = e, this.count++) : (flushIntDiffOptRleEncoder(this), this.count = 1, this.diff = e - this.s, this.s = e)
    }
    toUint8Array() {
        return flushIntDiffOptRleEncoder(this), toUint8Array(this.encoder)
    }
}
class StringEncoder {
    constructor() {
        this.sarr = [], this.s = "", this.lensE = new UintOptRleEncoder
    }
    write(e) {
        this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length)
    }
    toUint8Array() {
        const e = new Encoder;
        return this.sarr.push(this.s), this.s = "", Ul(e, this.sarr.join("")), writeUint8Array(e, this.lensE.toUint8Array()), toUint8Array(e)
    }
}
const create$3 = e => new Error(e),
    methodUnimplemented = () => {
        throw create$3("Method unimplemented")
    },
    unexpectedCase = () => {
        throw create$3("Unexpected case")
    },
    Gl = create$3("Unexpected end of array"),
    Hl = create$3("Integer out of Range");
class Decoder {
    constructor(e) {
        this.arr = e, this.pos = 0
    }
}
const createDecoder = e => new Decoder(e),
    hasContent = e => e.pos !== e.arr.length,
    readVarUint8Array = e => ((e, t) => {
        const n = new Uint8Array(e.arr.buffer, e.pos + e.arr.byteOffset, t);
        return e.pos += t, n
    })(e, readVarUint(e)),
    readUint8 = e => e.arr[e.pos++],
    readVarUint = e => {
        let t = 0,
            n = 1;
        const o = e.arr.length;
        for (; e.pos < o;) {
            const o = e.arr[e.pos++];
            if (t += (o & Vl) * n, n *= 128, o < Ll) return t;
            if (t > Zl) throw Hl
        }
        throw Gl
    },
    readVarInt = e => {
        let t = e.arr[e.pos++],
            n = 63 & t,
            o = 64;
        const h = (t & Dl) > 0 ? -1 : 1;
        if (!(t & Ll)) return h * n;
        const p = e.arr.length;
        for (; e.pos < p;) {
            if (t = e.arr[e.pos++], n += (t & Vl) * o, o *= 128, t < Ll) return h * n;
            if (n > Zl) throw Hl
        }
        throw Gl
    },
    Kl = Nl ? e => Nl.decode(readVarUint8Array(e)) : e => {
        let t = readVarUint(e);
        if (0 === t) return ""; {
            let n = String.fromCodePoint(readUint8(e));
            if (--t < 100)
                for (; t--;) n += String.fromCodePoint(readUint8(e));
            else
                for (; t > 0;) {
                    const o = t < 1e4 ? t : 1e4,
                        h = e.arr.subarray(e.pos, e.pos + o);
                    e.pos += o, n += String.fromCodePoint.apply(null, h), t -= o
                }
            return decodeURIComponent(escape(n))
        }
    },
    readFromDataView = (e, t) => {
        const n = new DataView(e.arr.buffer, e.arr.byteOffset + e.pos, t);
        return e.pos += t, n
    },
    Jl = [e => {}, e => null, readVarInt, e => readFromDataView(e, 4).getFloat32(0, !1), e => readFromDataView(e, 8).getFloat64(0, !1), e => readFromDataView(e, 8).getBigInt64(0, !1), e => !1, e => !0, Kl, e => {
        const t = readVarUint(e),
            n = {};
        for (let o = 0; o < t; o++) {
            n[Kl(e)] = readAny(e)
        }
        return n
    }, e => {
        const t = readVarUint(e),
            n = [];
        for (let o = 0; o < t; o++) n.push(readAny(e));
        return n
    }, readVarUint8Array],
    readAny = e => Jl[127 - readUint8(e)](e);
class RleDecoder extends Decoder {
    constructor(e, t) {
        super(e), this.reader = t, this.s = null, this.count = 0
    }
    read() {
        return 0 === this.count && (this.s = this.reader(this), hasContent(this) ? this.count = readVarUint(this) + 1 : this.count = -1), this.count--, this.s
    }
}
class UintOptRleDecoder extends Decoder {
    constructor(e) {
        super(e), this.s = 0, this.count = 0
    }
    read() {
        if (0 === this.count) {
            this.s = readVarInt(this);
            const e = isNegativeZero(this.s);
            this.count = 1, e && (this.s = -this.s, this.count = readVarUint(this) + 2)
        }
        return this.count--, this.s
    }
}
class IntDiffOptRleDecoder extends Decoder {
    constructor(e) {
        super(e), this.s = 0, this.count = 0, this.diff = 0
    }
    read() {
        if (0 === this.count) {
            const e = readVarInt(this),
                t = 1 & e;
            this.diff = Al(e / 2), this.count = 1, t && (this.count = readVarUint(this) + 2)
        }
        return this.s += this.diff, this.count--, this.s
    }
}
class StringDecoder {
    constructor(e) {
        this.decoder = new UintOptRleDecoder(e), this.str = Kl(this.decoder), this.spos = 0
    }
    read() {
        const e = this.spos + this.decoder.read(),
            t = this.str.slice(this.spos, e);
        return this.spos = e, t
    }
}
const ec = crypto.getRandomValues.bind(crypto),
    uint32 = () => ec(new Uint32Array(1))[0],
    tc = [1e7] + -1e3 + -4e3 + -8e3 + -1e11,
    uuidv4 = () => tc.replace(/[018]/g, (e => (e ^ uint32() & 15 >> e / 4).toString(16))),
    nc = Date.now,
    create$2 = e => new Promise(e);
Promise.all.bind(Promise);
const undefinedToNull = e => void 0 === e ? null : e;
let ic = new class {
        constructor() {
            this.map = new Map
        }
        setItem(e, t) {
            this.map.set(e, t)
        }
        getItem(e) {
            return this.map.get(e)
        }
    },
    rc = !0;
try {
    "undefined" != typeof localStorage && localStorage && (ic = localStorage, rc = !1)
} catch (ph) {}
const oc = ic,
    sc = Object.assign,
    ac = Object.keys,
    length = e => ac(e).length,
    size = e => ac(e).length,
    hasProperty = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
    lc = Object.freeze,
    deepFreeze = e => {
        for (const t in e) {
            const n = e[t];
            "object" != typeof n && "function" != typeof n || deepFreeze(e[t])
        }
        return lc(e)
    },
    callAll = (e, t, n = 0) => {
        try {
            for (; n < e.length; n++) e[n](...t)
        } finally {
            n < e.length && callAll(e, t, n + 1)
        }
    },
    id = e => e,
    equalityDeep = (e, t) => {
        if (null == e || null == t) return ((e, t) => e === t)(e, t);
        if (e.constructor !== t.constructor) return !1;
        if (e === t) return !0;
        switch (e.constructor) {
            case ArrayBuffer:
                e = new Uint8Array(e), t = new Uint8Array(t);
            case Uint8Array:
                if (e.byteLength !== t.byteLength) return !1;
                for (let n = 0; n < e.length; n++)
                    if (e[n] !== t[n]) return !1;
                break;
            case Set:
                if (e.size !== t.size) return !1;
                for (const n of e)
                    if (!t.has(n)) return !1;
                break;
            case Map:
                if (e.size !== t.size) return !1;
                for (const n of e.keys())
                    if (!t.has(n) || !equalityDeep(e.get(n), t.get(n))) return !1;
                break;
            case Object:
                if (length(e) !== length(t)) return !1;
                for (const n in e)
                    if (!hasProperty(e, n) || !equalityDeep(e[n], t[n])) return !1;
                break;
            case Array:
                if (e.length !== t.length) return !1;
                for (let n = 0; n < e.length; n++)
                    if (!equalityDeep(e[n], t[n])) return !1;
                break;
            default:
                return !1
        }
        return !0
    },
    cc = "undefined" != typeof process && process.release && /node|io\.js/.test(process.release.name) && "[object process]" === Object.prototype.toString.call("undefined" != typeof process ? process : 0),
    hc = "undefined" != typeof window && "undefined" != typeof document && !cc;
let dc;
const hasParam = e => (() => {
        if (void 0 === dc)
            if (cc) {
                dc = create$5();
                const e = process.argv;
                let t = null;
                for (let n = 0; n < e.length; n++) {
                    const o = e[n];
                    "-" === o[0] ? (null !== t && dc.set(t, ""), t = o) : null !== t && (dc.set(t, o), t = null)
                }
                null !== t && dc.set(t, "")
            } else "object" == typeof location ? (dc = create$5(), (location.search || "?").slice(1).split("&").forEach((e => {
                if (0 !== e.length) {
                    const [t, n] = e.split("=");
                    dc.set(`--${fromCamelCase(t,"-")}`, n), dc.set(`-${fromCamelCase(t,"-")}`, n)
                }
            }))) : dc = create$5();
        return dc
    })().has(e),
    getVariable = e => undefinedToNull(cc ? process.env[e.toUpperCase().replaceAll("-", "_")] : oc.getItem(e)),
    hasConf = e => hasParam("--" + e) || null !== getVariable(e);
hasConf("production");
var uc;
const pc = cc && (uc = process.env.FORCE_COLOR, ["true", "1", "2"].includes(uc)) || !hasParam("--no-colors") && !hasConf("no-color") && (!cc || process.stdout.isTTY) && (!cc || hasParam("--color") || null !== getVariable("COLORTERM") || (getVariable("TERM") || "").includes("color")),
    createUint8ArrayFromLen = e => new Uint8Array(e),
    fc = hc ? e => {
        let t = "";
        for (let n = 0; n < e.byteLength; n++) t += Bl(e[n]);
        return btoa(t)
    } : e => Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString("base64"),
    gc = hc ? e => {
        const t = atob(e),
            n = createUint8ArrayFromLen(t.length);
        for (let e = 0; e < t.length; e++) n[e] = t.charCodeAt(e);
        return n
    } : e => {
        const t = Buffer.from(e, "base64");
        return ((e, t, n) => new Uint8Array(e, t, n))(t.buffer, t.byteOffset, t.byteLength)
    };
class Pair {
    constructor(e, t) {
        this.left = e, this.right = t
    }
}
const create$1 = (e, t) => new Pair(e, t);
"undefined" != typeof DOMParser && new DOMParser;
const mc = Symbol,
    Oc = mc(),
    yc = mc(),
    wc = mc(),
    bc = mc(),
    Sc = mc(),
    xc = mc(),
    kc = mc(),
    vc = mc(),
    Pc = mc(),
    Cc = {
        [Oc]: create$1("font-weight", "bold"),
        [yc]: create$1("font-weight", "normal"),
        [wc]: create$1("color", "blue"),
        [Sc]: create$1("color", "green"),
        [bc]: create$1("color", "grey"),
        [xc]: create$1("color", "red"),
        [kc]: create$1("color", "purple"),
        [vc]: create$1("color", "orange"),
        [Pc]: create$1("color", "black")
    },
    Qc = pc ? e => {
        1 === e.length && e[0] ? .constructor === Function && (e = e[0]());
        const t = [],
            n = [],
            o = create$5();
        let h = [],
            p = 0;
        for (; p < e.length; p++) {
            const h = e[p],
                f = Cc[h];
            if (void 0 !== f) o.set(f.left, f.right);
            else {
                if (void 0 === h) break;
                if (h.constructor !== String && h.constructor !== Number) break; {
                    const e = ((e, t) => {
                        const n = [];
                        for (const [o, h] of e) n.push(t(h, o));
                        return n
                    })(o, ((e, t) => `${t}:${e};`)).join("");
                    p > 0 || e.length > 0 ? (t.push("%c" + h), n.push(e)) : t.push(h)
                }
            }
        }
        for (p > 0 && (h = n, h.unshift(t.join(""))); p < e.length; p++) {
            const t = e[p];
            t instanceof Symbol || h.push(t)
        }
        return h
    } : e => {
        1 === e.length && e[0] ? .constructor === Function && (e = e[0]());
        const t = [],
            n = [];
        let o = 0;
        for (; o < e.length; o++) {
            const n = e[o];
            if (void 0 === n) break;
            if (n.constructor === String || n.constructor === Number) t.push(n);
            else if (n.constructor === Object) break
        }
        for (o > 0 && n.push(t.join("")); o < e.length; o++) {
            const t = e[o];
            t instanceof Symbol || n.push(t)
        }
        return n
    },
    print = (...e) => {
        console.log(...Qc(e)), Tc.forEach((t => t.print(e)))
    },
    warn = (...e) => {
        console.warn(...Qc(e)), e.unshift(vc), Tc.forEach((t => t.print(e)))
    },
    Tc = create$4(),
    createIterator = e => ({
        [Symbol.iterator]() {
            return this
        },
        next: e
    }),
    iteratorMap = (e, t) => createIterator((() => {
        const {
            done: n,
            value: o
        } = e.next();
        return {
            done: n,
            value: n ? void 0 : t(o)
        }
    }));
class DeleteItem {
    constructor(e, t) {
        this.clock = e, this.len = t
    }
}
class DeleteSet {
    constructor() {
        this.clients = new Map
    }
}
const iterateDeletedStructs = (e, t, n) => t.clients.forEach(((t, o) => {
        const h = e.doc.store.clients.get(o);
        for (let o = 0; o < t.length; o++) {
            const p = t[o];
            iterateStructs(e, h, p.clock, p.len, n)
        }
    })),
    isDeleted = (e, t) => {
        const n = e.clients.get(t.client);
        return void 0 !== n && null !== ((e, t) => {
            let n = 0,
                o = e.length - 1;
            for (; n <= o;) {
                const h = Al((n + o) / 2),
                    p = e[h],
                    f = p.clock;
                if (f <= t) {
                    if (t < f + p.len) return h;
                    n = h + 1
                } else o = h - 1
            }
            return null
        })(n, t.clock)
    },
    sortAndMergeDeleteSet = e => {
        e.clients.forEach((e => {
            let t, n;
            for (e.sort(((e, t) => e.clock - t.clock)), t = 1, n = 1; t < e.length; t++) {
                const o = e[n - 1],
                    h = e[t];
                o.clock + o.len >= h.clock ? o.len = max(o.len, h.clock + h.len - o.clock) : (n < t && (e[n] = h), n++)
            }
            e.length = n
        }))
    },
    mergeDeleteSets = e => {
        const t = new DeleteSet;
        for (let n = 0; n < e.length; n++) e[n].clients.forEach(((o, h) => {
            if (!t.clients.has(h)) {
                const p = o.slice();
                for (let t = n + 1; t < e.length; t++) appendTo(p, e[t].clients.get(h) || []);
                t.clients.set(h, p)
            }
        }));
        return sortAndMergeDeleteSet(t), t
    },
    addToDeleteSet = (e, t, n, o) => {
        setIfUndefined(e.clients, t, (() => [])).push(new DeleteItem(n, o))
    },
    createDeleteSet = () => new DeleteSet,
    createDeleteSetFromStructStore = e => {
        const t = createDeleteSet();
        return e.clients.forEach(((e, n) => {
            const o = [];
            for (let t = 0; t < e.length; t++) {
                const n = e[t];
                if (n.deleted) {
                    const h = n.id.clock;
                    let p = n.length;
                    if (t + 1 < e.length)
                        for (let n = e[t + 1]; t + 1 < e.length && n.deleted; n = e[1 + ++t]) p += n.length;
                    o.push(new DeleteItem(h, p))
                }
            }
            o.length > 0 && t.clients.set(n, o)
        })), t
    },
    writeDeleteSet = (e, t) => {
        writeVarUint(e.restEncoder, t.clients.size), $l(t.clients.entries()).sort(((e, t) => t[0] - e[0])).forEach((([t, n]) => {
            e.resetDsCurVal(), writeVarUint(e.restEncoder, t);
            const o = n.length;
            writeVarUint(e.restEncoder, o);
            for (let t = 0; t < o; t++) {
                const o = n[t];
                e.writeDsClock(o.clock), e.writeDsLen(o.len)
            }
        }))
    },
    readDeleteSet = e => {
        const t = new DeleteSet,
            n = readVarUint(e.restDecoder);
        for (let o = 0; o < n; o++) {
            e.resetDsCurVal();
            const n = readVarUint(e.restDecoder),
                o = readVarUint(e.restDecoder);
            if (o > 0) {
                const h = setIfUndefined(t.clients, n, (() => []));
                for (let t = 0; t < o; t++) h.push(new DeleteItem(e.readDsClock(), e.readDsLen()))
            }
        }
        return t
    },
    readAndApplyDeleteSet = (e, t, n) => {
        const o = new DeleteSet,
            h = readVarUint(e.restDecoder);
        for (let p = 0; p < h; p++) {
            e.resetDsCurVal();
            const h = readVarUint(e.restDecoder),
                p = readVarUint(e.restDecoder),
                f = n.clients.get(h) || [],
                g = getState(n, h);
            for (let n = 0; n < p; n++) {
                const n = e.readDsClock(),
                    p = n + e.readDsLen();
                if (n < g) {
                    g < p && addToDeleteSet(o, h, g, p - g);
                    let e = findIndexSS(f, n),
                        y = f[e];
                    for (!y.deleted && y.id.clock < n && (f.splice(e + 1, 0, splitItem(t, y, n - y.id.clock)), e++); e < f.length && (y = f[e++], y.id.clock < p);) y.deleted || (p < y.id.clock + y.length && f.splice(e, 0, splitItem(t, y, p - y.id.clock)), y.delete(t))
                } else addToDeleteSet(o, h, n, p - n)
            }
        }
        if (o.clients.size > 0) {
            const e = new UpdateEncoderV2;
            return writeVarUint(e.restEncoder, 0), writeDeleteSet(e, o), e.toUint8Array()
        }
        return null
    },
    equalDeleteSets = (e, t) => {
        if (e.clients.size !== t.clients.size) return !1;
        for (const [n, o] of e.clients.entries()) {
            const e = t.clients.get(n);
            if (void 0 === e || o.length !== e.length) return !1;
            for (let t = 0; t < o.length; t++) {
                const n = o[t],
                    h = e[t];
                if (n.clock !== h.clock || n.len !== h.len) return !1
            }
        }
        return !0
    },
    $c = uint32;
class Doc extends ObservableV2 {
    constructor({
        guid: e = uuidv4(),
        collectionid: t = null,
        gc: n = !0,
        gcFilter: o = () => !0,
        meta: h = null,
        autoLoad: p = !1,
        shouldLoad: f = !0
    } = {}) {
        super(), this.gc = n, this.gcFilter = o, this.clientID = $c(), this.guid = e, this.collectionid = t, this.share = new Map, this.store = new StructStore, this._transaction = null, this._transactionCleanups = [], this.subdocs = new Set, this._item = null, this.shouldLoad = f, this.autoLoad = p, this.meta = h, this.isLoaded = !1, this.isSynced = !1, this.isDestroyed = !1, this.whenLoaded = create$2((e => {
            this.on("load", (() => {
                this.isLoaded = !0, e(this)
            }))
        }));
        const provideSyncedPromise = () => create$2((e => {
            const eventHandler = t => {
                void 0 !== t && !0 !== t || (this.off("sync", eventHandler), e())
            };
            this.on("sync", eventHandler)
        }));
        this.on("sync", (e => {
            !1 === e && this.isSynced && (this.whenSynced = provideSyncedPromise()), this.isSynced = void 0 === e || !0 === e, this.isSynced && !this.isLoaded && this.emit("load", [this])
        })), this.whenSynced = provideSyncedPromise()
    }
    load() {
        const e = this._item;
        null === e || this.shouldLoad || transact(e.parent.doc, (e => {
            e.subdocsLoaded.add(this)
        }), null, !0), this.shouldLoad = !0
    }
    getSubdocs() {
        return this.subdocs
    }
    getSubdocGuids() {
        return new Set($l(this.subdocs).map((e => e.guid)))
    }
    transact(e, t = null) {
        return transact(this, e, t)
    }
    get(e, t = AbstractType) {
        const n = setIfUndefined(this.share, e, (() => {
                const e = new t;
                return e._integrate(this, null), e
            })),
            o = n.constructor;
        if (t !== AbstractType && o !== t) {
            if (o === AbstractType) {
                const o = new t;
                o._map = n._map, n._map.forEach((e => {
                    for (; null !== e; e = e.left) e.parent = o
                })), o._start = n._start;
                for (let e = o._start; null !== e; e = e.right) e.parent = o;
                return o._length = n._length, this.share.set(e, o), o._integrate(this, null), o
            }
            throw new Error(`Type with the name ${e} has already been defined with a different constructor`)
        }
        return n
    }
    getArray(e = "") {
        return this.get(e, YArray)
    }
    getText(e = "") {
        return this.get(e, YText)
    }
    getMap(e = "") {
        return this.get(e, YMap)
    }
    getXmlElement(e = "") {
        return this.get(e, YXmlElement)
    }
    getXmlFragment(e = "") {
        return this.get(e, YXmlFragment)
    }
    toJSON() {
        const e = {};
        return this.share.forEach(((t, n) => {
            e[n] = t.toJSON()
        })), e
    }
    destroy() {
        this.isDestroyed = !0, $l(this.subdocs).forEach((e => e.destroy()));
        const e = this._item;
        if (null !== e) {
            this._item = null;
            const t = e.content;
            t.doc = new Doc({
                guid: this.guid,
                ...t.opts,
                shouldLoad: !1
            }), t.doc._item = e, transact(e.parent.doc, (n => {
                const o = t.doc;
                e.deleted || n.subdocsAdded.add(o), n.subdocsRemoved.add(this)
            }), null, !0)
        }
        this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy()
    }
}
class DSDecoderV1 {
    constructor(e) {
        this.restDecoder = e
    }
    resetDsCurVal() {}
    readDsClock() {
        return readVarUint(this.restDecoder)
    }
    readDsLen() {
        return readVarUint(this.restDecoder)
    }
}
class UpdateDecoderV1 extends DSDecoderV1 {
    readLeftID() {
        return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder))
    }
    readRightID() {
        return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder))
    }
    readClient() {
        return readVarUint(this.restDecoder)
    }
    readInfo() {
        return readUint8(this.restDecoder)
    }
    readString() {
        return Kl(this.restDecoder)
    }
    readParentInfo() {
        return 1 === readVarUint(this.restDecoder)
    }
    readTypeRef() {
        return readVarUint(this.restDecoder)
    }
    readLen() {
        return readVarUint(this.restDecoder)
    }
    readAny() {
        return readAny(this.restDecoder)
    }
    readBuf() {
        return (e => {
            const t = createUint8ArrayFromLen(e.byteLength);
            return t.set(e), t
        })(readVarUint8Array(this.restDecoder))
    }
    readJSON() {
        return JSON.parse(Kl(this.restDecoder))
    }
    readKey() {
        return Kl(this.restDecoder)
    }
}
class DSDecoderV2 {
    constructor(e) {
        this.dsCurrVal = 0, this.restDecoder = e
    }
    resetDsCurVal() {
        this.dsCurrVal = 0
    }
    readDsClock() {
        return this.dsCurrVal += readVarUint(this.restDecoder), this.dsCurrVal
    }
    readDsLen() {
        const e = readVarUint(this.restDecoder) + 1;
        return this.dsCurrVal += e, e
    }
}
class UpdateDecoderV2 extends DSDecoderV2 {
    constructor(e) {
        super(e), this.keys = [], readVarUint(e), this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(e)), this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(e)), this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(e)), this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(e)), this.infoDecoder = new RleDecoder(readVarUint8Array(e), readUint8), this.stringDecoder = new StringDecoder(readVarUint8Array(e)), this.parentInfoDecoder = new RleDecoder(readVarUint8Array(e), readUint8), this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(e)), this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(e))
    }
    readLeftID() {
        return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())
    }
    readRightID() {
        return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())
    }
    readClient() {
        return this.clientDecoder.read()
    }
    readInfo() {
        return this.infoDecoder.read()
    }
    readString() {
        return this.stringDecoder.read()
    }
    readParentInfo() {
        return 1 === this.parentInfoDecoder.read()
    }
    readTypeRef() {
        return this.typeRefDecoder.read()
    }
    readLen() {
        return this.lenDecoder.read()
    }
    readAny() {
        return readAny(this.restDecoder)
    }
    readBuf() {
        return readVarUint8Array(this.restDecoder)
    }
    readJSON() {
        return readAny(this.restDecoder)
    }
    readKey() {
        const e = this.keyClockDecoder.read();
        if (e < this.keys.length) return this.keys[e]; {
            const e = this.stringDecoder.read();
            return this.keys.push(e), e
        }
    }
}
class DSEncoderV1 {
    constructor() {
        this.restEncoder = createEncoder()
    }
    toUint8Array() {
        return toUint8Array(this.restEncoder)
    }
    resetDsCurVal() {}
    writeDsClock(e) {
        writeVarUint(this.restEncoder, e)
    }
    writeDsLen(e) {
        writeVarUint(this.restEncoder, e)
    }
}
class UpdateEncoderV1 extends DSEncoderV1 {
    writeLeftID(e) {
        writeVarUint(this.restEncoder, e.client), writeVarUint(this.restEncoder, e.clock)
    }
    writeRightID(e) {
        writeVarUint(this.restEncoder, e.client), writeVarUint(this.restEncoder, e.clock)
    }
    writeClient(e) {
        writeVarUint(this.restEncoder, e)
    }
    writeInfo(e) {
        Yl(this.restEncoder, e)
    }
    writeString(e) {
        Ul(this.restEncoder, e)
    }
    writeParentInfo(e) {
        writeVarUint(this.restEncoder, e ? 1 : 0)
    }
    writeTypeRef(e) {
        writeVarUint(this.restEncoder, e)
    }
    writeLen(e) {
        writeVarUint(this.restEncoder, e)
    }
    writeAny(e) {
        writeAny(this.restEncoder, e)
    }
    writeBuf(e) {
        writeVarUint8Array(this.restEncoder, e)
    }
    writeJSON(e) {
        Ul(this.restEncoder, JSON.stringify(e))
    }
    writeKey(e) {
        Ul(this.restEncoder, e)
    }
}
class DSEncoderV2 {
    constructor() {
        this.restEncoder = createEncoder(), this.dsCurrVal = 0
    }
    toUint8Array() {
        return toUint8Array(this.restEncoder)
    }
    resetDsCurVal() {
        this.dsCurrVal = 0
    }
    writeDsClock(e) {
        const t = e - this.dsCurrVal;
        this.dsCurrVal = e, writeVarUint(this.restEncoder, t)
    }
    writeDsLen(e) {
        0 === e && unexpectedCase(), writeVarUint(this.restEncoder, e - 1), this.dsCurrVal += e
    }
}
class UpdateEncoderV2 extends DSEncoderV2 {
    constructor() {
        super(), this.keyMap = new Map, this.keyClock = 0, this.keyClockEncoder = new IntDiffOptRleEncoder, this.clientEncoder = new UintOptRleEncoder, this.leftClockEncoder = new IntDiffOptRleEncoder, this.rightClockEncoder = new IntDiffOptRleEncoder, this.infoEncoder = new RleEncoder(Yl), this.stringEncoder = new StringEncoder, this.parentInfoEncoder = new RleEncoder(Yl), this.typeRefEncoder = new UintOptRleEncoder, this.lenEncoder = new UintOptRleEncoder
    }
    toUint8Array() {
        const e = createEncoder();
        return writeVarUint(e, 0), writeVarUint8Array(e, this.keyClockEncoder.toUint8Array()), writeVarUint8Array(e, this.clientEncoder.toUint8Array()), writeVarUint8Array(e, this.leftClockEncoder.toUint8Array()), writeVarUint8Array(e, this.rightClockEncoder.toUint8Array()), writeVarUint8Array(e, toUint8Array(this.infoEncoder)), writeVarUint8Array(e, this.stringEncoder.toUint8Array()), writeVarUint8Array(e, toUint8Array(this.parentInfoEncoder)), writeVarUint8Array(e, this.typeRefEncoder.toUint8Array()), writeVarUint8Array(e, this.lenEncoder.toUint8Array()), writeUint8Array(e, toUint8Array(this.restEncoder)), toUint8Array(e)
    }
    writeLeftID(e) {
        this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock)
    }
    writeRightID(e) {
        this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock)
    }
    writeClient(e) {
        this.clientEncoder.write(e)
    }
    writeInfo(e) {
        this.infoEncoder.write(e)
    }
    writeString(e) {
        this.stringEncoder.write(e)
    }
    writeParentInfo(e) {
        this.parentInfoEncoder.write(e ? 1 : 0)
    }
    writeTypeRef(e) {
        this.typeRefEncoder.write(e)
    }
    writeLen(e) {
        this.lenEncoder.write(e)
    }
    writeAny(e) {
        writeAny(this.restEncoder, e)
    }
    writeBuf(e) {
        writeVarUint8Array(this.restEncoder, e)
    }
    writeJSON(e) {
        writeAny(this.restEncoder, e)
    }
    writeKey(e) {
        const t = this.keyMap.get(e);
        void 0 === t ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(t)
    }
}
const writeClientsStructs = (e, t, n) => {
        const o = new Map;
        n.forEach(((e, n) => {
            getState(t, n) > e && o.set(n, e)
        })), getStateVector(t).forEach(((e, t) => {
            n.has(t) || o.set(t, 0)
        })), writeVarUint(e.restEncoder, o.size), $l(o.entries()).sort(((e, t) => t[0] - e[0])).forEach((([n, o]) => {
            ((e, t, n, o) => {
                o = max(o, t[0].id.clock);
                const h = findIndexSS(t, o);
                writeVarUint(e.restEncoder, t.length - h), e.writeClient(n), writeVarUint(e.restEncoder, o);
                const p = t[h];
                p.write(e, o - p.id.clock);
                for (let n = h + 1; n < t.length; n++) t[n].write(e, 0)
            })(e, t.clients.get(n), n, o)
        }))
    },
    readUpdateV2 = (e, t, n, o = new UpdateDecoderV2(e)) => transact(t, (e => {
        e.local = !1;
        let t = !1;
        const n = e.doc,
            h = n.store,
            p = ((e, t) => {
                const n = create$5(),
                    o = readVarUint(e.restDecoder);
                for (let h = 0; h < o; h++) {
                    const o = readVarUint(e.restDecoder),
                        h = new Array(o),
                        p = e.readClient();
                    let f = readVarUint(e.restDecoder);
                    n.set(p, {
                        i: 0,
                        refs: h
                    });
                    for (let n = 0; n < o; n++) {
                        const o = e.readInfo();
                        switch (31 & o) {
                            case 0:
                                {
                                    const t = e.readLen();h[n] = new GC(createID(p, f), t),
                                    f += t;
                                    break
                                }
                            case 10:
                                {
                                    const t = readVarUint(e.restDecoder);h[n] = new Skip(createID(p, f), t),
                                    f += t;
                                    break
                                }
                            default:
                                {
                                    const g = !(192 & o),
                                        y = new Item(createID(p, f), null, (o & Ll) === Ll ? e.readLeftID() : null, null, (o & Dl) === Dl ? e.readRightID() : null, g ? e.readParentInfo() ? t.get(e.readString()) : e.readLeftID() : null, !g || 32 & ~o ? null : e.readString(), readItemContent(e, o));h[n] = y,
                                    f += y.length
                                }
                        }
                    }
                }
                return n
            })(o, n),
            f = ((e, t, n) => {
                const o = [];
                let h = $l(n.keys()).sort(((e, t) => e - t));
                if (0 === h.length) return null;
                const getNextStructTarget = () => {
                    if (0 === h.length) return null;
                    let e = n.get(h[h.length - 1]);
                    for (; e.refs.length === e.i;) {
                        if (h.pop(), !(h.length > 0)) return null;
                        e = n.get(h[h.length - 1])
                    }
                    return e
                };
                let p = getNextStructTarget();
                if (null === p) return null;
                const f = new StructStore,
                    g = new Map,
                    updateMissingSv = (e, t) => {
                        const n = g.get(e);
                        (null == n || n > t) && g.set(e, t)
                    };
                let y = p.refs[p.i++];
                const w = new Map,
                    addStackToRestSS = () => {
                        for (const e of o) {
                            const t = e.id.client,
                                o = n.get(t);
                            o ? (o.i--, f.clients.set(t, o.refs.slice(o.i)), n.delete(t), o.i = 0, o.refs = []) : f.clients.set(t, [e]), h = h.filter((e => e !== t))
                        }
                        o.length = 0
                    };
                for (;;) {
                    if (y.constructor !== Skip) {
                        const h = setIfUndefined(w, y.id.client, (() => getState(t, y.id.client))) - y.id.clock;
                        if (h < 0) o.push(y), updateMissingSv(y.id.client, y.id.clock - 1), addStackToRestSS();
                        else {
                            const p = y.getMissing(e, t);
                            if (null !== p) {
                                o.push(y);
                                const e = n.get(p) || {
                                    refs: [],
                                    i: 0
                                };
                                if (e.refs.length !== e.i) {
                                    y = e.refs[e.i++];
                                    continue
                                }
                                updateMissingSv(p, getState(t, p)), addStackToRestSS()
                            } else(0 === h || h < y.length) && (y.integrate(e, h), w.set(y.id.client, y.id.clock + y.length))
                        }
                    }
                    if (o.length > 0) y = o.pop();
                    else if (null !== p && p.i < p.refs.length) y = p.refs[p.i++];
                    else {
                        if (p = getNextStructTarget(), null === p) break;
                        y = p.refs[p.i++]
                    }
                }
                if (f.clients.size > 0) {
                    const e = new UpdateEncoderV2;
                    return writeClientsStructs(e, f, new Map), writeVarUint(e.restEncoder, 0), {
                        missing: g,
                        update: e.toUint8Array()
                    }
                }
                return null
            })(e, h, p),
            g = h.pendingStructs;
        if (g) {
            for (const [e, n] of g.missing)
                if (n < getState(h, e)) {
                    t = !0;
                    break
                }
            if (f) {
                for (const [e, t] of f.missing) {
                    const n = g.missing.get(e);
                    (null == n || n > t) && g.missing.set(e, t)
                }
                g.update = mergeUpdatesV2([g.update, f.update])
            }
        } else h.pendingStructs = f;
        const y = readAndApplyDeleteSet(o, e, h);
        if (h.pendingDs) {
            const t = new UpdateDecoderV2(createDecoder(h.pendingDs));
            readVarUint(t.restDecoder);
            const n = readAndApplyDeleteSet(t, e, h);
            h.pendingDs = y && n ? mergeUpdatesV2([y, n]) : y || n
        } else h.pendingDs = y;
        if (t) {
            const t = h.pendingStructs.update;
            h.pendingStructs = null, applyUpdateV2(e.doc, t)
        }
    }), n, !1),
    applyUpdateV2 = (e, t, n, o = UpdateDecoderV2) => {
        const h = createDecoder(t);
        readUpdateV2(h, e, n, new o(h))
    },
    applyUpdate = (e, t, n) => applyUpdateV2(e, t, n, UpdateDecoderV1),
    encodeStateAsUpdateV2 = (e, t = new Uint8Array([0]), n = new UpdateEncoderV2) => {
        ((e, t, n = new Map) => {
            writeClientsStructs(e, t.store, n), writeDeleteSet(e, createDeleteSetFromStructStore(t.store))
        })(n, e, decodeStateVector(t));
        const o = [n.toUint8Array()];
        if (e.store.pendingDs && o.push(e.store.pendingDs), e.store.pendingStructs && o.push(diffUpdateV2(e.store.pendingStructs.update, t)), o.length > 1) {
            if (n.constructor === UpdateEncoderV1) return mergeUpdates(o.map(((e, t) => 0 === t ? e : convertUpdateFormatV2ToV1(e))));
            if (n.constructor === UpdateEncoderV2) return mergeUpdatesV2(o)
        }
        return o[0]
    },
    encodeStateAsUpdate = (e, t) => encodeStateAsUpdateV2(e, t, new UpdateEncoderV1),
    readStateVector = e => {
        const t = new Map,
            n = readVarUint(e.restDecoder);
        for (let o = 0; o < n; o++) {
            const n = readVarUint(e.restDecoder),
                o = readVarUint(e.restDecoder);
            t.set(n, o)
        }
        return t
    },
    decodeStateVector = e => readStateVector(new DSDecoderV1(createDecoder(e))),
    writeStateVector = (e, t) => (writeVarUint(e.restEncoder, t.size), $l(t.entries()).sort(((e, t) => t[0] - e[0])).forEach((([t, n]) => {
        writeVarUint(e.restEncoder, t), writeVarUint(e.restEncoder, n)
    })), e),
    encodeStateVectorV2 = (e, t = new DSEncoderV2) => (e instanceof Map ? writeStateVector(t, e) : ((e, t) => {
        writeStateVector(e, getStateVector(t.store))
    })(t, e), t.toUint8Array()),
    encodeStateVector = e => encodeStateVectorV2(e, new DSEncoderV1);
class EventHandler {
    constructor() {
        this.l = []
    }
}
const createEventHandler = () => new EventHandler,
    addEventHandlerListener = (e, t) => e.l.push(t),
    removeEventHandlerListener = (e, t) => {
        const n = e.l,
            o = n.length;
        e.l = n.filter((e => t !== e)), o === e.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.")
    },
    callEventHandlerListeners = (e, t, n) => callAll(e.l, [t, n]);
class ID {
    constructor(e, t) {
        this.client = e, this.clock = t
    }
}
const compareIDs = (e, t) => e === t || null !== e && null !== t && e.client === t.client && e.clock === t.clock,
    createID = (e, t) => new ID(e, t),
    writeID = (e, t) => {
        writeVarUint(e, t.client), writeVarUint(e, t.clock)
    },
    readID = e => createID(readVarUint(e), readVarUint(e)),
    findRootTypeKey = e => {
        for (const [t, n] of e.doc.share.entries())
            if (n === e) return t;
        throw unexpectedCase()
    },
    isParentOf = (e, t) => {
        for (; null !== t;) {
            if (t.parent === e) return !0;
            t = t.parent._item
        }
        return !1
    };
class RelativePosition {
    constructor(e, t, n, o = 0) {
        this.type = e, this.tname = t, this.item = n, this.assoc = o
    }
}
class AbsolutePosition {
    constructor(e, t, n = 0) {
        this.type = e, this.index = t, this.assoc = n
    }
}
const createRelativePosition = (e, t, n) => {
    let o = null,
        h = null;
    return null === e._item ? h = findRootTypeKey(e) : o = createID(e._item.id.client, e._item.id.clock), new RelativePosition(o, h, t, n)
};
class Snapshot {
    constructor(e, t) {
        this.ds = e, this.sv = t
    }
}
const encodeSnapshotV2 = (e, t = new DSEncoderV2) => (writeDeleteSet(t, e.ds), writeStateVector(t, e.sv), t.toUint8Array()),
    decodeSnapshotV2 = (e, t = new DSDecoderV2(createDecoder(e))) => new Snapshot(readDeleteSet(t), readStateVector(t)),
    createSnapshot = (e, t) => new Snapshot(e, t),
    Ec = createSnapshot(createDeleteSet(), new Map),
    isVisible = (e, t) => void 0 === t ? !e.deleted : t.sv.has(e.id.client) && (t.sv.get(e.id.client) || 0) > e.id.clock && !isDeleted(t.ds, e.id),
    splitSnapshotAffectedStructs = (e, t) => {
        const n = setIfUndefined(e.meta, splitSnapshotAffectedStructs, create$4),
            o = e.doc.store;
        n.has(t) || (t.sv.forEach(((t, n) => {
            t < getState(o, n) && getItemCleanStart(e, createID(n, t))
        })), iterateDeletedStructs(e, t.ds, (e => {})), n.add(t))
    };
class StructStore {
    constructor() {
        this.clients = new Map, this.pendingStructs = null, this.pendingDs = null
    }
}
const getStateVector = e => {
        const t = new Map;
        return e.clients.forEach(((e, n) => {
            const o = e[e.length - 1];
            t.set(n, o.id.clock + o.length)
        })), t
    },
    getState = (e, t) => {
        const n = e.clients.get(t);
        if (void 0 === n) return 0;
        const o = n[n.length - 1];
        return o.id.clock + o.length
    },
    addStruct = (e, t) => {
        let n = e.clients.get(t.id.client);
        if (void 0 === n) n = [], e.clients.set(t.id.client, n);
        else {
            const e = n[n.length - 1];
            if (e.id.clock + e.length !== t.id.clock) throw unexpectedCase()
        }
        n.push(t)
    },
    findIndexSS = (e, t) => {
        let n = 0,
            o = e.length - 1,
            h = e[o],
            p = h.id.clock;
        if (p === t) return o;
        let f = Al(t / (p + h.length - 1) * o);
        for (; n <= o;) {
            if (h = e[f], p = h.id.clock, p <= t) {
                if (t < p + h.length) return f;
                n = f + 1
            } else o = f - 1;
            f = Al((n + o) / 2)
        }
        throw unexpectedCase()
    },
    getItem = (e, t) => {
        const n = e.clients.get(t.client);
        return n[findIndexSS(n, t.clock)]
    },
    findIndexCleanStart = (e, t, n) => {
        const o = findIndexSS(t, n),
            h = t[o];
        return h.id.clock < n && h instanceof Item ? (t.splice(o + 1, 0, splitItem(e, h, n - h.id.clock)), o + 1) : o
    },
    getItemCleanStart = (e, t) => {
        const n = e.doc.store.clients.get(t.client);
        return n[findIndexCleanStart(e, n, t.clock)]
    },
    getItemCleanEnd = (e, t, n) => {
        const o = t.clients.get(n.client),
            h = findIndexSS(o, n.clock),
            p = o[h];
        return n.clock !== p.id.clock + p.length - 1 && p.constructor !== GC && o.splice(h + 1, 0, splitItem(e, p, n.clock - p.id.clock + 1)), p
    },
    iterateStructs = (e, t, n, o, h) => {
        if (0 === o) return;
        const p = n + o;
        let f, g = findIndexCleanStart(e, t, n);
        do {
            f = t[g++], p < f.id.clock + f.length && findIndexCleanStart(e, t, p), h(f)
        } while (g < t.length && t[g].id.clock < p)
    };
class Transaction {
    constructor(e, t, n) {
        this.doc = e, this.deleteSet = new DeleteSet, this.beforeState = getStateVector(e.store), this.afterState = new Map, this.changed = new Map, this.changedParentTypes = new Map, this._mergeStructs = [], this.origin = t, this.meta = new Map, this.local = n, this.subdocsAdded = new Set, this.subdocsRemoved = new Set, this.subdocsLoaded = new Set, this._needFormattingCleanup = !1
    }
}
const writeUpdateMessageFromTransaction = (e, t) => !(0 === t.deleteSet.clients.size && !((e, t) => {
        for (const [n, o] of e)
            if (t(o, n)) return !0;
        return !1
    })(t.afterState, ((e, n) => t.beforeState.get(n) !== e))) && (sortAndMergeDeleteSet(t.deleteSet), ((e, t) => {
        writeClientsStructs(e, t.doc.store, t.beforeState)
    })(e, t), writeDeleteSet(e, t.deleteSet), !0),
    addChangedTypeToTransaction = (e, t, n) => {
        const o = t._item;
        (null === o || o.id.clock < (e.beforeState.get(o.id.client) || 0) && !o.deleted) && setIfUndefined(e.changed, t, create$4).add(n)
    },
    tryToMergeWithLefts = (e, t) => {
        let n = e[t],
            o = e[t - 1],
            h = t;
        for (; h > 0 && (o.deleted === n.deleted && o.constructor === n.constructor && o.mergeWith(n)); n = o, o = e[--h - 1]) n instanceof Item && null !== n.parentSub && n.parent._map.get(n.parentSub) === n && n.parent._map.set(n.parentSub, o);
        const p = t - h;
        return p && e.splice(t + 1 - p, p), p
    },
    tryGcDeleteSet = (e, t, n) => {
        for (const [o, h] of e.clients.entries()) {
            const e = t.clients.get(o);
            for (let o = h.length - 1; o >= 0; o--) {
                const p = h[o],
                    f = p.clock + p.len;
                for (let o = findIndexSS(e, p.clock), h = e[o]; o < e.length && h.id.clock < f; h = e[++o]) {
                    const h = e[o];
                    if (p.clock + p.len <= h.id.clock) break;
                    h instanceof Item && h.deleted && !h.keep && n(h) && h.gc(t, !1)
                }
            }
        }
    },
    tryMergeDeleteSet = (e, t) => {
        e.clients.forEach(((e, n) => {
            const o = t.clients.get(n);
            for (let t = e.length - 1; t >= 0; t--) {
                const n = e[t];
                for (let e = min(o.length - 1, 1 + findIndexSS(o, n.clock + n.len - 1)), t = o[e]; e > 0 && t.id.clock >= n.clock; t = o[e]) e -= 1 + tryToMergeWithLefts(o, e)
            }
        }))
    },
    cleanupTransactions = (e, t) => {
        if (t < e.length) {
            const n = e[t],
                o = n.doc,
                h = o.store,
                p = n.deleteSet,
                f = n._mergeStructs;
            try {
                sortAndMergeDeleteSet(p), n.afterState = getStateVector(n.doc.store), o.emit("beforeObserverCalls", [n, o]);
                const e = [];
                n.changed.forEach(((t, o) => e.push((() => {
                    null !== o._item && o._item.deleted || o._callObserver(n, t)
                })))), e.push((() => {
                    n.changedParentTypes.forEach(((e, t) => {
                        t._dEH.l.length > 0 && (null === t._item || !t._item.deleted) && ((e = e.filter((e => null === e.target._item || !e.target._item.deleted))).forEach((e => {
                            e.currentTarget = t, e._path = null
                        })), e.sort(((e, t) => e.path.length - t.path.length)), callEventHandlerListeners(t._dEH, e, n))
                    }))
                })), e.push((() => o.emit("afterTransaction", [n, o]))), callAll(e, []), n._needFormattingCleanup && cleanupYTextAfterTransaction(n)
            } finally {
                o.gc && tryGcDeleteSet(p, h, o.gcFilter), tryMergeDeleteSet(p, h), n.afterState.forEach(((e, t) => {
                    const o = n.beforeState.get(t) || 0;
                    if (o !== e) {
                        const e = h.clients.get(t),
                            n = max(findIndexSS(e, o), 1);
                        for (let t = e.length - 1; t >= n;) t -= 1 + tryToMergeWithLefts(e, t)
                    }
                }));
                for (let e = f.length - 1; e >= 0; e--) {
                    const {
                        client: t,
                        clock: n
                    } = f[e].id, o = h.clients.get(t), p = findIndexSS(o, n);
                    p + 1 < o.length && tryToMergeWithLefts(o, p + 1) > 1 || p > 0 && tryToMergeWithLefts(o, p)
                }
                if (n.local || n.afterState.get(o.clientID) === n.beforeState.get(o.clientID) || (print(vc, Oc, "[yjs] ", yc, xc, "Changed the client-id because another client seems to be using it."), o.clientID = $c()), o.emit("afterTransactionCleanup", [n, o]), o._observers.has("update")) {
                    const e = new UpdateEncoderV1;
                    writeUpdateMessageFromTransaction(e, n) && o.emit("update", [e.toUint8Array(), n.origin, o, n])
                }
                if (o._observers.has("updateV2")) {
                    const e = new UpdateEncoderV2;
                    writeUpdateMessageFromTransaction(e, n) && o.emit("updateV2", [e.toUint8Array(), n.origin, o, n])
                }
                const {
                    subdocsAdded: g,
                    subdocsLoaded: y,
                    subdocsRemoved: w
                } = n;
                (g.size > 0 || w.size > 0 || y.size > 0) && (g.forEach((e => {
                    e.clientID = o.clientID, null == e.collectionid && (e.collectionid = o.collectionid), o.subdocs.add(e)
                })), w.forEach((e => o.subdocs.delete(e))), o.emit("subdocs", [{
                    loaded: y,
                    added: g,
                    removed: w
                }, o, n]), w.forEach((e => e.destroy()))), e.length <= t + 1 ? (o._transactionCleanups = [], o.emit("afterAllTransactions", [o, e])) : cleanupTransactions(e, t + 1)
            }
        }
    },
    transact = (e, t, n = null, o = !0) => {
        const h = e._transactionCleanups;
        let p = !1,
            f = null;
        null === e._transaction && (p = !0, e._transaction = new Transaction(e, n, o), h.push(e._transaction), 1 === h.length && e.emit("beforeAllTransactions", [e]), e.emit("beforeTransaction", [e._transaction, e]));
        try {
            f = t(e._transaction)
        } finally {
            if (p) {
                const t = e._transaction === h[0];
                e._transaction = null, t && cleanupTransactions(h, 0)
            }
        }
        return f
    };
class StackItem {
    constructor(e, t) {
        this.insertions = t, this.deletions = e, this.meta = new Map
    }
}
const clearUndoManagerStackItem = (e, t, n) => {
        iterateDeletedStructs(e, n.deletions, (e => {
            e instanceof Item && t.scope.some((t => isParentOf(t, e))) && keepItem(e, !1)
        }))
    },
    popStackItem = (e, t, n) => {
        let o = null;
        const h = e.doc,
            p = e.scope;
        transact(h, (n => {
            for (; t.length > 0 && null === e.currStackItem;) {
                const o = h.store,
                    f = t.pop(),
                    g = new Set,
                    y = [];
                let w = !1;
                iterateDeletedStructs(n, f.insertions, (e => {
                    if (e instanceof Item) {
                        if (null !== e.redone) {
                            let {
                                item: t,
                                diff: h
                            } = followRedone(o, e.id);
                            h > 0 && (t = getItemCleanStart(n, createID(t.id.client, t.id.clock + h))), e = t
                        }!e.deleted && p.some((t => isParentOf(t, e))) && y.push(e)
                    }
                })), iterateDeletedStructs(n, f.deletions, (e => {
                    e instanceof Item && p.some((t => isParentOf(t, e))) && !isDeleted(f.insertions, e.id) && g.add(e)
                })), g.forEach((t => {
                    w = null !== redoItem(n, t, g, f.insertions, e.ignoreRemoteMapChanges, e) || w
                }));
                for (let t = y.length - 1; t >= 0; t--) {
                    const o = y[t];
                    e.deleteFilter(o) && (o.delete(n), w = !0)
                }
                e.currStackItem = w ? f : null
            }
            n.changed.forEach(((e, t) => {
                e.has(null) && t._searchMarker && (t._searchMarker.length = 0)
            })), o = n
        }), e);
        const f = e.currStackItem;
        if (null != f) {
            const t = o.changedParentTypes;
            e.emit("stack-item-popped", [{
                stackItem: f,
                type: n,
                changedParentTypes: t,
                origin: e
            }, e]), e.currStackItem = null
        }
        return f
    };
class LazyStructReader {
    constructor(e, t) {
        this.gen = function*(e) {
            const t = readVarUint(e.restDecoder);
            for (let n = 0; n < t; n++) {
                const t = readVarUint(e.restDecoder),
                    n = e.readClient();
                let o = readVarUint(e.restDecoder);
                for (let h = 0; h < t; h++) {
                    const t = e.readInfo();
                    if (10 === t) {
                        const t = readVarUint(e.restDecoder);
                        yield new Skip(createID(n, o), t), o += t
                    } else if (31 & t) {
                        const h = !(192 & t),
                            p = new Item(createID(n, o), null, (t & Ll) === Ll ? e.readLeftID() : null, null, (t & Dl) === Dl ? e.readRightID() : null, h ? e.readParentInfo() ? e.readString() : e.readLeftID() : null, !h || 32 & ~t ? null : e.readString(), readItemContent(e, t));
                        yield p, o += p.length
                    } else {
                        const t = e.readLen();
                        yield new GC(createID(n, o), t), o += t
                    }
                }
            }
        }(e), this.curr = null, this.done = !1, this.filterSkips = t, this.next()
    }
    next() {
        do {
            this.curr = this.gen.next().value || null
        } while (this.filterSkips && null !== this.curr && this.curr.constructor === Skip);
        return this.curr
    }
}
const logUpdateV2 = (e, t = UpdateDecoderV2) => {
        const n = [],
            o = new t(createDecoder(e)),
            h = new LazyStructReader(o, !1);
        for (let e = h.curr; null !== e; e = h.next()) n.push(e);
        print("Structs: ", n);
        const p = readDeleteSet(o);
        print("DeleteSet: ", p)
    },
    decodeUpdateV2 = (e, t = UpdateDecoderV2) => {
        const n = [],
            o = new t(createDecoder(e)),
            h = new LazyStructReader(o, !1);
        for (let e = h.curr; null !== e; e = h.next()) n.push(e);
        return {
            structs: n,
            ds: readDeleteSet(o)
        }
    };
class LazyStructWriter {
    constructor(e) {
        this.currClient = 0, this.startClock = 0, this.written = 0, this.encoder = e, this.clientStructs = []
    }
}
const mergeUpdates = e => mergeUpdatesV2(e, UpdateDecoderV1, UpdateEncoderV1),
    encodeStateVectorFromUpdateV2 = (e, t = DSEncoderV2, n = UpdateDecoderV2) => {
        const o = new t,
            h = new LazyStructReader(new n(createDecoder(e)), !1);
        let p = h.curr;
        if (null !== p) {
            let e = 0,
                t = p.id.client,
                n = 0 !== p.id.clock,
                f = n ? 0 : p.id.clock + p.length;
            for (; null !== p; p = h.next()) t !== p.id.client && (0 !== f && (e++, writeVarUint(o.restEncoder, t), writeVarUint(o.restEncoder, f)), t = p.id.client, f = 0, n = 0 !== p.id.clock), p.constructor === Skip && (n = !0), n || (f = p.id.clock + p.length);
            0 !== f && (e++, writeVarUint(o.restEncoder, t), writeVarUint(o.restEncoder, f));
            const g = createEncoder();
            return writeVarUint(g, e), ((e, t) => {
                writeUint8Array(e, toUint8Array(t))
            })(g, o.restEncoder), o.restEncoder = g, o.toUint8Array()
        }
        return writeVarUint(o.restEncoder, 0), o.toUint8Array()
    },
    parseUpdateMetaV2 = (e, t = UpdateDecoderV2) => {
        const n = new Map,
            o = new Map,
            h = new LazyStructReader(new t(createDecoder(e)), !1);
        let p = h.curr;
        if (null !== p) {
            let e = p.id.client,
                t = p.id.clock;
            for (n.set(e, t); null !== p; p = h.next()) e !== p.id.client && (o.set(e, t), n.set(p.id.client, p.id.clock), e = p.id.client), t = p.id.clock + p.length;
            o.set(e, t)
        }
        return {
            from: n,
            to: o
        }
    },
    sliceStruct = (e, t) => {
        if (e.constructor === GC) {
            const {
                client: n,
                clock: o
            } = e.id;
            return new GC(createID(n, o + t), e.length - t)
        }
        if (e.constructor === Skip) {
            const {
                client: n,
                clock: o
            } = e.id;
            return new Skip(createID(n, o + t), e.length - t)
        } {
            const n = e,
                {
                    client: o,
                    clock: h
                } = n.id;
            return new Item(createID(o, h + t), null, createID(o, h + t - 1), null, n.rightOrigin, n.parent, n.parentSub, n.content.splice(t))
        }
    },
    mergeUpdatesV2 = (e, t = UpdateDecoderV2, n = UpdateEncoderV2) => {
        if (1 === e.length) return e[0];
        const o = e.map((e => new t(createDecoder(e))));
        let h = o.map((e => new LazyStructReader(e, !0))),
            p = null;
        const f = new n,
            g = new LazyStructWriter(f);
        for (; h = h.filter((e => null !== e.curr)), h.sort(((e, t) => {
                if (e.curr.id.client === t.curr.id.client) {
                    const n = e.curr.id.clock - t.curr.id.clock;
                    return 0 === n ? e.curr.constructor === t.curr.constructor ? 0 : e.curr.constructor === Skip ? 1 : -1 : n
                }
                return t.curr.id.client - e.curr.id.client
            })), 0 !== h.length;) {
            const e = h[0],
                t = e.curr.id.client;
            if (null !== p) {
                let n = e.curr,
                    o = !1;
                for (; null !== n && n.id.clock + n.length <= p.struct.id.clock + p.struct.length && n.id.client >= p.struct.id.client;) n = e.next(), o = !0;
                if (null === n || n.id.client !== t || o && n.id.clock > p.struct.id.clock + p.struct.length) continue;
                if (t !== p.struct.id.client) writeStructToLazyStructWriter(g, p.struct, p.offset), p = {
                    struct: n,
                    offset: 0
                }, e.next();
                else if (p.struct.id.clock + p.struct.length < n.id.clock)
                    if (p.struct.constructor === Skip) p.struct.length = n.id.clock + n.length - p.struct.id.clock;
                    else {
                        writeStructToLazyStructWriter(g, p.struct, p.offset);
                        const e = n.id.clock - p.struct.id.clock - p.struct.length;
                        p = {
                            struct: new Skip(createID(t, p.struct.id.clock + p.struct.length), e),
                            offset: 0
                        }
                    }
                else {
                    const t = p.struct.id.clock + p.struct.length - n.id.clock;
                    t > 0 && (p.struct.constructor === Skip ? p.struct.length -= t : n = sliceStruct(n, t)), p.struct.mergeWith(n) || (writeStructToLazyStructWriter(g, p.struct, p.offset), p = {
                        struct: n,
                        offset: 0
                    }, e.next())
                }
            } else p = {
                struct: e.curr,
                offset: 0
            }, e.next();
            for (let n = e.curr; null !== n && n.id.client === t && n.id.clock === p.struct.id.clock + p.struct.length && n.constructor !== Skip; n = e.next()) writeStructToLazyStructWriter(g, p.struct, p.offset), p = {
                struct: n,
                offset: 0
            }
        }
        null !== p && (writeStructToLazyStructWriter(g, p.struct, p.offset), p = null), finishLazyStructWriting(g);
        const y = o.map((e => readDeleteSet(e))),
            w = mergeDeleteSets(y);
        return writeDeleteSet(f, w), f.toUint8Array()
    },
    diffUpdateV2 = (e, t, n = UpdateDecoderV2, o = UpdateEncoderV2) => {
        const h = decodeStateVector(t),
            p = new o,
            f = new LazyStructWriter(p),
            g = new n(createDecoder(e)),
            y = new LazyStructReader(g, !1);
        for (; y.curr;) {
            const e = y.curr,
                t = e.id.client,
                n = h.get(t) || 0;
            if (y.curr.constructor !== Skip)
                if (e.id.clock + e.length > n)
                    for (writeStructToLazyStructWriter(f, e, max(n - e.id.clock, 0)), y.next(); y.curr && y.curr.id.client === t;) writeStructToLazyStructWriter(f, y.curr, 0), y.next();
                else
                    for (; y.curr && y.curr.id.client === t && y.curr.id.clock + y.curr.length <= n;) y.next();
            else y.next()
        }
        finishLazyStructWriting(f);
        const w = readDeleteSet(g);
        return writeDeleteSet(p, w), p.toUint8Array()
    },
    flushLazyStructWriter = e => {
        e.written > 0 && (e.clientStructs.push({
            written: e.written,
            restEncoder: toUint8Array(e.encoder.restEncoder)
        }), e.encoder.restEncoder = createEncoder(), e.written = 0)
    },
    writeStructToLazyStructWriter = (e, t, n) => {
        e.written > 0 && e.currClient !== t.id.client && flushLazyStructWriter(e), 0 === e.written && (e.currClient = t.id.client, e.encoder.writeClient(t.id.client), writeVarUint(e.encoder.restEncoder, t.id.clock + n)), t.write(e.encoder, n), e.written++
    },
    finishLazyStructWriting = e => {
        flushLazyStructWriter(e);
        const t = e.encoder.restEncoder;
        writeVarUint(t, e.clientStructs.length);
        for (let n = 0; n < e.clientStructs.length; n++) {
            const o = e.clientStructs[n];
            writeVarUint(t, o.written), writeUint8Array(t, o.restEncoder)
        }
    },
    convertUpdateFormat = (e, t, n, o) => {
        const h = new n(createDecoder(e)),
            p = new LazyStructReader(h, !1),
            f = new o,
            g = new LazyStructWriter(f);
        for (let e = p.curr; null !== e; e = p.next()) writeStructToLazyStructWriter(g, t(e), 0);
        finishLazyStructWriting(g);
        const y = readDeleteSet(h);
        return writeDeleteSet(f, y), f.toUint8Array()
    },
    createObfuscator = ({
        formatting: e = !0,
        subdocs: t = !0,
        yxml: n = !0
    } = {}) => {
        let o = 0;
        const h = create$5(),
            p = create$5(),
            f = create$5(),
            g = create$5();
        return g.set(null, null), y => {
            switch (y.constructor) {
                case GC:
                case Skip:
                    return y;
                case Item:
                    {
                        const w = y,
                            b = w.content;
                        switch (b.constructor) {
                            case ContentDeleted:
                                break;
                            case ContentType:
                                if (n) {
                                    const e = b.type;
                                    e instanceof YXmlElement && (e.nodeName = setIfUndefined(p, e.nodeName, (() => "node-" + o))), e instanceof YXmlHook && (e.hookName = setIfUndefined(p, e.hookName, (() => "hook-" + o)))
                                }
                                break;
                            case ContentAny:
                                {
                                    const e = b;e.arr = e.arr.map((() => o));
                                    break
                                }
                            case ContentBinary:
                                b.content = new Uint8Array([o]);
                                break;
                            case ContentDoc:
                                {
                                    const e = b;t && (e.opts = {}, e.doc.guid = o + "");
                                    break
                                }
                            case ContentEmbed:
                                b.embed = {};
                                break;
                            case ContentFormat:
                                {
                                    const t = b;e && (t.key = setIfUndefined(f, t.key, (() => o + "")), t.value = setIfUndefined(g, t.value, (() => ({
                                        i: o
                                    }))));
                                    break
                                }
                            case ContentJSON:
                                {
                                    const e = b;e.arr = e.arr.map((() => o));
                                    break
                                }
                            case ContentString:
                                {
                                    const e = b;e.str = repeat(o % 10 + "", e.str.length);
                                    break
                                }
                            default:
                                unexpectedCase()
                        }
                        return w.parentSub && (w.parentSub = setIfUndefined(h, w.parentSub, (() => o + ""))),
                        o++,
                        y
                    }
                default:
                    unexpectedCase()
            }
        }
    },
    convertUpdateFormatV2ToV1 = e => convertUpdateFormat(e, id, UpdateDecoderV2, UpdateEncoderV1),
    Ac = "You must not compute changes after the event-handler fired.";
class YEvent {
    constructor(e, t) {
        this.target = e, this.currentTarget = e, this.transaction = t, this._changes = null, this._keys = null, this._delta = null, this._path = null
    }
    get path() {
        return this._path || (this._path = getPathTo(this.currentTarget, this.target))
    }
    deletes(e) {
        return isDeleted(this.transaction.deleteSet, e.id)
    }
    get keys() {
        if (null === this._keys) {
            if (0 === this.transaction.doc._transactionCleanups.length) throw create$3(Ac);
            const e = new Map,
                t = this.target;
            this.transaction.changed.get(t).forEach((n => {
                if (null !== n) {
                    const o = t._map.get(n);
                    let h, p;
                    if (this.adds(o)) {
                        let e = o.left;
                        for (; null !== e && this.adds(e);) e = e.left;
                        if (this.deletes(o)) {
                            if (null === e || !this.deletes(e)) return;
                            h = "delete", p = last(e.content.getContent())
                        } else null !== e && this.deletes(e) ? (h = "update", p = last(e.content.getContent())) : (h = "add", p = void 0)
                    } else {
                        if (!this.deletes(o)) return;
                        h = "delete", p = last(o.content.getContent())
                    }
                    e.set(n, {
                        action: h,
                        oldValue: p
                    })
                }
            })), this._keys = e
        }
        return this._keys
    }
    get delta() {
        return this.changes.delta
    }
    adds(e) {
        return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0)
    }
    get changes() {
        let e = this._changes;
        if (null === e) {
            if (0 === this.transaction.doc._transactionCleanups.length) throw create$3(Ac);
            const t = this.target,
                n = create$4(),
                o = create$4(),
                h = [];
            e = {
                added: n,
                deleted: o,
                delta: h,
                keys: this.keys
            };
            if (this.transaction.changed.get(t).has(null)) {
                let e = null;
                const packOp = () => {
                    e && h.push(e)
                };
                for (let h = t._start; null !== h; h = h.right) h.deleted ? this.deletes(h) && !this.adds(h) && (null !== e && void 0 !== e.delete || (packOp(), e = {
                    delete: 0
                }), e.delete += h.length, o.add(h)) : this.adds(h) ? (null !== e && void 0 !== e.insert || (packOp(), e = {
                    insert: []
                }), e.insert = e.insert.concat(h.content.getContent()), n.add(h)) : (null !== e && void 0 !== e.retain || (packOp(), e = {
                    retain: 0
                }), e.retain += h.length);
                null !== e && void 0 === e.retain && packOp()
            }
            this._changes = e
        }
        return e
    }
}
const getPathTo = (e, t) => {
        const n = [];
        for (; null !== t._item && t !== e;) {
            if (null !== t._item.parentSub) n.unshift(t._item.parentSub);
            else {
                let e = 0,
                    o = t._item.parent._start;
                for (; o !== t._item && null !== o;) !o.deleted && o.countable && (e += o.length), o = o.right;
                n.unshift(e)
            }
            t = t._item.parent
        }
        return n
    },
    warnPrematureAccess = () => {
        warn("Invalid access: Add Yjs type to a document before reading data.")
    };
let Mc = 0;
class ArraySearchMarker {
    constructor(e, t) {
        e.marker = !0, this.p = e, this.index = t, this.timestamp = Mc++
    }
}
const overwriteMarker = (e, t, n) => {
        e.p.marker = !1, e.p = t, t.marker = !0, e.index = n, e.timestamp = Mc++
    },
    findMarker = (e, t) => {
        if (null === e._start || 0 === t || null === e._searchMarker) return null;
        const n = 0 === e._searchMarker.length ? null : e._searchMarker.reduce(((e, n) => Ml(t - e.index) < Ml(t - n.index) ? e : n));
        let o = e._start,
            h = 0;
        for (null !== n && (o = n.p, h = n.index, (e => {
                e.timestamp = Mc++
            })(n)); null !== o.right && h < t;) {
            if (!o.deleted && o.countable) {
                if (t < h + o.length) break;
                h += o.length
            }
            o = o.right
        }
        for (; null !== o.left && h > t;) o = o.left, !o.deleted && o.countable && (h -= o.length);
        for (; null !== o.left && o.left.id.client === o.id.client && o.left.id.clock + o.left.length === o.id.clock;) o = o.left, !o.deleted && o.countable && (h -= o.length);
        return null !== n && Ml(n.index - h) < o.parent.length / 80 ? (overwriteMarker(n, o, h), n) : ((e, t, n) => {
            if (e.length >= 80) {
                const o = e.reduce(((e, t) => e.timestamp < t.timestamp ? e : t));
                return overwriteMarker(o, t, n), o
            } {
                const o = new ArraySearchMarker(t, n);
                return e.push(o), o
            }
        })(e._searchMarker, o, h)
    },
    updateMarkerChanges = (e, t, n) => {
        for (let o = e.length - 1; o >= 0; o--) {
            const h = e[o];
            if (n > 0) {
                let t = h.p;
                for (t.marker = !1; t && (t.deleted || !t.countable);) t = t.left, t && !t.deleted && t.countable && (h.index -= t.length);
                if (null === t || !0 === t.marker) {
                    e.splice(o, 1);
                    continue
                }
                h.p = t, t.marker = !0
            }(t < h.index || n > 0 && t === h.index) && (h.index = max(t, h.index + n))
        }
    },
    callTypeObservers = (e, t, n) => {
        const o = e,
            h = t.changedParentTypes;
        for (; setIfUndefined(h, e, (() => [])).push(n), null !== e._item;) e = e._item.parent;
        callEventHandlerListeners(o._eH, n, t)
    };
class AbstractType {
    constructor() {
        this._item = null, this._map = new Map, this._start = null, this.doc = null, this._length = 0, this._eH = createEventHandler(), this._dEH = createEventHandler(), this._searchMarker = null
    }
    get parent() {
        return this._item ? this._item.parent : null
    }
    _integrate(e, t) {
        this.doc = e, this._item = t
    }
    _copy() {
        throw methodUnimplemented()
    }
    clone() {
        throw methodUnimplemented()
    }
    _write(e) {}
    get _first() {
        let e = this._start;
        for (; null !== e && e.deleted;) e = e.right;
        return e
    }
    _callObserver(e, t) {
        !e.local && this._searchMarker && (this._searchMarker.length = 0)
    }
    observe(e) {
        addEventHandlerListener(this._eH, e)
    }
    observeDeep(e) {
        addEventHandlerListener(this._dEH, e)
    }
    unobserve(e) {
        removeEventHandlerListener(this._eH, e)
    }
    unobserveDeep(e) {
        removeEventHandlerListener(this._dEH, e)
    }
    toJSON() {}
}
const typeListSlice = (e, t, n) => {
        e.doc ? ? warnPrematureAccess(), t < 0 && (t = e._length + t), n < 0 && (n = e._length + n);
        let o = n - t;
        const h = [];
        let p = e._start;
        for (; null !== p && o > 0;) {
            if (p.countable && !p.deleted) {
                const e = p.content.getContent();
                if (e.length <= t) t -= e.length;
                else {
                    for (let n = t; n < e.length && o > 0; n++) h.push(e[n]), o--;
                    t = 0
                }
            }
            p = p.right
        }
        return h
    },
    typeListToArray = e => {
        e.doc ? ? warnPrematureAccess();
        const t = [];
        let n = e._start;
        for (; null !== n;) {
            if (n.countable && !n.deleted) {
                const e = n.content.getContent();
                for (let n = 0; n < e.length; n++) t.push(e[n])
            }
            n = n.right
        }
        return t
    },
    typeListForEach = (e, t) => {
        let n = 0,
            o = e._start;
        for (e.doc ? ? warnPrematureAccess(); null !== o;) {
            if (o.countable && !o.deleted) {
                const h = o.content.getContent();
                for (let o = 0; o < h.length; o++) t(h[o], n++, e)
            }
            o = o.right
        }
    },
    typeListMap = (e, t) => {
        const n = [];
        return typeListForEach(e, ((o, h) => {
            n.push(t(o, h, e))
        })), n
    },
    typeListCreateIterator = e => {
        let t = e._start,
            n = null,
            o = 0;
        return {
            [Symbol.iterator]() {
                return this
            },
            next: () => {
                if (null === n) {
                    for (; null !== t && t.deleted;) t = t.right;
                    if (null === t) return {
                        done: !0,
                        value: void 0
                    };
                    n = t.content.getContent(), o = 0, t = t.right
                }
                const e = n[o++];
                return n.length <= o && (n = null), {
                    done: !1,
                    value: e
                }
            }
        }
    },
    typeListGet = (e, t) => {
        e.doc ? ? warnPrematureAccess();
        const n = findMarker(e, t);
        let o = e._start;
        for (null !== n && (o = n.p, t -= n.index); null !== o; o = o.right)
            if (!o.deleted && o.countable) {
                if (t < o.length) return o.content.getContent()[t];
                t -= o.length
            }
    },
    typeListInsertGenericsAfter = (e, t, n, o) => {
        let h = n;
        const p = e.doc,
            f = p.clientID,
            g = p.store,
            y = null === n ? t._start : n.right;
        let w = [];
        const packJsonContent = () => {
            w.length > 0 && (h = new Item(createID(f, getState(g, f)), h, h && h.lastId, y, y && y.id, t, null, new ContentAny(w)), h.integrate(e, 0), w = [])
        };
        o.forEach((n => {
            if (null === n) w.push(n);
            else switch (n.constructor) {
                case Number:
                case Object:
                case Boolean:
                case Array:
                case String:
                    w.push(n);
                    break;
                default:
                    switch (packJsonContent(), n.constructor) {
                        case Uint8Array:
                        case ArrayBuffer:
                            h = new Item(createID(f, getState(g, f)), h, h && h.lastId, y, y && y.id, t, null, new ContentBinary(new Uint8Array(n))), h.integrate(e, 0);
                            break;
                        case Doc:
                            h = new Item(createID(f, getState(g, f)), h, h && h.lastId, y, y && y.id, t, null, new ContentDoc(n)), h.integrate(e, 0);
                            break;
                        default:
                            if (!(n instanceof AbstractType)) throw new Error("Unexpected content type in insert operation");
                            h = new Item(createID(f, getState(g, f)), h, h && h.lastId, y, y && y.id, t, null, new ContentType(n)), h.integrate(e, 0)
                    }
            }
        })), packJsonContent()
    },
    lengthExceeded = () => create$3("Length exceeded!"),
    typeListInsertGenerics = (e, t, n, o) => {
        if (n > t._length) throw lengthExceeded();
        if (0 === n) return t._searchMarker && updateMarkerChanges(t._searchMarker, n, o.length), typeListInsertGenericsAfter(e, t, null, o);
        const h = n,
            p = findMarker(t, n);
        let f = t._start;
        for (null !== p && (f = p.p, 0 === (n -= p.index) && (f = f.prev, n += f && f.countable && !f.deleted ? f.length : 0)); null !== f; f = f.right)
            if (!f.deleted && f.countable) {
                if (n <= f.length) {
                    n < f.length && getItemCleanStart(e, createID(f.id.client, f.id.clock + n));
                    break
                }
                n -= f.length
            }
        return t._searchMarker && updateMarkerChanges(t._searchMarker, h, o.length), typeListInsertGenericsAfter(e, t, f, o)
    },
    typeListDelete = (e, t, n, o) => {
        if (0 === o) return;
        const h = n,
            p = o,
            f = findMarker(t, n);
        let g = t._start;
        for (null !== f && (g = f.p, n -= f.index); null !== g && n > 0; g = g.right) !g.deleted && g.countable && (n < g.length && getItemCleanStart(e, createID(g.id.client, g.id.clock + n)), n -= g.length);
        for (; o > 0 && null !== g;) g.deleted || (o < g.length && getItemCleanStart(e, createID(g.id.client, g.id.clock + o)), g.delete(e), o -= g.length), g = g.right;
        if (o > 0) throw lengthExceeded();
        t._searchMarker && updateMarkerChanges(t._searchMarker, h, -p + o)
    },
    typeMapDelete = (e, t, n) => {
        const o = t._map.get(n);
        void 0 !== o && o.delete(e)
    },
    typeMapSet = (e, t, n, o) => {
        const h = t._map.get(n) || null,
            p = e.doc,
            f = p.clientID;
        let g;
        if (null == o) g = new ContentAny([o]);
        else switch (o.constructor) {
            case Number:
            case Object:
            case Boolean:
            case Array:
            case String:
                g = new ContentAny([o]);
                break;
            case Uint8Array:
                g = new ContentBinary(o);
                break;
            case Doc:
                g = new ContentDoc(o);
                break;
            default:
                if (!(o instanceof AbstractType)) throw new Error("Unexpected content type");
                g = new ContentType(o)
        }
        new Item(createID(f, getState(p.store, f)), h, h && h.lastId, null, null, t, n, g).integrate(e, 0)
    },
    typeMapGet = (e, t) => {
        e.doc ? ? warnPrematureAccess();
        const n = e._map.get(t);
        return void 0 === n || n.deleted ? void 0 : n.content.getContent()[n.length - 1]
    },
    typeMapGetAll = e => {
        const t = {};
        return e.doc ? ? warnPrematureAccess(), e._map.forEach(((e, n) => {
            e.deleted || (t[n] = e.content.getContent()[e.length - 1])
        })), t
    },
    typeMapHas = (e, t) => {
        e.doc ? ? warnPrematureAccess();
        const n = e._map.get(t);
        return void 0 !== n && !n.deleted
    },
    typeMapGetAllSnapshot = (e, t) => {
        const n = {};
        return e._map.forEach(((e, o) => {
            let h = e;
            for (; null !== h && (!t.sv.has(h.id.client) || h.id.clock >= (t.sv.get(h.id.client) || 0));) h = h.left;
            null !== h && isVisible(h, t) && (n[o] = h.content.getContent()[h.length - 1])
        })), n
    },
    createMapIterator = e => {
        return e.doc ? ? warnPrematureAccess(), t = e._map.entries(), n = e => !e[1].deleted, createIterator((() => {
            let e;
            do {
                e = t.next()
            } while (!e.done && !n(e.value));
            return e
        }));
        var t, n
    };
class YArrayEvent extends YEvent {}
class YArray extends AbstractType {
    constructor() {
        super(), this._prelimContent = [], this._searchMarker = []
    }
    static from(e) {
        const t = new YArray;
        return t.push(e), t
    }
    _integrate(e, t) {
        super._integrate(e, t), this.insert(0, this._prelimContent), this._prelimContent = null
    }
    _copy() {
        return new YArray
    }
    clone() {
        const e = new YArray;
        return e.insert(0, this.toArray().map((e => e instanceof AbstractType ? e.clone() : e))), e
    }
    get length() {
        return this.doc ? ? warnPrematureAccess(), this._length
    }
    _callObserver(e, t) {
        super._callObserver(e, t), callTypeObservers(this, e, new YArrayEvent(this, e))
    }
    insert(e, t) {
        null !== this.doc ? transact(this.doc, (n => {
            typeListInsertGenerics(n, this, e, t)
        })) : this._prelimContent.splice(e, 0, ...t)
    }
    push(e) {
        null !== this.doc ? transact(this.doc, (t => {
            ((e, t, n) => {
                let o = (t._searchMarker || []).reduce(((e, t) => t.index > e.index ? t : e), {
                    index: 0,
                    p: t._start
                }).p;
                if (o)
                    for (; o.right;) o = o.right;
                typeListInsertGenericsAfter(e, t, o, n)
            })(t, this, e)
        })) : this._prelimContent.push(...e)
    }
    unshift(e) {
        this.insert(0, e)
    }
    delete(e, t = 1) {
        null !== this.doc ? transact(this.doc, (n => {
            typeListDelete(n, this, e, t)
        })) : this._prelimContent.splice(e, t)
    }
    get(e) {
        return typeListGet(this, e)
    }
    toArray() {
        return typeListToArray(this)
    }
    slice(e = 0, t = this.length) {
        return typeListSlice(this, e, t)
    }
    toJSON() {
        return this.map((e => e instanceof AbstractType ? e.toJSON() : e))
    }
    map(e) {
        return typeListMap(this, e)
    }
    forEach(e) {
        typeListForEach(this, e)
    }[Symbol.iterator]() {
        return typeListCreateIterator(this)
    }
    _write(e) {
        e.writeTypeRef(Lc)
    }
}
class YMapEvent extends YEvent {
    constructor(e, t, n) {
        super(e, t), this.keysChanged = n
    }
}
class YMap extends AbstractType {
    constructor(e) {
        super(), this._prelimContent = null, this._prelimContent = void 0 === e ? new Map : new Map(e)
    }
    _integrate(e, t) {
        super._integrate(e, t), this._prelimContent.forEach(((e, t) => {
            this.set(t, e)
        })), this._prelimContent = null
    }
    _copy() {
        return new YMap
    }
    clone() {
        const e = new YMap;
        return this.forEach(((t, n) => {
            e.set(n, t instanceof AbstractType ? t.clone() : t)
        })), e
    }
    _callObserver(e, t) {
        callTypeObservers(this, e, new YMapEvent(this, e, t))
    }
    toJSON() {
        this.doc ? ? warnPrematureAccess();
        const e = {};
        return this._map.forEach(((t, n) => {
            if (!t.deleted) {
                const o = t.content.getContent()[t.length - 1];
                e[n] = o instanceof AbstractType ? o.toJSON() : o
            }
        })), e
    }
    get size() {
        return [...createMapIterator(this)].length
    }
    keys() {
        return iteratorMap(createMapIterator(this), (e => e[0]))
    }
    values() {
        return iteratorMap(createMapIterator(this), (e => e[1].content.getContent()[e[1].length - 1]))
    }
    entries() {
        return iteratorMap(createMapIterator(this), (e => [e[0], e[1].content.getContent()[e[1].length - 1]]))
    }
    forEach(e) {
        this.doc ? ? warnPrematureAccess(), this._map.forEach(((t, n) => {
            t.deleted || e(t.content.getContent()[t.length - 1], n, this)
        }))
    }[Symbol.iterator]() {
        return this.entries()
    }
    delete(e) {
        null !== this.doc ? transact(this.doc, (t => {
            typeMapDelete(t, this, e)
        })) : this._prelimContent.delete(e)
    }
    set(e, t) {
        return null !== this.doc ? transact(this.doc, (n => {
            typeMapSet(n, this, e, t)
        })) : this._prelimContent.set(e, t), t
    }
    get(e) {
        return typeMapGet(this, e)
    }
    has(e) {
        return typeMapHas(this, e)
    }
    clear() {
        null !== this.doc ? transact(this.doc, (e => {
            this.forEach((function(t, n, o) {
                typeMapDelete(e, o, n)
            }))
        })) : this._prelimContent.clear()
    }
    _write(e) {
        e.writeTypeRef(Vc)
    }
}
const equalAttrs = (e, t) => e === t || "object" == typeof e && "object" == typeof t && e && t && ((e, t) => e === t || size(e) === size(t) && ((e, t) => {
    for (const n in e)
        if (!t(e[n], n)) return !1;
    return !0
})(e, ((e, n) => (void 0 !== e || hasProperty(t, n)) && t[n] === e)))(e, t);
class ItemTextListPosition {
    constructor(e, t, n, o) {
        this.left = e, this.right = t, this.index = n, this.currentAttributes = o
    }
    forward() {
        if (null === this.right && unexpectedCase(), this.right.content.constructor === ContentFormat) this.right.deleted || updateCurrentAttributes(this.currentAttributes, this.right.content);
        else this.right.deleted || (this.index += this.right.length);
        this.left = this.right, this.right = this.right.right
    }
}
const findNextPosition = (e, t, n) => {
        for (; null !== t.right && n > 0;) {
            if (t.right.content.constructor === ContentFormat) t.right.deleted || updateCurrentAttributes(t.currentAttributes, t.right.content);
            else t.right.deleted || (n < t.right.length && getItemCleanStart(e, createID(t.right.id.client, t.right.id.clock + n)), t.index += t.right.length, n -= t.right.length);
            t.left = t.right, t.right = t.right.right
        }
        return t
    },
    findPosition = (e, t, n, o) => {
        const h = new Map,
            p = o ? findMarker(t, n) : null;
        if (p) {
            const t = new ItemTextListPosition(p.p.left, p.p, p.index, h);
            return findNextPosition(e, t, n - p.index)
        } {
            const o = new ItemTextListPosition(null, t._start, 0, h);
            return findNextPosition(e, o, n)
        }
    },
    insertNegatedAttributes = (e, t, n, o) => {
        for (; null !== n.right && (!0 === n.right.deleted || n.right.content.constructor === ContentFormat && equalAttrs(o.get(n.right.content.key), n.right.content.value));) n.right.deleted || o.delete(n.right.content.key), n.forward();
        const h = e.doc,
            p = h.clientID;
        o.forEach(((o, f) => {
            const g = n.left,
                y = n.right,
                w = new Item(createID(p, getState(h.store, p)), g, g && g.lastId, y, y && y.id, t, null, new ContentFormat(f, o));
            w.integrate(e, 0), n.right = w, n.forward()
        }))
    },
    updateCurrentAttributes = (e, t) => {
        const {
            key: n,
            value: o
        } = t;
        null === o ? e.delete(n) : e.set(n, o)
    },
    minimizeAttributeChanges = (e, t) => {
        for (; null !== e.right && (e.right.deleted || e.right.content.constructor === ContentFormat && equalAttrs(t[e.right.content.key] ? ? null, e.right.content.value));) e.forward()
    },
    insertAttributes = (e, t, n, o) => {
        const h = e.doc,
            p = h.clientID,
            f = new Map;
        for (const g in o) {
            const y = o[g],
                w = n.currentAttributes.get(g) ? ? null;
            if (!equalAttrs(w, y)) {
                f.set(g, w);
                const {
                    left: o,
                    right: b
                } = n;
                n.right = new Item(createID(p, getState(h.store, p)), o, o && o.lastId, b, b && b.id, t, null, new ContentFormat(g, y)), n.right.integrate(e, 0), n.forward()
            }
        }
        return f
    },
    insertText = (e, t, n, o, h) => {
        n.currentAttributes.forEach(((e, t) => {
            void 0 === h[t] && (h[t] = null)
        }));
        const p = e.doc,
            f = p.clientID;
        minimizeAttributeChanges(n, h);
        const g = insertAttributes(e, t, n, h),
            y = o.constructor === String ? new ContentString(o) : o instanceof AbstractType ? new ContentType(o) : new ContentEmbed(o);
        let {
            left: w,
            right: b,
            index: S
        } = n;
        t._searchMarker && updateMarkerChanges(t._searchMarker, n.index, y.getLength()), b = new Item(createID(f, getState(p.store, f)), w, w && w.lastId, b, b && b.id, t, null, y), b.integrate(e, 0), n.right = b, n.index = S, n.forward(), insertNegatedAttributes(e, t, n, g)
    },
    formatText = (e, t, n, o, h) => {
        const p = e.doc,
            f = p.clientID;
        minimizeAttributeChanges(n, h);
        const g = insertAttributes(e, t, n, h);
        e: for (; null !== n.right && (o > 0 || g.size > 0 && (n.right.deleted || n.right.content.constructor === ContentFormat));) {
            if (!n.right.deleted) switch (n.right.content.constructor) {
                case ContentFormat:
                    {
                        const {
                            key: t,
                            value: p
                        } = n.right.content,
                        f = h[t];
                        if (void 0 !== f) {
                            if (equalAttrs(f, p)) g.delete(t);
                            else {
                                if (0 === o) break e;
                                g.set(t, p)
                            }
                            n.right.delete(e)
                        } else n.currentAttributes.set(t, p);
                        break
                    }
                default:
                    o < n.right.length && getItemCleanStart(e, createID(n.right.id.client, n.right.id.clock + o)), o -= n.right.length
            }
            n.forward()
        }
        if (o > 0) {
            let h = "";
            for (; o > 0; o--) h += "\n";
            n.right = new Item(createID(f, getState(p.store, f)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, t, null, new ContentString(h)), n.right.integrate(e, 0), n.forward()
        }
        insertNegatedAttributes(e, t, n, g)
    },
    cleanupFormattingGap = (e, t, n, o, h) => {
        let p = t;
        const f = create$5();
        for (; p && (!p.countable || p.deleted);) {
            if (!p.deleted && p.content.constructor === ContentFormat) {
                const e = p.content;
                f.set(e.key, e)
            }
            p = p.right
        }
        let g = 0,
            y = !1;
        for (; t !== p;) {
            if (n === t && (y = !0), !t.deleted) {
                const n = t.content;
                switch (n.constructor) {
                    case ContentFormat:
                        {
                            const {
                                key: p,
                                value: w
                            } = n,
                            b = o.get(p) ? ? null;f.get(p) === n && b !== w || (t.delete(e), g++, y || (h.get(p) ? ? null) !== w || b === w || (null === b ? h.delete(p) : h.set(p, b))),
                            y || t.deleted || updateCurrentAttributes(h, n);
                            break
                        }
                }
            }
            t = t.right
        }
        return g
    },
    cleanupYTextFormatting = e => {
        let t = 0;
        return transact(e.doc, (n => {
            let o = e._start,
                h = e._start,
                p = create$5();
            const f = copy(p);
            for (; h;) {
                if (!1 === h.deleted)
                    if (h.content.constructor === ContentFormat) updateCurrentAttributes(f, h.content);
                    else t += cleanupFormattingGap(n, o, h, p, f), p = copy(f), o = h;
                h = h.right
            }
        })), t
    },
    cleanupYTextAfterTransaction = e => {
        const t = new Set,
            n = e.doc;
        for (const [o, h] of e.afterState.entries()) {
            const p = e.beforeState.get(o) || 0;
            h !== p && iterateStructs(e, n.store.clients.get(o), p, h, (e => {
                e.deleted || e.content.constructor !== ContentFormat || e.constructor === GC || t.add(e.parent)
            }))
        }
        transact(n, (n => {
            iterateDeletedStructs(e, e.deleteSet, (e => {
                if (e instanceof GC || !e.parent._hasFormatting || t.has(e.parent)) return;
                const o = e.parent;
                e.content.constructor === ContentFormat ? t.add(o) : ((e, t) => {
                    for (; t && t.right && (t.right.deleted || !t.right.countable);) t = t.right;
                    const n = new Set;
                    for (; t && (t.deleted || !t.countable);) {
                        if (!t.deleted && t.content.constructor === ContentFormat) {
                            const o = t.content.key;
                            n.has(o) ? t.delete(e) : n.add(o)
                        }
                        t = t.left
                    }
                })(n, e)
            }));
            for (const e of t) cleanupYTextFormatting(e)
        }))
    },
    deleteText = (e, t, n) => {
        const o = n,
            h = copy(t.currentAttributes),
            p = t.right;
        for (; n > 0 && null !== t.right;) {
            if (!1 === t.right.deleted) switch (t.right.content.constructor) {
                case ContentType:
                case ContentEmbed:
                case ContentString:
                    n < t.right.length && getItemCleanStart(e, createID(t.right.id.client, t.right.id.clock + n)), n -= t.right.length, t.right.delete(e)
            }
            t.forward()
        }
        p && cleanupFormattingGap(e, p, t.right, h, t.currentAttributes);
        const f = (t.left || t.right).parent;
        return f._searchMarker && updateMarkerChanges(f._searchMarker, t.index, -o + n), t
    };
class YTextEvent extends YEvent {
    constructor(e, t, n) {
        super(e, t), this.childListChanged = !1, this.keysChanged = new Set, n.forEach((e => {
            null === e ? this.childListChanged = !0 : this.keysChanged.add(e)
        }))
    }
    get changes() {
        if (null === this._changes) {
            const e = {
                keys: this.keys,
                delta: this.delta,
                added: new Set,
                deleted: new Set
            };
            this._changes = e
        }
        return this._changes
    }
    get delta() {
        if (null === this._delta) {
            const e = this.target.doc,
                t = [];
            transact(e, (e => {
                const n = new Map,
                    o = new Map;
                let h = this.target._start,
                    p = null;
                const f = {};
                let g = "",
                    y = 0,
                    w = 0;
                const addOp = () => {
                    if (null !== p) {
                        let e = null;
                        switch (p) {
                            case "delete":
                                w > 0 && (e = {
                                    delete: w
                                }), w = 0;
                                break;
                            case "insert":
                                ("object" == typeof g || g.length > 0) && (e = {
                                    insert: g
                                }, n.size > 0 && (e.attributes = {}, n.forEach(((t, n) => {
                                    null !== t && (e.attributes[n] = t)
                                })))), g = "";
                                break;
                            case "retain":
                                y > 0 && (e = {
                                    retain: y
                                }, (e => {
                                    for (const t in e) return !1;
                                    return !0
                                })(f) || (e.attributes = sc({}, f))), y = 0
                        }
                        e && t.push(e), p = null
                    }
                };
                for (; null !== h;) {
                    switch (h.content.constructor) {
                        case ContentType:
                        case ContentEmbed:
                            this.adds(h) ? this.deletes(h) || (addOp(), p = "insert", g = h.content.getContent()[0], addOp()) : this.deletes(h) ? ("delete" !== p && (addOp(), p = "delete"), w += 1) : h.deleted || ("retain" !== p && (addOp(), p = "retain"), y += 1);
                            break;
                        case ContentString:
                            this.adds(h) ? this.deletes(h) || ("insert" !== p && (addOp(), p = "insert"), g += h.content.str) : this.deletes(h) ? ("delete" !== p && (addOp(), p = "delete"), w += h.length) : h.deleted || ("retain" !== p && (addOp(), p = "retain"), y += h.length);
                            break;
                        case ContentFormat:
                            {
                                const {
                                    key: t,
                                    value: g
                                } = h.content;
                                if (this.adds(h)) {
                                    if (!this.deletes(h)) {
                                        const y = n.get(t) ? ? null;
                                        equalAttrs(y, g) ? null !== g && h.delete(e) : ("retain" === p && addOp(), equalAttrs(g, o.get(t) ? ? null) ? delete f[t] : f[t] = g)
                                    }
                                } else if (this.deletes(h)) {
                                    o.set(t, g);
                                    const e = n.get(t) ? ? null;
                                    equalAttrs(e, g) || ("retain" === p && addOp(), f[t] = e)
                                } else if (!h.deleted) {
                                    o.set(t, g);
                                    const n = f[t];
                                    void 0 !== n && (equalAttrs(n, g) ? null !== n && h.delete(e) : ("retain" === p && addOp(), null === g ? delete f[t] : f[t] = g))
                                }
                                h.deleted || ("insert" === p && addOp(), updateCurrentAttributes(n, h.content));
                                break
                            }
                    }
                    h = h.right
                }
                for (addOp(); t.length > 0;) {
                    const e = t[t.length - 1];
                    if (void 0 === e.retain || void 0 !== e.attributes) break;
                    t.pop()
                }
            })), this._delta = t
        }
        return this._delta
    }
}
class YText extends AbstractType {
    constructor(e) {
        super(), this._pending = void 0 !== e ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1
    }
    get length() {
        return this.doc ? ? warnPrematureAccess(), this._length
    }
    _integrate(e, t) {
        super._integrate(e, t);
        try {
            this._pending.forEach((e => e()))
        } catch (e) {
            console.error(e)
        }
        this._pending = null
    }
    _copy() {
        return new YText
    }
    clone() {
        const e = new YText;
        return e.applyDelta(this.toDelta()), e
    }
    _callObserver(e, t) {
        super._callObserver(e, t);
        const n = new YTextEvent(this, e, t);
        callTypeObservers(this, e, n), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0)
    }
    toString() {
        this.doc ? ? warnPrematureAccess();
        let e = "",
            t = this._start;
        for (; null !== t;) !t.deleted && t.countable && t.content.constructor === ContentString && (e += t.content.str), t = t.right;
        return e
    }
    toJSON() {
        return this.toString()
    }
    applyDelta(e, {
        sanitize: t = !0
    } = {}) {
        null !== this.doc ? transact(this.doc, (n => {
            const o = new ItemTextListPosition(null, this._start, 0, new Map);
            for (let h = 0; h < e.length; h++) {
                const p = e[h];
                if (void 0 !== p.insert) {
                    const f = t || "string" != typeof p.insert || h !== e.length - 1 || null !== o.right || "\n" !== p.insert.slice(-1) ? p.insert : p.insert.slice(0, -1);
                    ("string" != typeof f || f.length > 0) && insertText(n, this, o, f, p.attributes || {})
                } else void 0 !== p.retain ? formatText(n, this, o, p.retain, p.attributes || {}) : void 0 !== p.delete && deleteText(n, o, p.delete)
            }
        })) : this._pending.push((() => this.applyDelta(e)))
    }
    toDelta(e, t, n) {
        this.doc ? ? warnPrematureAccess();
        const o = [],
            h = new Map,
            p = this.doc;
        let f = "",
            g = this._start;

        function packStr() {
            if (f.length > 0) {
                const e = {};
                let t = !1;
                h.forEach(((n, o) => {
                    t = !0, e[o] = n
                }));
                const n = {
                    insert: f
                };
                t && (n.attributes = e), o.push(n), f = ""
            }
        }
        const computeDelta = () => {
            for (; null !== g;) {
                if (isVisible(g, e) || void 0 !== t && isVisible(g, t)) switch (g.content.constructor) {
                    case ContentString:
                        {
                            const o = h.get("ychange");void 0 === e || isVisible(g, e) ? void 0 === t || isVisible(g, t) ? void 0 !== o && (packStr(), h.delete("ychange")) : void 0 !== o && o.user === g.id.client && "added" === o.type || (packStr(), h.set("ychange", n ? n("added", g.id) : {
                                type: "added"
                            })) : void 0 !== o && o.user === g.id.client && "removed" === o.type || (packStr(), h.set("ychange", n ? n("removed", g.id) : {
                                type: "removed"
                            })),
                            f += g.content.str;
                            break
                        }
                    case ContentType:
                    case ContentEmbed:
                        {
                            packStr();
                            const e = {
                                insert: g.content.getContent()[0]
                            };
                            if (h.size > 0) {
                                const t = {};
                                e.attributes = t, h.forEach(((e, n) => {
                                    t[n] = e
                                }))
                            }
                            o.push(e);
                            break
                        }
                    case ContentFormat:
                        isVisible(g, e) && (packStr(), updateCurrentAttributes(h, g.content))
                }
                g = g.right
            }
            packStr()
        };
        return e || t ? transact(p, (n => {
            e && splitSnapshotAffectedStructs(n, e), t && splitSnapshotAffectedStructs(n, t), computeDelta()
        }), "cleanup") : computeDelta(), o
    }
    insert(e, t, n) {
        if (t.length <= 0) return;
        const o = this.doc;
        null !== o ? transact(o, (o => {
            const h = findPosition(o, this, e, !n);
            n || (n = {}, h.currentAttributes.forEach(((e, t) => {
                n[t] = e
            }))), insertText(o, this, h, t, n)
        })) : this._pending.push((() => this.insert(e, t, n)))
    }
    insertEmbed(e, t, n) {
        const o = this.doc;
        null !== o ? transact(o, (o => {
            const h = findPosition(o, this, e, !n);
            insertText(o, this, h, t, n || {})
        })) : this._pending.push((() => this.insertEmbed(e, t, n || {})))
    }
    delete(e, t) {
        if (0 === t) return;
        const n = this.doc;
        null !== n ? transact(n, (n => {
            deleteText(n, findPosition(n, this, e, !0), t)
        })) : this._pending.push((() => this.delete(e, t)))
    }
    format(e, t, n) {
        if (0 === t) return;
        const o = this.doc;
        null !== o ? transact(o, (o => {
            const h = findPosition(o, this, e, !1);
            null !== h.right && formatText(o, this, h, t, n)
        })) : this._pending.push((() => this.format(e, t, n)))
    }
    removeAttribute(e) {
        null !== this.doc ? transact(this.doc, (t => {
            typeMapDelete(t, this, e)
        })) : this._pending.push((() => this.removeAttribute(e)))
    }
    setAttribute(e, t) {
        null !== this.doc ? transact(this.doc, (n => {
            typeMapSet(n, this, e, t)
        })) : this._pending.push((() => this.setAttribute(e, t)))
    }
    getAttribute(e) {
        return typeMapGet(this, e)
    }
    getAttributes() {
        return typeMapGetAll(this)
    }
    _write(e) {
        e.writeTypeRef(Zc)
    }
}
class YXmlTreeWalker {
    constructor(e, t = () => !0) {
        this._filter = t, this._root = e, this._currentNode = e._start, this._firstCall = !0, e.doc ? ? warnPrematureAccess()
    }[Symbol.iterator]() {
        return this
    }
    next() {
        let e = this._currentNode,
            t = e && e.content && e.content.type;
        if (null !== e && (!this._firstCall || e.deleted || !this._filter(t)))
            do {
                if (t = e.content.type, e.deleted || t.constructor !== YXmlElement && t.constructor !== YXmlFragment || null === t._start)
                    for (; null !== e;) {
                        if (null !== e.right) {
                            e = e.right;
                            break
                        }
                        e = e.parent === this._root ? null : e.parent._item
                    } else e = t._start
            } while (null !== e && (e.deleted || !this._filter(e.content.type)));
        return this._firstCall = !1, null === e ? {
            value: void 0,
            done: !0
        } : (this._currentNode = e, {
            value: e.content.type,
            done: !1
        })
    }
}
class YXmlFragment extends AbstractType {
    constructor() {
        super(), this._prelimContent = []
    }
    get firstChild() {
        const e = this._first;
        return e ? e.content.getContent()[0] : null
    }
    _integrate(e, t) {
        super._integrate(e, t), this.insert(0, this._prelimContent), this._prelimContent = null
    }
    _copy() {
        return new YXmlFragment
    }
    clone() {
        const e = new YXmlFragment;
        return e.insert(0, this.toArray().map((e => e instanceof AbstractType ? e.clone() : e))), e
    }
    get length() {
        return this.doc ? ? warnPrematureAccess(), null === this._prelimContent ? this._length : this._prelimContent.length
    }
    createTreeWalker(e) {
        return new YXmlTreeWalker(this, e)
    }
    querySelector(e) {
        e = e.toUpperCase();
        const t = new YXmlTreeWalker(this, (t => t.nodeName && t.nodeName.toUpperCase() === e)).next();
        return t.done ? null : t.value
    }
    querySelectorAll(e) {
        return e = e.toUpperCase(), $l(new YXmlTreeWalker(this, (t => t.nodeName && t.nodeName.toUpperCase() === e)))
    }
    _callObserver(e, t) {
        callTypeObservers(this, e, new YXmlEvent(this, t, e))
    }
    toString() {
        return typeListMap(this, (e => e.toString())).join("")
    }
    toJSON() {
        return this.toString()
    }
    toDOM(e = document, t = {}, n) {
        const o = e.createDocumentFragment();
        return void 0 !== n && n._createAssociation(o, this), typeListForEach(this, (h => {
            o.insertBefore(h.toDOM(e, t, n), null)
        })), o
    }
    insert(e, t) {
        null !== this.doc ? transact(this.doc, (n => {
            typeListInsertGenerics(n, this, e, t)
        })) : this._prelimContent.splice(e, 0, ...t)
    }
    insertAfter(e, t) {
        if (null !== this.doc) transact(this.doc, (n => {
            const o = e && e instanceof AbstractType ? e._item : e;
            typeListInsertGenericsAfter(n, this, o, t)
        }));
        else {
            const n = this._prelimContent,
                o = null === e ? 0 : n.findIndex((t => t === e)) + 1;
            if (0 === o && null !== e) throw create$3("Reference item not found");
            n.splice(o, 0, ...t)
        }
    }
    delete(e, t = 1) {
        null !== this.doc ? transact(this.doc, (n => {
            typeListDelete(n, this, e, t)
        })) : this._prelimContent.splice(e, t)
    }
    toArray() {
        return typeListToArray(this)
    }
    push(e) {
        this.insert(this.length, e)
    }
    unshift(e) {
        this.insert(0, e)
    }
    get(e) {
        return typeListGet(this, e)
    }
    slice(e = 0, t = this.length) {
        return typeListSlice(this, e, t)
    }
    forEach(e) {
        typeListForEach(this, e)
    }
    _write(e) {
        e.writeTypeRef(Bc)
    }
}
class YXmlElement extends YXmlFragment {
    constructor(e = "UNDEFINED") {
        super(), this.nodeName = e, this._prelimAttrs = new Map
    }
    get nextSibling() {
        const e = this._item ? this._item.next : null;
        return e ? e.content.type : null
    }
    get prevSibling() {
        const e = this._item ? this._item.prev : null;
        return e ? e.content.type : null
    }
    _integrate(e, t) {
        super._integrate(e, t), this._prelimAttrs.forEach(((e, t) => {
            this.setAttribute(t, e)
        })), this._prelimAttrs = null
    }
    _copy() {
        return new YXmlElement(this.nodeName)
    }
    clone() {
        const e = new YXmlElement(this.nodeName);
        return ((e, t) => {
            for (const n in e) t(e[n], n)
        })(this.getAttributes(), ((t, n) => {
            "string" == typeof t && e.setAttribute(n, t)
        })), e.insert(0, this.toArray().map((e => e instanceof AbstractType ? e.clone() : e))), e
    }
    toString() {
        const e = this.getAttributes(),
            t = [],
            n = [];
        for (const t in e) n.push(t);
        n.sort();
        const o = n.length;
        for (let h = 0; h < o; h++) {
            const o = n[h];
            t.push(o + '="' + e[o] + '"')
        }
        const h = this.nodeName.toLocaleLowerCase();
        return `<${h}${t.length>0?" "+t.join(" "):""}>${super.toString()}</${h}>`
    }
    removeAttribute(e) {
        null !== this.doc ? transact(this.doc, (t => {
            typeMapDelete(t, this, e)
        })) : this._prelimAttrs.delete(e)
    }
    setAttribute(e, t) {
        null !== this.doc ? transact(this.doc, (n => {
            typeMapSet(n, this, e, t)
        })) : this._prelimAttrs.set(e, t)
    }
    getAttribute(e) {
        return typeMapGet(this, e)
    }
    hasAttribute(e) {
        return typeMapHas(this, e)
    }
    getAttributes(e) {
        return e ? typeMapGetAllSnapshot(this, e) : typeMapGetAll(this)
    }
    toDOM(e = document, t = {}, n) {
        const o = e.createElement(this.nodeName),
            h = this.getAttributes();
        for (const e in h) {
            const t = h[e];
            "string" == typeof t && o.setAttribute(e, t)
        }
        return typeListForEach(this, (h => {
            o.appendChild(h.toDOM(e, t, n))
        })), void 0 !== n && n._createAssociation(o, this), o
    }
    _write(e) {
        e.writeTypeRef(_c), e.writeKey(this.nodeName)
    }
}
class YXmlEvent extends YEvent {
    constructor(e, t, n) {
        super(e, n), this.childListChanged = !1, this.attributesChanged = new Set, t.forEach((e => {
            null === e ? this.childListChanged = !0 : this.attributesChanged.add(e)
        }))
    }
}
class YXmlHook extends YMap {
    constructor(e) {
        super(), this.hookName = e
    }
    _copy() {
        return new YXmlHook(this.hookName)
    }
    clone() {
        const e = new YXmlHook(this.hookName);
        return this.forEach(((t, n) => {
            e.set(n, t)
        })), e
    }
    toDOM(e = document, t = {}, n) {
        const o = t[this.hookName];
        let h;
        return h = void 0 !== o ? o.createDom(this) : document.createElement(this.hookName), h.setAttribute("data-yjs-hook", this.hookName), void 0 !== n && n._createAssociation(h, this), h
    }
    _write(e) {
        e.writeTypeRef(Ic), e.writeKey(this.hookName)
    }
}
class YXmlText extends YText {
    get nextSibling() {
        const e = this._item ? this._item.next : null;
        return e ? e.content.type : null
    }
    get prevSibling() {
        const e = this._item ? this._item.prev : null;
        return e ? e.content.type : null
    }
    _copy() {
        return new YXmlText
    }
    clone() {
        const e = new YXmlText;
        return e.applyDelta(this.toDelta()), e
    }
    toDOM(e = document, t, n) {
        const o = e.createTextNode(this.toString());
        return void 0 !== n && n._createAssociation(o, this), o
    }
    toString() {
        return this.toDelta().map((e => {
            const t = [];
            for (const n in e.attributes) {
                const o = [];
                for (const t in e.attributes[n]) o.push({
                    key: t,
                    value: e.attributes[n][t]
                });
                o.sort(((e, t) => e.key < t.key ? -1 : 1)), t.push({
                    nodeName: n,
                    attrs: o
                })
            }
            t.sort(((e, t) => e.nodeName < t.nodeName ? -1 : 1));
            let n = "";
            for (let e = 0; e < t.length; e++) {
                const o = t[e];
                n += `<${o.nodeName}`;
                for (let e = 0; e < o.attrs.length; e++) {
                    const t = o.attrs[e];
                    n += ` ${t.key}="${t.value}"`
                }
                n += ">"
            }
            n += e.insert;
            for (let e = t.length - 1; e >= 0; e--) n += `</${t[e].nodeName}>`;
            return n
        })).join("")
    }
    toJSON() {
        return this.toString()
    }
    _write(e) {
        e.writeTypeRef(Xc)
    }
}
class AbstractStruct {
    constructor(e, t) {
        this.id = e, this.length = t
    }
    get deleted() {
        throw methodUnimplemented()
    }
    mergeWith(e) {
        return !1
    }
    write(e, t, n) {
        throw methodUnimplemented()
    }
    integrate(e, t) {
        throw methodUnimplemented()
    }
}
class GC extends AbstractStruct {
    get deleted() {
        return !0
    }
    delete() {}
    mergeWith(e) {
        return this.constructor === e.constructor && (this.length += e.length, !0)
    }
    integrate(e, t) {
        t > 0 && (this.id.clock += t, this.length -= t), addStruct(e.doc.store, this)
    }
    write(e, t) {
        e.writeInfo(0), e.writeLen(this.length - t)
    }
    getMissing(e, t) {
        return null
    }
}
class ContentBinary {
    constructor(e) {
        this.content = e
    }
    getLength() {
        return 1
    }
    getContent() {
        return [this.content]
    }
    isCountable() {
        return !0
    }
    copy() {
        return new ContentBinary(this.content)
    }
    splice(e) {
        throw methodUnimplemented()
    }
    mergeWith(e) {
        return !1
    }
    integrate(e, t) {}
    delete(e) {}
    gc(e) {}
    write(e, t) {
        e.writeBuf(this.content)
    }
    getRef() {
        return 3
    }
}
class ContentDeleted {
    constructor(e) {
        this.len = e
    }
    getLength() {
        return this.len
    }
    getContent() {
        return []
    }
    isCountable() {
        return !1
    }
    copy() {
        return new ContentDeleted(this.len)
    }
    splice(e) {
        const t = new ContentDeleted(this.len - e);
        return this.len = e, t
    }
    mergeWith(e) {
        return this.len += e.len, !0
    }
    integrate(e, t) {
        addToDeleteSet(e.deleteSet, t.id.client, t.id.clock, this.len), t.markDeleted()
    }
    delete(e) {}
    gc(e) {}
    write(e, t) {
        e.writeLen(this.len - t)
    }
    getRef() {
        return 1
    }
}
const createDocFromOpts = (e, t) => new Doc({
    guid: e,
    ...t,
    shouldLoad: t.shouldLoad || t.autoLoad || !1
});
class ContentDoc {
    constructor(e) {
        e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
        const t = {};
        this.opts = t, e.gc || (t.gc = !1), e.autoLoad && (t.autoLoad = !0), null !== e.meta && (t.meta = e.meta)
    }
    getLength() {
        return 1
    }
    getContent() {
        return [this.doc]
    }
    isCountable() {
        return !0
    }
    copy() {
        return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts))
    }
    splice(e) {
        throw methodUnimplemented()
    }
    mergeWith(e) {
        return !1
    }
    integrate(e, t) {
        this.doc._item = t, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc)
    }
    delete(e) {
        e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc)
    }
    gc(e) {}
    write(e, t) {
        e.writeString(this.doc.guid), e.writeAny(this.opts)
    }
    getRef() {
        return 9
    }
}
class ContentEmbed {
    constructor(e) {
        this.embed = e
    }
    getLength() {
        return 1
    }
    getContent() {
        return [this.embed]
    }
    isCountable() {
        return !0
    }
    copy() {
        return new ContentEmbed(this.embed)
    }
    splice(e) {
        throw methodUnimplemented()
    }
    mergeWith(e) {
        return !1
    }
    integrate(e, t) {}
    delete(e) {}
    gc(e) {}
    write(e, t) {
        e.writeJSON(this.embed)
    }
    getRef() {
        return 5
    }
}
class ContentFormat {
    constructor(e, t) {
        this.key = e, this.value = t
    }
    getLength() {
        return 1
    }
    getContent() {
        return []
    }
    isCountable() {
        return !1
    }
    copy() {
        return new ContentFormat(this.key, this.value)
    }
    splice(e) {
        throw methodUnimplemented()
    }
    mergeWith(e) {
        return !1
    }
    integrate(e, t) {
        const n = t.parent;
        n._searchMarker = null, n._hasFormatting = !0
    }
    delete(e) {}
    gc(e) {}
    write(e, t) {
        e.writeKey(this.key), e.writeJSON(this.value)
    }
    getRef() {
        return 6
    }
}
class ContentJSON {
    constructor(e) {
        this.arr = e
    }
    getLength() {
        return this.arr.length
    }
    getContent() {
        return this.arr
    }
    isCountable() {
        return !0
    }
    copy() {
        return new ContentJSON(this.arr)
    }
    splice(e) {
        const t = new ContentJSON(this.arr.slice(e));
        return this.arr = this.arr.slice(0, e), t
    }
    mergeWith(e) {
        return this.arr = this.arr.concat(e.arr), !0
    }
    integrate(e, t) {}
    delete(e) {}
    gc(e) {}
    write(e, t) {
        const n = this.arr.length;
        e.writeLen(n - t);
        for (let o = t; o < n; o++) {
            const t = this.arr[o];
            e.writeString(void 0 === t ? "undefined" : JSON.stringify(t))
        }
    }
    getRef() {
        return 2
    }
}
const Rc = "development" === getVariable("node_env");
class ContentAny {
    constructor(e) {
        this.arr = e, Rc && deepFreeze(e)
    }
    getLength() {
        return this.arr.length
    }
    getContent() {
        return this.arr
    }
    isCountable() {
        return !0
    }
    copy() {
        return new ContentAny(this.arr)
    }
    splice(e) {
        const t = new ContentAny(this.arr.slice(e));
        return this.arr = this.arr.slice(0, e), t
    }
    mergeWith(e) {
        return this.arr = this.arr.concat(e.arr), !0
    }
    integrate(e, t) {}
    delete(e) {}
    gc(e) {}
    write(e, t) {
        const n = this.arr.length;
        e.writeLen(n - t);
        for (let o = t; o < n; o++) {
            const t = this.arr[o];
            e.writeAny(t)
        }
    }
    getRef() {
        return 8
    }
}
class ContentString {
    constructor(e) {
        this.str = e
    }
    getLength() {
        return this.str.length
    }
    getContent() {
        return this.str.split("")
    }
    isCountable() {
        return !0
    }
    copy() {
        return new ContentString(this.str)
    }
    splice(e) {
        const t = new ContentString(this.str.slice(e));
        this.str = this.str.slice(0, e);
        const n = this.str.charCodeAt(e - 1);
        return n >= 55296 && n <= 56319 && (this.str = this.str.slice(0, e - 1) + "ï¿½", t.str = "ï¿½" + t.str.slice(1)), t
    }
    mergeWith(e) {
        return this.str += e.str, !0
    }
    integrate(e, t) {}
    delete(e) {}
    gc(e) {}
    write(e, t) {
        e.writeString(0 === t ? this.str : this.str.slice(t))
    }
    getRef() {
        return 4
    }
}
const Dc = [e => new YArray, e => new YMap, e => new YText, e => new YXmlElement(e.readKey()), e => new YXmlFragment, e => new YXmlHook(e.readKey()), e => new YXmlText],
    Lc = 0,
    Vc = 1,
    Zc = 2,
    _c = 3,
    Bc = 4,
    Ic = 5,
    Xc = 6;
class ContentType {
    constructor(e) {
        this.type = e
    }
    getLength() {
        return 1
    }
    getContent() {
        return [this.type]
    }
    isCountable() {
        return !0
    }
    copy() {
        return new ContentType(this.type._copy())
    }
    splice(e) {
        throw methodUnimplemented()
    }
    mergeWith(e) {
        return !1
    }
    integrate(e, t) {
        this.type._integrate(e.doc, t)
    }
    delete(e) {
        let t = this.type._start;
        for (; null !== t;) t.deleted ? t.id.clock < (e.beforeState.get(t.id.client) || 0) && e._mergeStructs.push(t) : t.delete(e), t = t.right;
        this.type._map.forEach((t => {
            t.deleted ? t.id.clock < (e.beforeState.get(t.id.client) || 0) && e._mergeStructs.push(t) : t.delete(e)
        })), e.changed.delete(this.type)
    }
    gc(e) {
        let t = this.type._start;
        for (; null !== t;) t.gc(e, !0), t = t.right;
        this.type._start = null, this.type._map.forEach((t => {
            for (; null !== t;) t.gc(e, !0), t = t.left
        })), this.type._map = new Map
    }
    write(e, t) {
        this.type._write(e)
    }
    getRef() {
        return 7
    }
}
const followRedone = (e, t) => {
        let n, o = t,
            h = 0;
        do {
            h > 0 && (o = createID(o.client, o.clock + h)), n = getItem(e, o), h = o.clock - n.id.clock, o = n.redone
        } while (null !== o && n instanceof Item);
        return {
            item: n,
            diff: h
        }
    },
    keepItem = (e, t) => {
        for (; null !== e && e.keep !== t;) e.keep = t, e = e.parent._item
    },
    splitItem = (e, t, n) => {
        const {
            client: o,
            clock: h
        } = t.id, p = new Item(createID(o, h + n), t, createID(o, h + n - 1), t.right, t.rightOrigin, t.parent, t.parentSub, t.content.splice(n));
        return t.deleted && p.markDeleted(), t.keep && (p.keep = !0), null !== t.redone && (p.redone = createID(t.redone.client, t.redone.clock + n)), t.right = p, null !== p.right && (p.right.left = p), e._mergeStructs.push(p), null !== p.parentSub && null === p.right && p.parent._map.set(p.parentSub, p), t.length = n, p
    },
    isDeletedByUndoStack = (e, t) => ((e, t) => {
        for (let n = 0; n < e.length; n++)
            if (t(e[n], n, e)) return !0;
        return !1
    })(e, (e => isDeleted(e.deletions, t))),
    redoItem = (e, t, n, o, h, p) => {
        const f = e.doc,
            g = f.store,
            y = f.clientID,
            w = t.redone;
        if (null !== w) return getItemCleanStart(e, w);
        let b, S = t.parent._item,
            k = null;
        if (null !== S && !0 === S.deleted) {
            if (null === S.redone && (!n.has(S) || null === redoItem(e, S, n, o, h, p))) return null;
            for (; null !== S.redone;) S = getItemCleanStart(e, S.redone)
        }
        const v = null === S ? t.parent : S.content.type;
        if (null === t.parentSub) {
            for (k = t.left, b = t; null !== k;) {
                let t = k;
                for (; null !== t && t.parent._item !== S;) t = null === t.redone ? null : getItemCleanStart(e, t.redone);
                if (null !== t && t.parent._item === S) {
                    k = t;
                    break
                }
                k = k.left
            }
            for (; null !== b;) {
                let t = b;
                for (; null !== t && t.parent._item !== S;) t = null === t.redone ? null : getItemCleanStart(e, t.redone);
                if (null !== t && t.parent._item === S) {
                    b = t;
                    break
                }
                b = b.right
            }
        } else if (b = null, t.right && !h) {
            for (k = t; null !== k && null !== k.right && (k.right.redone || isDeleted(o, k.right.id) || isDeletedByUndoStack(p.undoStack, k.right.id) || isDeletedByUndoStack(p.redoStack, k.right.id));)
                for (k = k.right; k.redone;) k = getItemCleanStart(e, k.redone);
            if (k && null !== k.right) return null
        } else k = v._map.get(t.parentSub) || null;
        const P = getState(g, y),
            C = createID(y, P),
            Q = new Item(C, k, k && k.lastId, b, b && b.id, v, t.parentSub, t.content.copy());
        return t.redone = C, keepItem(Q, !0), Q.integrate(e, 0), Q
    };
class Item extends AbstractStruct {
    constructor(e, t, n, o, h, p, f, g) {
        super(e, g.getLength()), this.origin = n, this.left = t, this.right = o, this.rightOrigin = h, this.parent = p, this.parentSub = f, this.redone = null, this.content = g, this.info = this.content.isCountable() ? 2 : 0
    }
    set marker(e) {
        (8 & this.info) > 0 !== e && (this.info ^= 8)
    }
    get marker() {
        return (8 & this.info) > 0
    }
    get keep() {
        return (1 & this.info) > 0
    }
    set keep(e) {
        this.keep !== e && (this.info ^= 1)
    }
    get countable() {
        return (2 & this.info) > 0
    }
    get deleted() {
        return (4 & this.info) > 0
    }
    set deleted(e) {
        this.deleted !== e && (this.info ^= 4)
    }
    markDeleted() {
        this.info |= 4
    }
    getMissing(e, t) {
        if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(t, this.origin.client)) return this.origin.client;
        if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(t, this.rightOrigin.client)) return this.rightOrigin.client;
        if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(t, this.parent.client)) return this.parent.client;
        if (this.origin && (this.left = getItemCleanEnd(e, t, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = getItemCleanStart(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) this.parent = null;
        else if (this.parent) {
            if (this.parent.constructor === ID) {
                const e = getItem(t, this.parent);
                e.constructor === GC ? this.parent = null : this.parent = e.content.type
            }
        } else this.left && this.left.constructor === Item && (this.parent = this.left.parent, this.parentSub = this.left.parentSub), this.right && this.right.constructor === Item && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
        return null
    }
    integrate(e, t) {
        if (t > 0 && (this.id.clock += t, this.left = getItemCleanEnd(e, e.doc.store, createID(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(t), this.length -= t), this.parent) {
            if (!this.left && (!this.right || null !== this.right.left) || this.left && this.left.right !== this.right) {
                let t, n = this.left;
                if (null !== n) t = n.right;
                else if (null !== this.parentSub)
                    for (t = this.parent._map.get(this.parentSub) || null; null !== t && null !== t.left;) t = t.left;
                else t = this.parent._start;
                const o = new Set,
                    h = new Set;
                for (; null !== t && t !== this.right;) {
                    if (h.add(t), o.add(t), compareIDs(this.origin, t.origin)) {
                        if (t.id.client < this.id.client) n = t, o.clear();
                        else if (compareIDs(this.rightOrigin, t.rightOrigin)) break
                    } else {
                        if (null === t.origin || !h.has(getItem(e.doc.store, t.origin))) break;
                        o.has(getItem(e.doc.store, t.origin)) || (n = t, o.clear())
                    }
                    t = t.right
                }
                this.left = n
            }
            if (null !== this.left) {
                const e = this.left.right;
                this.right = e, this.left.right = this
            } else {
                let e;
                if (null !== this.parentSub)
                    for (e = this.parent._map.get(this.parentSub) || null; null !== e && null !== e.left;) e = e.left;
                else e = this.parent._start, this.parent._start = this;
                this.right = e
            }
            null !== this.right ? this.right.left = this : null !== this.parentSub && (this.parent._map.set(this.parentSub, this), null !== this.left && this.left.delete(e)), null === this.parentSub && this.countable && !this.deleted && (this.parent._length += this.length), addStruct(e.doc.store, this), this.content.integrate(e, this), addChangedTypeToTransaction(e, this.parent, this.parentSub), (null !== this.parent._item && this.parent._item.deleted || null !== this.parentSub && null !== this.right) && this.delete(e)
        } else new GC(this.id, this.length).integrate(e, 0)
    }
    get next() {
        let e = this.right;
        for (; null !== e && e.deleted;) e = e.right;
        return e
    }
    get prev() {
        let e = this.left;
        for (; null !== e && e.deleted;) e = e.left;
        return e
    }
    get lastId() {
        return 1 === this.length ? this.id : createID(this.id.client, this.id.clock + this.length - 1)
    }
    mergeWith(e) {
        if (this.constructor === e.constructor && compareIDs(e.origin, this.lastId) && this.right === e && compareIDs(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && null === this.redone && null === e.redone && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
            const t = this.parent._searchMarker;
            return t && t.forEach((t => {
                t.p === e && (t.p = this, !this.deleted && this.countable && (t.index -= this.length))
            })), e.keep && (this.keep = !0), this.right = e.right, null !== this.right && (this.right.left = this), this.length += e.length, !0
        }
        return !1
    }
    delete(e) {
        if (!this.deleted) {
            const t = this.parent;
            this.countable && null === this.parentSub && (t._length -= this.length), this.markDeleted(), addToDeleteSet(e.deleteSet, this.id.client, this.id.clock, this.length), addChangedTypeToTransaction(e, t, this.parentSub), this.content.delete(e)
        }
    }
    gc(e, t) {
        if (!this.deleted) throw unexpectedCase();
        this.content.gc(e), t ? ((e, t, n) => {
            const o = e.clients.get(t.id.client);
            o[findIndexSS(o, t.id.clock)] = n
        })(e, this, new GC(this.id, this.length)) : this.content = new ContentDeleted(this.length)
    }
    write(e, t) {
        const n = t > 0 ? createID(this.id.client, this.id.clock + t - 1) : this.origin,
            o = this.rightOrigin,
            h = this.parentSub,
            p = 31 & this.content.getRef() | (null === n ? 0 : Ll) | (null === o ? 0 : Dl) | (null === h ? 0 : 32);
        if (e.writeInfo(p), null !== n && e.writeLeftID(n), null !== o && e.writeRightID(o), null === n && null === o) {
            const t = this.parent;
            if (void 0 !== t._item) {
                const n = t._item;
                if (null === n) {
                    const n = findRootTypeKey(t);
                    e.writeParentInfo(!0), e.writeString(n)
                } else e.writeParentInfo(!1), e.writeLeftID(n.id)
            } else t.constructor === String ? (e.writeParentInfo(!0), e.writeString(t)) : t.constructor === ID ? (e.writeParentInfo(!1), e.writeLeftID(t)) : unexpectedCase();
            null !== h && e.writeString(h)
        }
        this.content.write(e, t)
    }
}
const readItemContent = (e, t) => qc[31 & t](e),
    qc = [() => {
        unexpectedCase()
    }, e => new ContentDeleted(e.readLen()), e => {
        const t = e.readLen(),
            n = [];
        for (let o = 0; o < t; o++) {
            const t = e.readString();
            "undefined" === t ? n.push(void 0) : n.push(JSON.parse(t))
        }
        return new ContentJSON(n)
    }, e => new ContentBinary(e.readBuf()), e => new ContentString(e.readString()), e => new ContentEmbed(e.readJSON()), e => new ContentFormat(e.readKey(), e.readJSON()), e => new ContentType(Dc[e.readTypeRef()](e)), e => {
        const t = e.readLen(),
            n = [];
        for (let o = 0; o < t; o++) n.push(e.readAny());
        return new ContentAny(n)
    }, e => new ContentDoc(createDocFromOpts(e.readString(), e.readAny())), () => {
        unexpectedCase()
    }];
class Skip extends AbstractStruct {
    get deleted() {
        return !0
    }
    delete() {}
    mergeWith(e) {
        return this.constructor === e.constructor && (this.length += e.length, !0)
    }
    integrate(e, t) {
        unexpectedCase()
    }
    write(e, t) {
        e.writeInfo(10), writeVarUint(e.restEncoder, this.length - t)
    }
    getMissing(e, t) {
        return null
    }
}
const zc = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {},
    Nc = "__ $YJS$ __";
!0 === zc[Nc] && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438"), zc[Nc] = !0;
var Yc = Object.freeze({
    __proto__: null,
    AbsolutePosition: AbsolutePosition,
    AbstractConnector: class extends ObservableV2 {
        constructor(e, t) {
            super(), this.doc = e, this.awareness = t
        }
    },
    AbstractStruct: AbstractStruct,
    AbstractType: AbstractType,
    Array: YArray,
    ContentAny: ContentAny,
    ContentBinary: ContentBinary,
    ContentDeleted: ContentDeleted,
    ContentDoc: ContentDoc,
    ContentEmbed: ContentEmbed,
    ContentFormat: ContentFormat,
    ContentJSON: ContentJSON,
    ContentString: ContentString,
    ContentType: ContentType,
    Doc: Doc,
    GC: GC,
    ID: ID,
    Item: Item,
    Map: YMap,
    PermanentUserData: class {
        constructor(e, t = e.getMap("users")) {
            const n = new Map;
            this.yusers = t, this.doc = e, this.clients = new Map, this.dss = n;
            const initUser = (e, t) => {
                const n = e.get("ds"),
                    o = e.get("ids"),
                    addClientId = e => this.clients.set(e, t);
                n.observe((e => {
                    e.changes.added.forEach((e => {
                        e.content.getContent().forEach((e => {
                            e instanceof Uint8Array && this.dss.set(t, mergeDeleteSets([this.dss.get(t) || createDeleteSet(), readDeleteSet(new DSDecoderV1(createDecoder(e)))]))
                        }))
                    }))
                })), this.dss.set(t, mergeDeleteSets(n.map((e => readDeleteSet(new DSDecoderV1(createDecoder(e))))))), o.observe((e => e.changes.added.forEach((e => e.content.getContent().forEach(addClientId))))), o.forEach(addClientId)
            };
            t.observe((e => {
                e.keysChanged.forEach((e => initUser(t.get(e), e)))
            })), t.forEach(initUser)
        }
        setUserMapping(e, t, n, {
            filter: o = () => !0
        } = {}) {
            const h = this.yusers;
            let p = h.get(n);
            p || (p = new YMap, p.set("ids", new YArray), p.set("ds", new YArray), h.set(n, p)), p.get("ids").push([t]), h.observe((e => {
                setTimeout((() => {
                    const e = h.get(n);
                    if (e !== p) {
                        p = e, this.clients.forEach(((e, t) => {
                            n === e && p.get("ids").push([t])
                        }));
                        const t = new DSEncoderV1,
                            o = this.dss.get(n);
                        o && (writeDeleteSet(t, o), p.get("ds").push([t.toUint8Array()]))
                    }
                }), 0)
            })), e.on("afterTransaction", (e => {
                setTimeout((() => {
                    const t = p.get("ds"),
                        n = e.deleteSet;
                    if (e.local && n.clients.size > 0 && o(e, n)) {
                        const e = new DSEncoderV1;
                        writeDeleteSet(e, n), t.push([e.toUint8Array()])
                    }
                }))
            }))
        }
        getUserByClientId(e) {
            return this.clients.get(e) || null
        }
        getUserByDeletedId(e) {
            for (const [t, n] of this.dss.entries())
                if (isDeleted(n, e)) return t;
            return null
        }
    },
    RelativePosition: RelativePosition,
    Skip: Skip,
    Snapshot: Snapshot,
    Text: YText,
    Transaction: Transaction,
    UndoManager: class extends ObservableV2 {
        constructor(e, {
            captureTimeout: t = 500,
            captureTransaction: n = e => !0,
            deleteFilter: o = () => !0,
            trackedOrigins: h = new Set([null]),
            ignoreRemoteMapChanges: p = !1,
            doc: f = (El(e) ? e[0].doc : e.doc)
        } = {}) {
            super(), this.scope = [], this.doc = f, this.addToScope(e), this.deleteFilter = o, h.add(this), this.trackedOrigins = h, this.captureTransaction = n, this.undoStack = [], this.redoStack = [], this.undoing = !1, this.redoing = !1, this.currStackItem = null, this.lastChange = 0, this.ignoreRemoteMapChanges = p, this.captureTimeout = t, this.afterTransactionHandler = e => {
                if (!(this.captureTransaction(e) && this.scope.some((t => e.changedParentTypes.has(t))) && (this.trackedOrigins.has(e.origin) || e.origin && this.trackedOrigins.has(e.origin.constructor)))) return;
                const t = this.undoing,
                    n = this.redoing,
                    o = t ? this.redoStack : this.undoStack;
                t ? this.stopCapturing() : n || this.clear(!1, !0);
                const h = new DeleteSet;
                e.afterState.forEach(((t, n) => {
                    const o = e.beforeState.get(n) || 0,
                        p = t - o;
                    p > 0 && addToDeleteSet(h, n, o, p)
                }));
                const p = nc();
                let f = !1;
                if (this.lastChange > 0 && p - this.lastChange < this.captureTimeout && o.length > 0 && !t && !n) {
                    const t = o[o.length - 1];
                    t.deletions = mergeDeleteSets([t.deletions, e.deleteSet]), t.insertions = mergeDeleteSets([t.insertions, h])
                } else o.push(new StackItem(e.deleteSet, h)), f = !0;
                t || n || (this.lastChange = p), iterateDeletedStructs(e, e.deleteSet, (e => {
                    e instanceof Item && this.scope.some((t => isParentOf(t, e))) && keepItem(e, !0)
                }));
                const g = [{
                    stackItem: o[o.length - 1],
                    origin: e.origin,
                    type: t ? "redo" : "undo",
                    changedParentTypes: e.changedParentTypes
                }, this];
                f ? this.emit("stack-item-added", g) : this.emit("stack-item-updated", g)
            }, this.doc.on("afterTransaction", this.afterTransactionHandler), this.doc.on("destroy", (() => {
                this.destroy()
            }))
        }
        addToScope(e) {
            (e = El(e) ? e : [e]).forEach((e => {
                this.scope.every((t => t !== e)) && (e.doc !== this.doc && warn("[yjs#509] Not same Y.Doc"), this.scope.push(e))
            }))
        }
        addTrackedOrigin(e) {
            this.trackedOrigins.add(e)
        }
        removeTrackedOrigin(e) {
            this.trackedOrigins.delete(e)
        }
        clear(e = !0, t = !0) {
            (e && this.canUndo() || t && this.canRedo()) && this.doc.transact((n => {
                e && (this.undoStack.forEach((e => clearUndoManagerStackItem(n, this, e))), this.undoStack = []), t && (this.redoStack.forEach((e => clearUndoManagerStackItem(n, this, e))), this.redoStack = []), this.emit("stack-cleared", [{
                    undoStackCleared: e,
                    redoStackCleared: t
                }])
            }))
        }
        stopCapturing() {
            this.lastChange = 0
        }
        undo() {
            let e;
            this.undoing = !0;
            try {
                e = popStackItem(this, this.undoStack, "undo")
            } finally {
                this.undoing = !1
            }
            return e
        }
        redo() {
            let e;
            this.redoing = !0;
            try {
                e = popStackItem(this, this.redoStack, "redo")
            } finally {
                this.redoing = !1
            }
            return e
        }
        canUndo() {
            return this.undoStack.length > 0
        }
        canRedo() {
            return this.redoStack.length > 0
        }
        destroy() {
            this.trackedOrigins.delete(this), this.doc.off("afterTransaction", this.afterTransactionHandler), super.destroy()
        }
    },
    UpdateDecoderV1: UpdateDecoderV1,
    UpdateDecoderV2: UpdateDecoderV2,
    UpdateEncoderV1: UpdateEncoderV1,
    UpdateEncoderV2: UpdateEncoderV2,
    XmlElement: YXmlElement,
    XmlFragment: YXmlFragment,
    XmlHook: YXmlHook,
    XmlText: YXmlText,
    YArrayEvent: YArrayEvent,
    YEvent: YEvent,
    YMapEvent: YMapEvent,
    YTextEvent: YTextEvent,
    YXmlEvent: YXmlEvent,
    applyUpdate: applyUpdate,
    applyUpdateV2: applyUpdateV2,
    cleanupYTextFormatting: cleanupYTextFormatting,
    compareIDs: compareIDs,
    compareRelativePositions: (e, t) => e === t || null !== e && null !== t && e.tname === t.tname && compareIDs(e.item, t.item) && compareIDs(e.type, t.type) && e.assoc === t.assoc,
    convertUpdateFormatV1ToV2: e => convertUpdateFormat(e, id, UpdateDecoderV1, UpdateEncoderV2),
    convertUpdateFormatV2ToV1: convertUpdateFormatV2ToV1,
    createAbsolutePositionFromRelativePosition: (e, t, n = !0) => {
        const o = t.store,
            h = e.item,
            p = e.type,
            f = e.tname,
            g = e.assoc;
        let y = null,
            w = 0;
        if (null !== h) {
            if (getState(o, h.client) <= h.clock) return null;
            const e = n ? followRedone(o, h) : {
                    item: getItem(o, h),
                    diff: 0
                },
                t = e.item;
            if (!(t instanceof Item)) return null;
            if (y = t.parent, null === y._item || !y._item.deleted) {
                w = t.deleted || !t.countable ? 0 : e.diff + (g >= 0 ? 0 : 1);
                let n = t.left;
                for (; null !== n;) !n.deleted && n.countable && (w += n.length), n = n.left
            }
        } else {
            if (null !== f) y = t.get(f);
            else {
                if (null === p) throw unexpectedCase(); {
                    if (getState(o, p.client) <= p.clock) return null;
                    const {
                        item: e
                    } = n ? followRedone(o, p) : {
                        item: getItem(o, p)
                    };
                    if (!(e instanceof Item && e.content instanceof ContentType)) return null;
                    y = e.content.type
                }
            }
            w = g >= 0 ? y._length : 0
        }
        return ((e, t, n = 0) => new AbsolutePosition(e, t, n))(y, w, e.assoc)
    },
    createDeleteSet: createDeleteSet,
    createDeleteSetFromStructStore: createDeleteSetFromStructStore,
    createDocFromSnapshot: (e, t, n = new Doc) => {
        if (e.gc) throw new Error("Garbage-collection must be disabled in `originDoc`!");
        const {
            sv: o,
            ds: h
        } = t, p = new UpdateEncoderV2;
        return e.transact((t => {
            let n = 0;
            o.forEach((e => {
                e > 0 && n++
            })), writeVarUint(p.restEncoder, n);
            for (const [n, h] of o) {
                if (0 === h) continue;
                h < getState(e.store, n) && getItemCleanStart(t, createID(n, h));
                const o = e.store.clients.get(n) || [],
                    f = findIndexSS(o, h - 1);
                writeVarUint(p.restEncoder, f + 1), p.writeClient(n), writeVarUint(p.restEncoder, 0);
                for (let e = 0; e <= f; e++) o[e].write(p, 0)
            }
            writeDeleteSet(p, h)
        })), applyUpdateV2(n, p.toUint8Array(), "snapshot"), n
    },
    createID: createID,
    createRelativePositionFromJSON: e => new RelativePosition(null == e.type ? null : createID(e.type.client, e.type.clock), e.tname ? ? null, null == e.item ? null : createID(e.item.client, e.item.clock), null == e.assoc ? 0 : e.assoc),
    createRelativePositionFromTypeIndex: (e, t, n = 0) => {
        let o = e._start;
        if (n < 0) {
            if (0 === t) return createRelativePosition(e, null, n);
            t--
        }
        for (; null !== o;) {
            if (!o.deleted && o.countable) {
                if (o.length > t) return createRelativePosition(e, createID(o.id.client, o.id.clock + t), n);
                t -= o.length
            }
            if (null === o.right && n < 0) return createRelativePosition(e, o.lastId, n);
            o = o.right
        }
        return createRelativePosition(e, null, n)
    },
    createSnapshot: createSnapshot,
    decodeRelativePosition: e => (e => {
        let t = null,
            n = null,
            o = null;
        switch (readVarUint(e)) {
            case 0:
                o = readID(e);
                break;
            case 1:
                n = Kl(e);
                break;
            case 2:
                t = readID(e)
        }
        const h = hasContent(e) ? readVarInt(e) : 0;
        return new RelativePosition(t, n, o, h)
    })(createDecoder(e)),
    decodeSnapshot: e => decodeSnapshotV2(e, new DSDecoderV1(createDecoder(e))),
    decodeSnapshotV2: decodeSnapshotV2,
    decodeStateVector: decodeStateVector,
    decodeUpdate: e => decodeUpdateV2(e, UpdateDecoderV1),
    decodeUpdateV2: decodeUpdateV2,
    diffUpdate: (e, t) => diffUpdateV2(e, t, UpdateDecoderV1, UpdateEncoderV1),
    diffUpdateV2: diffUpdateV2,
    emptySnapshot: Ec,
    encodeRelativePosition: e => {
        const t = createEncoder();
        return ((e, t) => {
            const {
                type: n,
                tname: o,
                item: h,
                assoc: p
            } = t;
            if (null !== h) writeVarUint(e, 0), writeID(e, h);
            else if (null !== o) Yl(e, 1), Ul(e, o);
            else {
                if (null === n) throw unexpectedCase();
                Yl(e, 2), writeID(e, n)
            }
            writeVarInt(e, p)
        })(t, e), toUint8Array(t)
    },
    encodeSnapshot: e => encodeSnapshotV2(e, new DSEncoderV1),
    encodeSnapshotV2: encodeSnapshotV2,
    encodeStateAsUpdate: encodeStateAsUpdate,
    encodeStateAsUpdateV2: encodeStateAsUpdateV2,
    encodeStateVector: encodeStateVector,
    encodeStateVectorFromUpdate: e => encodeStateVectorFromUpdateV2(e, DSEncoderV1, UpdateDecoderV1),
    encodeStateVectorFromUpdateV2: encodeStateVectorFromUpdateV2,
    equalDeleteSets: equalDeleteSets,
    equalSnapshots: (e, t) => {
        const n = e.ds.clients,
            o = t.ds.clients,
            h = e.sv,
            p = t.sv;
        if (h.size !== p.size || n.size !== o.size) return !1;
        for (const [e, t] of h.entries())
            if (p.get(e) !== t) return !1;
        for (const [e, t] of n.entries()) {
            const n = o.get(e) || [];
            if (t.length !== n.length) return !1;
            for (let e = 0; e < t.length; e++) {
                const o = t[e],
                    h = n[e];
                if (o.clock !== h.clock || o.len !== h.len) return !1
            }
        }
        return !0
    },
    findIndexSS: findIndexSS,
    findRootTypeKey: findRootTypeKey,
    getItem: getItem,
    getState: getState,
    getTypeChildren: e => {
        e.doc ? ? warnPrematureAccess();
        let t = e._start;
        const n = [];
        for (; t;) n.push(t), t = t.right;
        return n
    },
    isDeleted: isDeleted,
    isParentOf: isParentOf,
    iterateDeletedStructs: iterateDeletedStructs,
    logType: e => {
        const t = [];
        let n = e._start;
        for (; n;) t.push(n), n = n.right;
        console.log("Children: ", t), console.log("Children content: ", t.filter((e => !e.deleted)).map((e => e.content)))
    },
    logUpdate: e => logUpdateV2(e, UpdateDecoderV1),
    logUpdateV2: logUpdateV2,
    mergeDeleteSets: mergeDeleteSets,
    mergeUpdates: mergeUpdates,
    mergeUpdatesV2: mergeUpdatesV2,
    obfuscateUpdate: (e, t) => convertUpdateFormat(e, createObfuscator(t), UpdateDecoderV1, UpdateEncoderV1),
    obfuscateUpdateV2: (e, t) => convertUpdateFormat(e, createObfuscator(t), UpdateDecoderV2, UpdateEncoderV2),
    parseUpdateMeta: e => parseUpdateMetaV2(e, UpdateDecoderV1),
    parseUpdateMetaV2: parseUpdateMetaV2,
    readUpdate: (e, t, n) => readUpdateV2(e, t, n, new UpdateDecoderV1(e)),
    readUpdateV2: readUpdateV2,
    relativePositionToJSON: e => {
        const t = {};
        return e.type && (t.type = e.type), e.tname && (t.tname = e.tname), e.item && (t.item = e.item), null != e.assoc && (t.assoc = e.assoc), t
    },
    snapshot: e => createSnapshot(createDeleteSetFromStructStore(e.store), getStateVector(e.store)),
    snapshotContainsUpdate: (e, t) => ((e, t, n = UpdateDecoderV2) => {
        const o = new n(createDecoder(t)),
            h = new LazyStructReader(o, !1);
        for (let t = h.curr; null !== t; t = h.next())
            if ((e.sv.get(t.id.client) || 0) < t.id.clock + t.length) return !1;
        const p = mergeDeleteSets([e.ds, readDeleteSet(o)]);
        return equalDeleteSets(e.ds, p)
    })(e, t, UpdateDecoderV1),
    transact: transact,
    tryGc: (e, t, n) => {
        tryGcDeleteSet(e, t, n), tryMergeDeleteSet(e, t)
    },
    typeListToArraySnapshot: (e, t) => {
        const n = [];
        let o = e._start;
        for (; null !== o;) {
            if (o.countable && isVisible(o, t)) {
                const e = o.content.getContent();
                for (let t = 0; t < e.length; t++) n.push(e[t])
            }
            o = o.right
        }
        return n
    },
    typeMapGetAllSnapshot: typeMapGetAllSnapshot,
    typeMapGetSnapshot: (e, t, n) => {
        let o = e._map.get(t) || null;
        for (; null !== o && (!n.sv.has(o.id.client) || o.id.clock >= (n.sv.get(o.id.client) || 0));) o = o.left;
        return null !== o && isVisible(o, n) ? o.content.getContent()[o.length - 1] : void 0
    }
});
const jc = new Map;
const Wc = "undefined" == typeof BroadcastChannel ? class {
        constructor(e) {
            var t;
            this.room = e, this.onmessage = null, this._onChange = t => t.key === e && null !== this.onmessage && this.onmessage({
                data: gc(t.newValue || "")
            }), t = this._onChange, rc || addEventListener("storage", t)
        }
        postMessage(e) {
            oc.setItem(this.room, fc(new Uint8Array(e)))
        }
        close() {
            var e;
            e = this._onChange, rc || removeEventListener("storage", e)
        }
    } : BroadcastChannel,
    getChannel = e => setIfUndefined(jc, e, (() => {
        const t = create$4(),
            n = new Wc(e);
        return n.onmessage = e => t.forEach((t => t(e.data, "broadcastchannel"))), {
            bc: n,
            subs: t
        }
    })),
    publish = (e, t, n = null) => {
        const o = getChannel(e);
        o.bc.postMessage(t), o.subs.forEach((e => e(t, n)))
    },
    writeSyncStep1 = (e, t) => {
        writeVarUint(e, 0);
        const n = encodeStateVector(t);
        writeVarUint8Array(e, n)
    },
    writeSyncStep2 = (e, t, n) => {
        writeVarUint(e, 1), writeVarUint8Array(e, encodeStateAsUpdate(t, n))
    },
    readSyncStep2 = (e, t, n) => {
        try {
            applyUpdate(t, readVarUint8Array(e), n)
        } catch (e) {
            console.error("Caught error while handling a Yjs update", e)
        }
    },
    Uc = readSyncStep2,
    readSyncMessage = (e, t, n, o) => {
        const h = readVarUint(e);
        switch (h) {
            case 0:
                ((e, t, n) => {
                    writeSyncStep2(t, n, readVarUint8Array(e))
                })(e, t, n);
                break;
            case 1:
                readSyncStep2(e, n, o);
                break;
            case 2:
                Uc(e, n, o);
                break;
            default:
                throw new Error("Unknown message type")
        }
        return h
    },
    Fc = 3e4;
class Awareness extends Observable {
    constructor(e) {
        super(), this.doc = e, this.clientID = e.clientID, this.states = new Map, this.meta = new Map, this._checkInterval = setInterval((() => {
            const e = nc();
            null !== this.getLocalState() && 15e3 <= e - this.meta.get(this.clientID).lastUpdated && this.setLocalState(this.getLocalState());
            const t = [];
            this.meta.forEach(((n, o) => {
                o !== this.clientID && Fc <= e - n.lastUpdated && this.states.has(o) && t.push(o)
            })), t.length > 0 && removeAwarenessStates(this, t, "timeout")
        }), Al(3e3)), e.on("destroy", (() => {
            this.destroy()
        })), this.setLocalState({})
    }
    destroy() {
        this.emit("destroy", [this]), this.setLocalState(null), super.destroy(), clearInterval(this._checkInterval)
    }
    getLocalState() {
        return this.states.get(this.clientID) || null
    }
    setLocalState(e) {
        const t = this.clientID,
            n = this.meta.get(t),
            o = void 0 === n ? 0 : n.clock + 1,
            h = this.states.get(t);
        null === e ? this.states.delete(t) : this.states.set(t, e), this.meta.set(t, {
            clock: o,
            lastUpdated: nc()
        });
        const p = [],
            f = [],
            g = [],
            y = [];
        null === e ? y.push(t) : null == h ? null != e && p.push(t) : (f.push(t), equalityDeep(h, e) || g.push(t)), (p.length > 0 || g.length > 0 || y.length > 0) && this.emit("change", [{
            added: p,
            updated: g,
            removed: y
        }, "local"]), this.emit("update", [{
            added: p,
            updated: f,
            removed: y
        }, "local"])
    }
    setLocalStateField(e, t) {
        const n = this.getLocalState();
        null !== n && this.setLocalState({ ...n,
            [e]: t
        })
    }
    getStates() {
        return this.states
    }
}
const removeAwarenessStates = (e, t, n) => {
        const o = [];
        for (let n = 0; n < t.length; n++) {
            const h = t[n];
            if (e.states.has(h)) {
                if (e.states.delete(h), h === e.clientID) {
                    const t = e.meta.get(h);
                    e.meta.set(h, {
                        clock: t.clock + 1,
                        lastUpdated: nc()
                    })
                }
                o.push(h)
            }
        }
        o.length > 0 && (e.emit("change", [{
            added: [],
            updated: [],
            removed: o
        }, n]), e.emit("update", [{
            added: [],
            updated: [],
            removed: o
        }, n]))
    },
    encodeAwarenessUpdate = (e, t, n = e.states) => {
        const o = t.length,
            h = createEncoder();
        writeVarUint(h, o);
        for (let p = 0; p < o; p++) {
            const o = t[p],
                f = n.get(o) || null,
                g = e.meta.get(o).clock;
            writeVarUint(h, o), writeVarUint(h, g), Ul(h, JSON.stringify(f))
        }
        return toUint8Array(h)
    },
    Gc = [];
Gc[0] = (e, t, n, o, h) => {
    writeVarUint(e, 0);
    const p = readSyncMessage(t, e, n.doc, n);
    o && 1 === p && !n.synced && (n.synced = !0)
}, Gc[3] = (e, t, n, o, h) => {
    writeVarUint(e, 1), writeVarUint8Array(e, encodeAwarenessUpdate(n.awareness, Array.from(n.awareness.getStates().keys())))
}, Gc[1] = (e, t, n, o, h) => {
    ((e, t, n) => {
        const o = createDecoder(t),
            h = nc(),
            p = [],
            f = [],
            g = [],
            y = [],
            w = readVarUint(o);
        for (let t = 0; t < w; t++) {
            const t = readVarUint(o);
            let n = readVarUint(o);
            const w = JSON.parse(Kl(o)),
                b = e.meta.get(t),
                S = e.states.get(t),
                k = void 0 === b ? 0 : b.clock;
            (k < n || k === n && null === w && e.states.has(t)) && (null === w ? t === e.clientID && null != e.getLocalState() ? n++ : e.states.delete(t) : e.states.set(t, w), e.meta.set(t, {
                clock: n,
                lastUpdated: h
            }), void 0 === b && null !== w ? p.push(t) : void 0 !== b && null === w ? y.push(t) : null !== w && (equalityDeep(w, S) || g.push(t), f.push(t)))
        }(p.length > 0 || g.length > 0 || y.length > 0) && e.emit("change", [{
            added: p,
            updated: g,
            removed: y
        }, n]), (p.length > 0 || f.length > 0 || y.length > 0) && e.emit("update", [{
            added: p,
            updated: f,
            removed: y
        }, n])
    })(n.awareness, readVarUint8Array(t), n)
}, Gc[2] = (e, t, n, o, h) => {
    ((e, t, n) => {
        0 === readVarUint(e) && n(t, Kl(e))
    })(t, n.doc, ((e, t) => permissionDeniedHandler(n, t)))
};
const permissionDeniedHandler = (e, t) => console.warn(`Permission denied to access ${e.url}.\n${t}`),
    readMessage = (e, t, n) => {
        const o = createDecoder(t),
            h = createEncoder(),
            p = readVarUint(o),
            f = e.messageHandlers[p];
        return f ? f(h, o, e, n, p) : console.error("Unable to compute message"), h
    },
    closeWebsocketConnection = (e, t, n) => {
        t === e.ws && (e.emit("connection-close", [n, e]), e.ws = null, t.close(), e.wsconnecting = !1, e.wsconnected ? (e.wsconnected = !1, e.synced = !1, removeAwarenessStates(e.awareness, Array.from(e.awareness.getStates().keys()).filter((t => t !== e.doc.clientID)), e), e.emit("status", [{
            status: "disconnected"
        }])) : e.wsUnsuccessfulReconnects++, setTimeout(setupWS, min(100 * Rl(2, e.wsUnsuccessfulReconnects), e.maxBackoffTime), e))
    },
    setupWS = e => {
        if (e.shouldConnect && null === e.ws) {
            const t = new e._WS(e.url, e.protocols);
            t.binaryType = "arraybuffer", e.ws = t, e.wsconnecting = !0, e.wsconnected = !1, e.synced = !1, t.onmessage = n => {
                e.wsLastMessageReceived = nc();
                const o = readMessage(e, new Uint8Array(n.data), !0);
                length$1(o) > 1 && t.send(toUint8Array(o))
            }, t.onerror = t => {
                e.emit("connection-error", [t, e])
            }, t.onclose = n => {
                closeWebsocketConnection(e, t, n)
            }, t.onopen = () => {
                e.wsLastMessageReceived = nc(), e.wsconnecting = !1, e.wsconnected = !0, e.wsUnsuccessfulReconnects = 0, e.emit("status", [{
                    status: "connected"
                }]);
                const n = createEncoder();
                if (writeVarUint(n, 0), writeSyncStep1(n, e.doc), t.send(toUint8Array(n)), null !== e.awareness.getLocalState()) {
                    const n = createEncoder();
                    writeVarUint(n, 1), writeVarUint8Array(n, encodeAwarenessUpdate(e.awareness, [e.doc.clientID])), t.send(toUint8Array(n))
                }
            }, e.emit("status", [{
                status: "connecting"
            }])
        }
    },
    broadcastMessage = (e, t) => {
        const n = e.ws;
        e.wsconnected && n && n.readyState === n.OPEN && n.send(t), e.bcconnected && publish(e.bcChannel, t, e)
    };
class WebsocketProvider extends ObservableV2 {
    constructor(e, t, n, {
        connect: o = !0,
        awareness: h = new Awareness(n),
        params: p = {},
        protocols: f = [],
        WebSocketPolyfill: g = WebSocket,
        resyncInterval: y = -1,
        maxBackoffTime: w = 2500,
        disableBc: b = !1
    } = {}) {
        for (super();
            "/" === e[e.length - 1];) e = e.slice(0, e.length - 1);
        this.serverUrl = e, this.bcChannel = e + "/" + t, this.maxBackoffTime = w, this.params = p, this.protocols = f, this.roomname = t, this.doc = n, this._WS = g, this.awareness = h, this.wsconnected = !1, this.wsconnecting = !1, this.bcconnected = !1, this.disableBc = b, this.wsUnsuccessfulReconnects = 0, this.messageHandlers = Gc.slice(), this._synced = !1, this.ws = null, this.wsLastMessageReceived = 0, this.shouldConnect = o, this._resyncInterval = 0, y > 0 && (this._resyncInterval = setInterval((() => {
            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                const e = createEncoder();
                writeVarUint(e, 0), writeSyncStep1(e, n), this.ws.send(toUint8Array(e))
            }
        }), y)), this._bcSubscriber = (e, t) => {
            if (t !== this) {
                const t = readMessage(this, new Uint8Array(e), !1);
                length$1(t) > 1 && publish(this.bcChannel, toUint8Array(t), this)
            }
        }, this._updateHandler = (e, t) => {
            if (t !== this) {
                const t = createEncoder();
                writeVarUint(t, 0), ((e, t) => {
                    writeVarUint(e, 2), writeVarUint8Array(e, t)
                })(t, e), broadcastMessage(this, toUint8Array(t))
            }
        }, this.doc.on("update", this._updateHandler), this._awarenessUpdateHandler = ({
            added: e,
            updated: t,
            removed: n
        }, o) => {
            const p = e.concat(t).concat(n),
                f = createEncoder();
            writeVarUint(f, 1), writeVarUint8Array(f, encodeAwarenessUpdate(h, p)), broadcastMessage(this, toUint8Array(f))
        }, this._exitHandler = () => {
            removeAwarenessStates(this.awareness, [n.clientID], "app closed")
        }, cc && "undefined" != typeof process && process.on("exit", this._exitHandler), h.on("update", this._awarenessUpdateHandler), this._checkInterval = setInterval((() => {
            this.wsconnected && 3e4 < nc() - this.wsLastMessageReceived && closeWebsocketConnection(this, this.ws, null)
        }), 3e3), o && this.connect()
    }
    get url() {
        const e = (e => ((e, t) => {
            const n = [];
            for (const o in e) n.push(t(e[o], o));
            return n
        })(e, ((e, t) => `${encodeURIComponent(t)}=${encodeURIComponent(e)}`)).join("&"))(this.params);
        return this.serverUrl + "/" + this.roomname + (0 === e.length ? "" : "?" + e)
    }
    get synced() {
        return this._synced
    }
    set synced(e) {
        this._synced !== e && (this._synced = e, this.emit("synced", [e]), this.emit("sync", [e]))
    }
    destroy() {
        0 !== this._resyncInterval && clearInterval(this._resyncInterval), clearInterval(this._checkInterval), this.disconnect(), cc && "undefined" != typeof process && process.off("exit", this._exitHandler), this.awareness.off("update", this._awarenessUpdateHandler), this.doc.off("update", this._updateHandler), super.destroy()
    }
    connectBc() {
        if (this.disableBc) return;
        var e, t;
        this.bcconnected || (e = this.bcChannel, t = this._bcSubscriber, getChannel(e).subs.add(t), this.bcconnected = !0);
        const n = createEncoder();
        writeVarUint(n, 0), writeSyncStep1(n, this.doc), publish(this.bcChannel, toUint8Array(n), this);
        const o = createEncoder();
        writeVarUint(o, 0), writeSyncStep2(o, this.doc), publish(this.bcChannel, toUint8Array(o), this);
        const h = createEncoder();
        writeVarUint(h, 3), publish(this.bcChannel, toUint8Array(h), this);
        const p = createEncoder();
        writeVarUint(p, 1), writeVarUint8Array(p, encodeAwarenessUpdate(this.awareness, [this.doc.clientID])), publish(this.bcChannel, toUint8Array(p), this)
    }
    disconnectBc() {
        const e = createEncoder();
        writeVarUint(e, 1), writeVarUint8Array(e, encodeAwarenessUpdate(this.awareness, [this.doc.clientID], new Map)), broadcastMessage(this, toUint8Array(e)), this.bcconnected && (((e, t) => {
            const n = getChannel(e),
                o = n.subs.delete(t);
            o && 0 === n.subs.size && (n.bc.close(), jc.delete(e))
        })(this.bcChannel, this._bcSubscriber), this.bcconnected = !1)
    }
    disconnect() {
        this.shouldConnect = !1, this.disconnectBc(), null !== this.ws && closeWebsocketConnection(this, this.ws, null)
    }
    connect() {
        this.shouldConnect = !0, this.wsconnected || null !== this.ws || (setupWS(this), this.connectBc())
    }
}

function lib0Pair_Module() {
    var e = class {
        constructor(e, t) {
            this.left = e, this.right = t
        }
    };
    return {
        Pair: e,
        create: (t, n) => new e(t, n),
        createReversed: (t, n) => new e(n, t),
        forEach: (e, t) => e.forEach((e => t(e.left, e.right))),
        map: (e, t) => e.map((e => t(e.left, e.right)))
    }
}

function lib0Dom_Module() {
    let e = lib0Pair_Module(),
        t = function() {
            var s = () => new Map;
            return {
                all: (e, t) => {
                    for (let [n, o] of e)
                        if (!t(o, n)) return !1;
                    return !0
                },
                any: (e, t) => {
                    for (let [n, o] of e)
                        if (t(o, n)) return !0;
                    return !1
                },
                copy: e => {
                    let t = s();
                    return e.forEach(((e, n) => {
                        t.set(n, e)
                    })), t
                },
                create: s,
                map: (e, t) => {
                    let n = [];
                    for (let [o, h] of e) n.push(t(h, o));
                    return n
                },
                setIfUndefined: (e, t, n) => {
                    let o = e.get(t);
                    return void 0 === o && e.set(t, o = n()), o
                }
            }
        }();
    var n = typeof document < "u" ? document : {},
        c = e => n.createElement(e),
        x = () => n.createDocumentFragment(),
        m = e => n.createTextNode(e),
        o = typeof DOMParser < "u" ? new DOMParser : null,
        d = (t, n) => (e.forEach(n, ((e, n) => {
            !1 === n ? t.removeAttribute(e) : !0 === n ? t.setAttribute(e, "") : t.setAttribute(e, n)
        })), t),
        E = e => {
            let t = x();
            for (let n = 0; n < e.length; n++) i(t, e[n]);
            return t
        },
        l = (e, t) => (i(e, E(t)), e),
        T = (e, t, n) => e.addEventListener(t, n),
        O = (e, t, n) => e.removeEventListener(t, n),
        h = m,
        u = e => `${e.left}:${e.right};`,
        a = e => o.parseFromString(`<html><body>${e}</body></html>`, "text/html").body,
        i = (e, t) => e.appendChild(t),
        p = n.ELEMENT_NODE,
        f = n.TEXT_NODE,
        g = n.CDATA_SECTION_NODE,
        y = n.COMMENT_NODE,
        w = n.DOCUMENT_NODE,
        b = n.DOCUMENT_TYPE_NODE;
    return {
        CDATA_SECTION_NODE: g,
        COMMENT_NODE: y,
        DOCUMENT_FRAGMENT_NODE: n.DOCUMENT_FRAGMENT_NODE,
        DOCUMENT_NODE: w,
        DOCUMENT_TYPE_NODE: b,
        ELEMENT_NODE: p,
        TEXT_NODE: f,
        addEventListener: T,
        addEventListeners: (t, n) => (e.forEach(n, ((e, n) => T(t, e, n))), t),
        append: l,
        appendChild: i,
        canvas: (e, t) => {
            let n = c("canvas");
            return n.height = t, n.width = e, n
        },
        checkNodeType: (e, t) => e.nodeType === t,
        createDocumentFragment: x,
        createElement: c,
        createTextNode: m,
        doc: n,
        domParser: o,
        element: (e, t = [], n = []) => l(d(c(e), t), n),
        emitCustomEvent: (e, t, n) => e.dispatchEvent(new CustomEvent(t, n)),
        fragment: E,
        getElementById: e => n.getElementById(e),
        insertBefore: (e, t, n) => e.insertBefore(t, n),
        isParentOf: (e, t) => {
            let n = t.parentNode;
            for (; n && n !== e;) n = n.parentNode;
            return n === e
        },
        mapToStyleString: e => t.map(e, ((e, t) => `${t}:${e};`)).join(""),
        pairToStyleString: u,
        pairsToStyleString: e => e.map(u).join(""),
        parseElement: e => a(e).firstElementChild,
        parseFragment: e => E(a(e).childNodes),
        querySelector: (e, t) => e.querySelector(t),
        querySelectorAll: (e, t) => e.querySelectorAll(t),
        remove: e => e.remove(),
        removeEventListener: O,
        removeEventListeners: (t, n) => (e.forEach(n, ((e, n) => O(t, e, n))), t),
        replaceWith: (e, t) => e.replaceWith(t),
        setAttributes: d,
        setAttributesMap: (e, t) => (t.forEach(((t, n) => {
            e.setAttribute(n, t)
        })), e),
        text: h
    }
}
window.Yjs = Yc, window.CM = {}, CM["@codemirror/state"] = Z, CM["@codemirror/view"] = Rn;
let Hc, {
    yCollab: Kc
} = function() {
    let e = Yc,
        t = CM["@codemirror/view"],
        n = Yc;
    var o = class r {
        constructor(e, t) {
            this.yanchor = e, this.yhead = t
        }
        toJSON() {
            return {
                yanchor: n.relativePositionToJSON(this.yanchor),
                yhead: n.relativePositionToJSON(this.yhead)
            }
        }
        static fromJSON(e) {
            return new r(n.createRelativePositionFromJSON(e.yanchor), n.createRelativePositionFromJSON(e.yhead))
        }
    };
    let h = Yc,
        p = CM["@codemirror/state"],
        f = CM["@codemirror/view"];
    var g = class {
            constructor(e, t) {
                this.ytext = e, this.awareness = t, this.undoManager = new h.UndoManager(e)
            }
            toYPos(e, t = 0) {
                return h.createRelativePositionFromTypeIndex(this.ytext, e, t)
            }
            fromYPos(e) {
                let t = h.createAbsolutePositionFromRelativePosition(h.createRelativePositionFromJSON(e), this.ytext.doc);
                if (null == t || t.type !== this.ytext) throw new Error("[y-codemirror] The position you want to retrieve was created by a different document");
                return {
                    pos: t.index,
                    assoc: t.assoc
                }
            }
            toYRange(e) {
                let t = e.assoc,
                    n = this.toYPos(e.anchor, t),
                    h = this.toYPos(e.head, t);
                return new o(n, h)
            }
            fromYRange(e) {
                let t = this.fromYPos(e.yanchor),
                    n = this.fromYPos(e.yhead);
                return t.pos === n.pos ? p.EditorSelection.cursor(n.pos, n.assoc) : p.EditorSelection.range(t.pos, n.pos)
            }
        },
        y = p.Facet.define({
            combine: e => e[e.length - 1]
        }),
        w = p.Annotation.define(),
        b = f.ViewPlugin.fromClass(class {
            constructor(e) {
                this.view = e, this.conf = e.state.facet(y), this._observer = (t, n) => {
                    if (n.origin !== this.conf) {
                        let n = t.delta,
                            o = [],
                            h = 0;
                        for (let e = 0; e < n.length; e++) {
                            let t = n[e];
                            null != t.insert ? o.push({
                                from: h,
                                to: h,
                                insert: t.insert
                            }) : null != t.delete ? (o.push({
                                from: h,
                                to: h + t.delete,
                                insert: ""
                            }), h += t.delete) : h += t.retain
                        }
                        e.dispatch({
                            changes: o,
                            annotations: [w.of(this.conf)]
                        })
                    }
                }, this._ytext = this.conf.ytext, this._ytext.observe(this._observer)
            }
            update(e) {
                if (!e.docChanged || e.transactions.length > 0 && e.transactions[0].annotation(w) === this.conf) return;
                let t = this.conf.ytext;
                t.doc.transact((() => {
                    let n = 0;
                    e.changes.iterChanges(((e, o, h, p, f) => {
                        let g = f.sliceString(0, f.length, "\n");
                        e !== o && t.delete(e + n, o - e), g.length > 0 && t.insert(e + n, g), n += g.length - (o - e)
                    }))
                }), this.conf)
            }
            destroy() {
                this._ytext.unobserve(this._observer)
            }
        });
    let S = CM["@codemirror/view"],
        k = CM["@codemirror/state"],
        v = lib0Dom_Module(),
        P = lib0Pair_Module(),
        C = (Q = Math.floor, $ = Math.ceil, A = Math.abs, M = Math.imul, R = Math.round, D = Math.log10, L = Math.log2, V = Math.log, Z = Math.sqrt, {
            abs: A,
            add: (e, t) => e + t,
            ceil: $,
            exp10: e => Math.pow(10, e),
            floor: Q,
            imul: M,
            isNaN: Number.isNaN,
            isNegativeZero: e => 0 !== e ? e < 0 : 1 / e < 0,
            log: V,
            log10: D,
            log2: L,
            max: (e, t) => e > t ? e : t,
            min: (e, t) => e < t ? e : t,
            pow: Math.pow,
            round: R,
            sign: Math.sign,
            sqrt: Z
        });
    var Q, $, A, M, R, D, L, V, Z;
    let _ = Yc;
    var B = S.EditorView.baseTheme({
            ".cm-ySelection": {},
            ".cm-yLineSelection": {
                padding: 0,
                margin: "0px 2px 0px 4px"
            },
            ".cm-ySelectionCaret": {
                position: "relative",
                borderLeft: "1px solid black",
                borderRight: "1px solid black",
                marginLeft: "-1px",
                marginRight: "-1px",
                boxSizing: "border-box",
                display: "inline"
            },
            ".cm-ySelectionCaretDot": {
                borderRadius: "50%",
                position: "absolute",
                width: ".4em",
                height: ".4em",
                top: "-.2em",
                left: "-.2em",
                backgroundColor: "inherit",
                transition: "transform .3s ease-in-out",
                boxSizing: "border-box"
            },
            ".cm-ySelectionCaret:hover > .cm-ySelectionCaretDot": {
                transformOrigin: "bottom center",
                transform: "scale(0)"
            },
            ".cm-ySelectionInfo": {
                position: "absolute",
                top: "-1.05em",
                left: "-1px",
                fontSize: ".75em",
                fontFamily: "serif",
                fontStyle: "normal",
                fontWeight: "normal",
                lineHeight: "normal",
                userSelect: "none",
                color: "white",
                paddingLeft: "2px",
                paddingRight: "2px",
                zIndex: 101,
                transition: "opacity .3s ease-in-out",
                backgroundColor: "inherit",
                opacity: 0,
                transitionDelay: "0s",
                whiteSpace: "nowrap"
            },
            ".cm-ySelectionCaret:hover > .cm-ySelectionInfo": {
                opacity: 1,
                transitionDelay: "0s"
            }
        }),
        I = k.Annotation.define(),
        X = class extends S.WidgetType {
            constructor(e, t) {
                super(), this.color = e, this.name = t
            }
            toDOM() {
                return v.element("span", [P.create("class", "cm-ySelectionCaret"), P.create("style", `background-color: ${this.color}; border-color: ${this.color}`)], [v.text("â "), v.element("div", [P.create("class", "cm-ySelectionCaretDot")]), v.text("â "), v.element("div", [P.create("class", "cm-ySelectionInfo")], [v.text(this.name)]), v.text("â ")])
            }
            eq(e) {
                return e.color === this.color
            }
            compare(e) {
                return e.color === this.color
            }
            updateDOM() {
                return !1
            }
            get estimatedHeight() {
                return -1
            }
            ignoreEvent() {
                return !0
            }
        },
        q = S.ViewPlugin.fromClass(class {
            constructor(e) {
                this.conf = e.state.facet(y), this._listener = ({
                    added: t,
                    updated: n,
                    removed: o
                }, h, p) => {
                    t.concat(n).concat(o).findIndex((e => e !== this.conf.awareness.doc.clientID)) >= 0 && e.dispatch({
                        annotations: [I.of([])]
                    })
                }, this._awareness = this.conf.awareness, this._awareness.on("change", this._listener), this.decorations = k.RangeSet.of([])
            }
            destroy() {
                this._awareness.off("change", this._listener)
            }
            update(e) {
                let t = this.conf.ytext,
                    n = t.doc,
                    o = this.conf.awareness,
                    h = [],
                    p = this.conf.awareness.getLocalState();
                if (null != p) {
                    let n = e.view.hasFocus && e.view.dom.ownerDocument.hasFocus(),
                        h = n ? e.state.selection.main : null,
                        f = null == p.cursor ? null : _.createRelativePositionFromJSON(p.cursor.anchor),
                        g = null == p.cursor ? null : _.createRelativePositionFromJSON(p.cursor.head);
                    if (null != h) {
                        let e = _.createRelativePositionFromTypeIndex(t, h.anchor),
                            n = _.createRelativePositionFromTypeIndex(t, h.head);
                        (null == p.cursor || !_.compareRelativePositions(f, e) || !_.compareRelativePositions(g, n)) && o.setLocalStateField("cursor", {
                            anchor: e,
                            head: n
                        })
                    } else null != p.cursor && n && o.setLocalStateField("cursor", null)
                }
                o.getStates().forEach(((p, f) => {
                    if (f === o.doc.clientID) return;
                    let g = p.cursor;
                    if (null == g || null == g.anchor || null == g.head) return;
                    let y = _.createAbsolutePositionFromRelativePosition(g.anchor, n),
                        w = _.createAbsolutePositionFromRelativePosition(g.head, n);
                    if (null == y || null == w || y.type !== t || w.type !== t) return;
                    let {
                        color: b = "#30bced",
                        name: k = "Anonymous"
                    } = p.user || {}, v = p.user && p.user.colorLight || b + "33", P = C.min(y.index, w.index), Q = C.max(y.index, w.index), $ = e.view.state.doc.lineAt(P), A = e.view.state.doc.lineAt(Q);
                    if ($.number === A.number) h.push({
                        from: P,
                        to: Q,
                        value: S.Decoration.mark({
                            attributes: {
                                style: `background-color: ${v}`
                            },
                            class: "cm-ySelection"
                        })
                    });
                    else {
                        h.push({
                            from: P,
                            to: $.from + $.length,
                            value: S.Decoration.mark({
                                attributes: {
                                    style: `background-color: ${v}`
                                },
                                class: "cm-ySelection"
                            })
                        }), h.push({
                            from: A.from,
                            to: Q,
                            value: S.Decoration.mark({
                                attributes: {
                                    style: `background-color: ${v}`
                                },
                                class: "cm-ySelection"
                            })
                        });
                        for (let t = $.number + 1; t < A.number; t++) {
                            let n = e.view.state.doc.line(t).from;
                            h.push({
                                from: n,
                                to: n,
                                value: S.Decoration.line({
                                    attributes: {
                                        style: `background-color: ${v}`,
                                        class: "cm-yLineSelection"
                                    }
                                })
                            })
                        }
                    }
                    h.push({
                        from: w.index,
                        to: w.index,
                        value: S.Decoration.widget({
                            side: w.index - y.index > 0 ? -1 : 1,
                            block: !1,
                            widget: new X(b, k)
                        })
                    })
                })), this.decorations = S.Decoration.set(h, !0)
            }
        }, {
            decorations: e => e.decorations
        });
    let z = CM["@codemirror/state"],
        N = CM["@codemirror/view"];
    var Y = class {
            constructor(e) {
                this.undoManager = e
            }
            addTrackedOrigin(e) {
                this.undoManager.addTrackedOrigin(e)
            }
            removeTrackedOrigin(e) {
                this.undoManager.removeTrackedOrigin(e)
            }
            undo() {
                return null != this.undoManager.undo()
            }
            redo() {
                return null != this.undoManager.redo()
            }
        },
        j = z.Facet.define({
            combine: e => e[e.length - 1]
        });
    z.Annotation.define();
    var W = N.ViewPlugin.fromClass(class {
            constructor(e) {
                this.view = e, this.conf = e.state.facet(j), this._undoManager = this.conf.undoManager, this.syncConf = e.state.facet(y), this._beforeChangeSelection = null, this._mux = (() => {
                    let e = !0;
                    return (t, n) => {
                        if (e) {
                            e = !1;
                            try {
                                t()
                            } finally {
                                e = !0
                            }
                        } else void 0 !== n && n()
                    }
                })(), this._onStackItemAdded = ({
                    stackItem: e,
                    changedParentTypes: t
                }) => {
                    t.has(this.syncConf.ytext) && this._beforeChangeSelection && !e.meta.has(this) && e.meta.set(this, this._beforeChangeSelection)
                }, this._onStackItemPopped = ({
                    stackItem: t
                }) => {
                    let n = t.meta.get(this);
                    if (n) {
                        let t = this.syncConf.fromYRange(n);
                        e.dispatch(e.state.update({
                            selection: t,
                            effects: [N.EditorView.scrollIntoView(t)]
                        })), this._storeSelection()
                    }
                }, this._storeSelection = () => {
                    this._beforeChangeSelection = this.syncConf.toYRange(this.view.state.selection.main)
                }, this._undoManager.on("stack-item-added", this._onStackItemAdded), this._undoManager.on("stack-item-popped", this._onStackItemPopped), this._undoManager.addTrackedOrigin(this.syncConf)
            }
            update(e) {
                e.selectionSet && (0 === e.transactions.length || e.transactions[0].annotation(w) !== this.syncConf) && this._storeSelection()
            }
            destroy() {
                this._undoManager.off("stack-item-added", this._onStackItemAdded), this._undoManager.off("stack-item-popped", this._onStackItemPopped), this._undoManager.removeTrackedOrigin(this.syncConf)
            }
        }),
        U = ({
            state: e,
            dispatch: t
        }) => e.facet(j).undo() || !0,
        F = ({
            state: e,
            dispatch: t
        }) => e.facet(j).redo() || !0;
    return {
        YRange: o,
        YSyncConfig: g,
        yCollab: (n, o, {
            undoManager: h = new e.UndoManager(n)
        } = {}) => {
            let p = new g(n, o),
                f = [y.of(p), b];
            return o && f.push(B, q), !1 !== h && f.push(j.of(new Y(h)), W, t.EditorView.domEventHandlers({
                beforeinput: (e, t) => "historyUndo" === e.inputType ? U(t) : "historyRedo" === e.inputType && F(t)
            })), f
        },
        yRemoteSelections: q,
        yRemoteSelectionsTheme: B,
        ySync: b,
        ySyncFacet: y,
        yUndoManagerKeymap: [{
            key: "Mod-z",
            run: U,
            preventDefault: !0
        }, {
            key: "Mod-y",
            mac: "Mod-Shift-z",
            run: F,
            preventDefault: !0
        }, {
            key: "Mod-Shift-z",
            run: F,
            preventDefault: !0
        }]
    }
}();

function createFunctionFinderExtension({
    yText: e,
    docId: t
} = {}) {
    class FunctionButton extends WidgetType {
        constructor(e, t, n, o) {
            super(), this.pos = e, this.functionPos = t, this.foundInDocId = n, this.functionName = o
        }
        toDOM() {
            const e = document.createElement("button");
            return e.textContent = "ðŸ”Ž", e.className = "function-popup-open-button", e.onmousedown = () => {
                setTimeout((() => this.showPopup()), 10)
            }, e
        }
        showPopup() {
            createPopupEditor({
                position: this.functionPos,
                docId: this.foundInDocId,
                title: this.functionName
            })
        }
    }
    const n = ViewPlugin.fromClass(class {
            constructor(e) {}
            destroy() {}
        }),
        o = StateField.define({
            create: () => Decoration.none,
            update: (e, t) => {
                if (!t.selection) return e;
                const n = t.state.sliceDoc(t.state.selection.main.from, t.state.selection.main.to);
                for (let e of ["modelText", "outputTemplate"]) {
                    const o = window.docIdToView[e].state;
                    if (!n || !n.trim()) return Decoration.none;
                    if (n.includes("\n")) return Decoration.none;
                    let h, p = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                    try {
                        let t = [`(window.|globalThis.|self.|let\\s+|const\\s+|var\\s+)${p}\\s*=\\s*(async\\s+|)function\\s*\\(.*?\\)\\s*\\{`, `(window|globalThis|self)\\[['"\`]${p}['"\`]\\]\\s*=\\s*(async\\s+|)function\\s*\\(.*?\\)\\s*\\{`, `(window.|globalThis.|self.|let\\s+|const\\s+|var\\s+)${p}\\s*=(\\s*async\\s*|\\s*)(\\(.*?\\)|[a-zA-Z0-9_]+)\\s*=>`, `(window|globalThis|self)\\[['"\`]${p}['"\`]\\]\\s*=(\\s*async\\s*|\\s*)(\\(.*?\\)|[a-zA-Z0-9_]+)\\s*=>\\s*\\{`];
                        "outputTemplate" === e && (h = o.doc.toString().match(new RegExp(`(${t.join("|")}|function\\s+${p}\\s*\\(.*?\\)\\s*\\{)`))), "modelText" === e && (h = o.doc.toString().match(new RegExp(`(${t.join("|")}|(\\n\\s*|^)(async\\s+|)${p}\\s*\\(.*?\\)\\s*=>)`)))
                    } catch (e) {
                        console.error(e)
                    }
                    if (h) return Decoration.set([{
                        from: t.state.selection.main.from,
                        to: t.state.selection.main.from,
                        value: Decoration.widget({
                            widget: new FunctionButton(t.state.selection.main.from, h.index, e, p)
                        })
                    }])
                }
                return Decoration.none
            },
            provide: e => EditorView.decorations.from(e)
        });
    return [o, n, EditorView.baseTheme({
        "&": {
            position: "relative"
        },
        ".function-popup-open-button": {
            position: "absolute",
            cursor: "pointer",
            fontSize: "10px",
            marginTop: "-20px",
            opacity: "0.5",
            "&:hover": {
                opacity: "1"
            }
        }
    })]
}
window.createPopupEditor = function({
    docId: e,
    position: t,
    title: n,
    onClose: o
}) {
    const h = "function-finder-popup-styles-892734";
    if (!document.getElementById(h)) {
        const e = document.createElement("style");
        e.id = h, e.textContent = "\n      .function-popup { display:flex; flex-direction:column; position: fixed; top: 20%; left: 20%; background: light-dark(white, #1a1a1a); border: 1px solid light-dark(#ccc, #333); border-radius: 4px; box-shadow: 0 2px 10px light-dark(rgba(0,0,0,0.1), rgba(0,0,0,0.3)); width:750px; height:450px; max-width:95vw; max-height: 95vh; }\n      .popup-header { padding: 4px; background: light-dark(#f5f5f5, #2a2a2a); border-bottom: 1px solid light-dark(#ccc, #333); display: flex; justify-content: space-between; cursor: move; }\n      .popup-close { background: none; border: none; font-size: 18px; cursor: pointer; color: light-dark(#666, #999); }\n      .popup-editor { position:relative; flex-grow:1; width:100%; min-height:0; }\n      .popup-resize-handle { z-index:1000; position: absolute; right: 0; bottom: 0; width: 12px; height: 12px; cursor: nwse-resize; background: linear-gradient( 135deg, transparent 0%, transparent 50%, light-dark(#666, #999) 50%, light-dark(#666, #999) 100%); }\n      .popup-edit-title-btn { opacity:0.6; }\n      .popup-edit-title-btn:hover { opacity:1; }\n    ", document.head.appendChild(e)
    }
    const p = document.createElement("div");
    p.className = "function-popup", p.style.zIndex = function() {
        const e = [...document.querySelectorAll(".function-popup")];
        return 0 === e.length ? 1e3 : e.reduce(((e, t) => Math.max(Number(t.style.zIndex), e)), -1 / 0) + 1
    }(), p.innerHTML = '\n    <div class="popup-header" style="user-select:none;">\n      <span class="popup-edit-title-btn" style="cursor:pointer; display:inline-flex ; align-items:center; justify-content:center; font-size:80%;">âœï¸</span>\n      <span class="popup-title" title="Double-tap here to toggle minimized view" style="pointer-events:none; opacity:0.8; display:inline-flex; align-items:center; margin-right:auto; margin-left:0.5rem; font-size:107%; white-space:nowrap; overflow:hidden;"></span>\n      <button class="popup-close">Ã—</button>\n    </div>\n    <div class="popup-editor"></div>\n  ', document.body.appendChild(p);
    const f = function(e) {
        let t = 0;
        const n = e.offsetTop,
            o = e.offsetLeft,
            h = [...document.querySelectorAll(".function-popup")].filter((t => t !== e)).map((e => ({
                offsetTop: e.offsetTop,
                offsetLeft: e.offsetLeft
            })));
        for (; h.some((e => e.offsetTop === n + t && e.offsetLeft === o + t));) t += 20;
        return t
    }(p);
    p.style.top = `${p.offsetTop+f}px`, p.style.left = `${p.offsetLeft+f}px`;
    let g = {
        title: n ? ? (Math.random() < .5 ? "Click & drag to move" : "Double-tap to minimize"),
        offsetWidth: p.offsetWidth,
        offsetHeight: p.offsetHeight,
        offsetTop: p.offsetTop,
        offsetLeft: p.offsetLeft,
        minimized: !1
    };
    p.querySelector(".popup-header .popup-edit-title-btn").addEventListener("click", (e => {
        e.stopPropagation();
        let t = window.prompt("Enter a new popup title:", g.title);
        null !== t && (g.title = t, p.querySelector(".popup-title").textContent = g.title)
    })), p.querySelector(".popup-title").textContent = g.title;
    const y = document.createElement("div");
    y.className = "popup-resize-handle", p.appendChild(y);
    const w = p.querySelector(".popup-header"),
        b = p.querySelector(".popup-editor");
    let S = !1,
        k = !1,
        v = {
            x: 0,
            y: 0
        },
        P = {
            width: 0,
            height: 0
        },
        C = {
            x: 0,
            y: 0
        };

    function handleWindowResize() {
        const e = p.getBoundingClientRect(),
            t = .8 * -e.width,
            n = window.innerWidth - .2 * e.width,
            o = window.innerHeight - .2 * e.height;
        let h = e.left,
            f = e.top,
            g = Math.min(Math.max(t, h), n),
            y = Math.min(Math.max(0, f), o);
        g === h && y === f || (p.style.left = `${g}px`, p.style.top = `${y}px`)
    }
    const move = e => {
            if (S) {
                e.preventDefault();
                const t = p.getBoundingClientRect();
                let n = e.clientX - v.x,
                    o = e.clientY - v.y;
                const h = .8 * -t.width,
                    f = window.innerWidth - .2 * t.width,
                    g = 0,
                    y = window.innerHeight - .2 * t.height;
                n = Math.min(Math.max(h, n), f), o = Math.min(Math.max(g, o), y), p.style.left = `${n}px`, p.style.top = `${o}px`
            } else if (k) {
                e.preventDefault();
                const t = e.clientX - C.x,
                    n = e.clientY - C.y;
                p.style.width = `${Math.max(200,P.width+t)}px`, p.style.height = `${Math.max(100,P.height+n)}px`
            }
        },
        end = () => {
            S = !1, k = !1, g.offsetTop = p.offsetTop, g.offsetLeft = p.offsetLeft, g.minimized || (g.offsetWidth = p.offsetWidth, g.offsetHeight = p.offsetHeight)
        };
    let Q;
    w.ondblclick = () => {
        g.minimized ? (p.style.width = g.offsetWidth + "px", p.style.height = g.offsetHeight + "px", b.style.display = "", y.style.display = "", g.minimized = !1) : (g.offsetWidth = p.offsetWidth, g.offsetHeight = p.offsetHeight, p.style.width = "280px", p.style.height = "auto", b.style.display = "none", y.style.display = "none", g.minimized = !0)
    }, p.onmousedown = () => {
        const e = [...document.querySelectorAll(".function-popup")],
            t = e.reduce(((e, t) => Math.max(Number(t.style.zIndex), e)), -1 / 0);
        if (p.style.zIndex = t + 1, t + 1 > 1100)
            for (let t of e) t.style.zIndex = Number(t.style.zIndex) - 1;
        const n = [...document.querySelectorAll(".cm-editor")],
            o = p.querySelector(".cm-editor");
        for (let e of n) e !== o && (e.style.pointerEvents = "none")
    }, p.onmouseup = () => {
        const e = [...document.querySelectorAll(".cm-editor")];
        for (let t of e) t.style.pointerEvents = "";
        end()
    }, w.onmousedown = e => {
        if (e.target !== w) return;
        S = !0;
        const t = p.getBoundingClientRect();
        v = {
            x: e.clientX - t.left,
            y: e.clientY - t.top
        }
    }, y.onmousedown = e => {
        if (e.target !== y) return;
        k = !0;
        const t = p.getBoundingClientRect();
        P = {
            width: t.width,
            height: t.height
        }, C = {
            x: e.clientX,
            y: e.clientY
        }, e.preventDefault()
    }, document.addEventListener("mousemove", move), document.addEventListener("mouseup", end), window.addEventListener("resize", handleWindowResize), p.querySelector(".popup-close").onclick = () => {
        p.remove(), Q.destroy(), document.removeEventListener("mousemove", move), document.removeEventListener("mouseup", end), window.removeEventListener("resize", handleWindowResize), o && o()
    };
    const $ = p.querySelector(".popup-editor");
    return "modelText" === e && (Q = createModelTextEditorView({
        parentElement: $,
        yText: window.yDoc.getText(e),
        docId: e
    })), "outputTemplate" === e && (Q = createOutputTemplateEditorView({
        parentElement: $,
        yText: window.yDoc.getText(e),
        docId: e
    })), Q.dispatch({
        selection: {
            anchor: t
        },
        scrollIntoView: !0
    }), setTimeout((() => {
        Q.scrollDOM.scrollTop += Q.scrollDOM.offsetHeight / 2
    }), 0), {
        popup: p,
        editorView: Q
    }
}, async function() {
    let [e, t] = await Promise.all([
        import (window.esLintImportUrl || "https://perchance.org/lib/eslint-linter-browserify-v9.14.0-bundle.mjs"),
        import (window.htmlparser2ImportUrl || "https://perchance.org/lib/htmlparser2-v9.1.0-bundle.mjs")
    ]);
    window.htmlparser2 = t, window.eslintInstances = {};
    for (let t of ["modelText", "outputTemplate"]) window.eslintInstances[t] = new e.Linter
}(); {
    function mapPos(e, t, n, o) {
        return n.line(e + o.line).from + t + (1 == e ? o.col - 1 : -1)
    }

    function translateDiagnostic(e, t, n) {
        let o = mapPos(e.line, e.column, t, n),
            h = {
                from: o,
                to: null != e.endLine && 1 != e.endColumn ? mapPos(e.endLine, e.endColumn, t, n) : o,
                message: e.message,
                source: e.ruleId ? "eslint:" + e.ruleId : "eslint",
                severity: 1 == e.severity ? "warning" : "error"
            };
        if (e.fix) {
            let {
                range: t,
                text: p
            } = e.fix, f = t[0] + n.pos - o, g = t[1] + n.pos - o;
            h.actions = [{
                name: "fix",
                apply(e, t) {
                    e.dispatch({
                        changes: {
                            from: t + f,
                            to: t + g,
                            insert: p
                        },
                        scrollIntoView: !0
                    })
                }
            }]
        }
        return h
    }

    function extractJavaScriptRegionsFromHtml(e) {
        const t = [];
        let n, o = -1,
            h = -1,
            p = "";

        function processAttributes(n, o) {
            for (const [h, p] of Object.entries(n))
                if (h.startsWith("on")) {
                    let n = e.indexOf(`${h}="${p}"`, o); - 1 === n && (n = e.indexOf(`${h}='${p}'`, o)), -1 !== n && t.push({
                        type: "attribute",
                        attributeName: h,
                        from: n + h.length + 2,
                        to: n + h.length + 2 + p.length,
                        code: p
                    })
                }
        }
        const f = new htmlparser2.Parser({
            onopentag(t, p) {
                "script" === t ? (n = p.type, o = f.startIndex, h = e.indexOf(">", o) + 1, processAttributes(p, o)) : processAttributes(p, f.startIndex)
            },
            ontext(e) {
                -1 !== o && (p += e)
            },
            onclosetag(f) {
                if ("script" === f && -1 !== o) {
                    const f = e.indexOf("</script", h);
                    t.push({
                        type: "script",
                        scriptType: n,
                        from: h,
                        to: f,
                        code: p.trim()
                    }), o = -1, h = -1, p = ""
                }
            }
        }, {
            xmlMode: !1,
            decodeEntities: !1,
            lowerCaseTags: !1,
            lowerCaseAttributeNames: !1,
            recognizeSelfClosing: !0
        });
        return f.write(e), f.end(), t.sort(((e, t) => e.from - t.from))
    }
    Hc = function(e, t = null) {
        return n => {
            if (!window.eslintInstances || !window.eslintInstances[e] || !window.htmlparser2) return [];
            let o = window.eslintInstances[e];
            const h = {
                languageOptions: {
                    globals: {},
                    parserOptions: {
                        ecmaVersion: 2022,
                        sourceType: "module"
                    }
                },
                rules: {}
            };
            let {
                state: p
            } = n, f = [], g = t.jsBlockRanges;
            !g && "html" === t.type && window.htmlparser2 && (g = extractJavaScriptRegionsFromHtml(p.doc.toString()));
            for (let {
                    from: e,
                    to: t,
                    type: n,
                    scriptType: y,
                    extraContext: w
                } of g) {
                if ("script" === n) {
                    if ("importmap" === y) continue;
                    if ("string" == typeof y && y.length > 0 && "text/javascript" !== y && "module" !== y) continue
                }
                let g = p.doc.lineAt(e),
                    b = {
                        line: g.number - 1,
                        col: e - g.from,
                        pos: e
                    },
                    S = p.sliceDoc(e, t);
                if ("square" === n) "missing_close" === w && (S += "[", b.pos -= 1, b.col -= 1);
                else if ("function" === n) {
                    let e = w.match(/^\s+/) ? .[0].length || 0;
                    if (S = w.trimStart() + S, S = /\s*async /.test(w) ? S.replace(/^async /, "").replace("(", "=async (") : S.replace("(", "=("), S = S.replace("=>", "=>{"), /(\s+|^)\/\/.*$/.test(S.trimEnd())) {
                        let e = S.trimEnd().split("\n");
                        S = e.length > 1 ? e.slice(0, -1).join("\n") + "\n" + e.at(-1).trimEnd().replace(/(\s+|^)\/\/.*$/, "") + "}" : e[0].trimEnd().replace(/(\s+|^)\/\/.*$/, "") + "}"
                    } else S = S.trimEnd() + "}";
                    b.pos -= 2, b.col = e - 2
                }
                h.languageOptions.parserOptions.sourceType = "script" === n && "module" === y ? "module" : "script";
                for (let e of o.verify(S, h)) f.push(translateDiagnostic(e, p.doc, b))
            }
            return f
        }
    }
}

function mkJavaScript(e) {
    var t, n, o = e.statementIndent,
        h = e.jsonld,
        p = e.json || h,
        f = e.typescript,
        g = e.wordCharacters || /[\w$\xa1-\uffff]/,
        y = function() {
            function kw(e) {
                return {
                    type: e,
                    style: "keyword"
                }
            }
            var e = kw("keyword a"),
                t = kw("keyword b"),
                n = kw("keyword c"),
                o = kw("keyword d"),
                h = kw("operator"),
                p = {
                    type: "atom",
                    style: "atom"
                };
            return {
                if: kw("if"),
                while: e,
                with: e,
                else: t,
                do: t,
                try: t,
                finally: t,
                return: o,
                break: o,
                continue: o,
                new: kw("new"),
                delete: n,
                void: n,
                throw: n,
                debugger: kw("debugger"),
                var: kw("var"),
                const: kw("var"),
                let: kw("var"),
                function: kw("function"),
                catch: kw("catch"),
                for: kw("for"),
                switch: kw("switch"),
                case: kw("case"),
                default: kw("default"),
                in: h,
                typeof: h,
                instanceof: h,
                true: p,
                false: p,
                null: p,
                undefined: p,
                NaN: p,
                Infinity: p,
                this: kw("this"),
                class: kw("class"),
                super: kw("atom"),
                yield: n,
                export: kw("export"),
                import: kw("import"),
                extends: n,
                await: n
            }
        }(),
        w = /[+\-*&%=<>!?|~^@]/,
        b = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

    function ret(e, o, h) {
        return t = e, n = h, o
    }

    function tokenBase(e, t) {
        var n, o = e.next();
        if ('"' == o || "'" == o) return t.tokenize = (n = o, function(e, t) {
            var o, p = !1;
            if (h && "@" == e.peek() && e.match(b)) return t.tokenize = tokenBase, ret("jsonld-keyword", "meta");
            for (; null != (o = e.next()) && (o != n || p);) p = !p && "\\" == o;
            return p || (t.tokenize = tokenBase), ret("string", "string")
        }), t.tokenize(e, t);
        if ("." == o && e.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) return ret("number", "number");
        if ("." == o && e.match("..")) return ret("spread", "meta");
        if (/[\[\]{}\(\),;\:\.]/.test(o)) return ret(o);
        if ("=" == o && e.eat(">")) return ret("=>", "operator");
        if ("0" == o && e.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) return ret("number", "number");
        if (/\d/.test(o)) return e.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), ret("number", "number");
        if ("/" == o) return e.eat("*") ? (t.tokenize = tokenComment, tokenComment(e, t)) : e.eat("/") ? (e.skipToEnd(), ret("comment", "comment")) : function(e, t, n) {
            return t.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(t.lastType) || "quasi" == t.lastType && /\{\s*$/.test(e.string.slice(0, e.pos - n))
        }(e, t, 1) ? (function(e) {
            for (var t, n = !1, o = !1; null != (t = e.next());) {
                if (!n) {
                    if ("/" == t && !o) return;
                    "[" == t ? o = !0 : o && "]" == t && (o = !1)
                }
                n = !n && "\\" == t
            }
        }(e), e.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), ret("regexp", "regexp")) : (e.eat("="), ret("operator", "operator", e.current()));
        if ("`" == o) return t.tokenize = tokenQuasi, tokenQuasi(e, t);
        if ("#" == o && "!" == e.peek()) return e.skipToEnd(), ret("meta", "meta");
        if ("#" == o && e.eatWhile(g)) return ret("variable", "property");
        if ("<" == o && e.match("!--") || "-" == o && e.match("->") && !/\S/.test(e.string.slice(0, e.start))) return e.skipToEnd(), ret("comment", "comment");
        if (w.test(o)) return ">" == o && t.lexical && ">" == t.lexical.type || (e.eat("=") ? "!" != o && "=" != o || e.eat("=") : /[<>*+\-|&?]/.test(o) && (e.eat(o), ">" == o && e.eat(o))), "?" == o && e.eat(".") ? ret(".") : ret("operator", "operator", e.current());
        if (g.test(o)) {
            e.eatWhile(g);
            var p = e.current();
            if ("." != t.lastType) {
                if (y.propertyIsEnumerable(p)) {
                    var f = y[p];
                    return ret(f.type, f.style, p)
                }
                if ("async" == p && e.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, !1)) return ret("async", "keyword", p)
            }
            return ret("variable", "variable", p)
        }
    }

    function tokenComment(e, t) {
        for (var n, o = !1; n = e.next();) {
            if ("/" == n && o) {
                t.tokenize = tokenBase;
                break
            }
            o = "*" == n
        }
        return ret("comment", "comment")
    }

    function tokenQuasi(e, t) {
        for (var n, o = !1; null != (n = e.next());) {
            if (!o && ("`" == n || "$" == n && e.eat("{"))) {
                t.tokenize = tokenBase;
                break
            }
            o = !o && "\\" == n
        }
        return ret("quasi", "string.special", e.current())
    }

    function findFatArrow(e, t) {
        t.fatArrowAt && (t.fatArrowAt = null);
        var n = e.string.indexOf("=>", e.start);
        if (!(n < 0)) {
            if (f) {
                var o = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(e.string.slice(e.start, n));
                o && (n = o.index)
            }
            for (var h = 0, p = !1, y = n - 1; y >= 0; --y) {
                var w = e.string.charAt(y),
                    b = "([{}])".indexOf(w);
                if (b >= 0 && b < 3) {
                    if (!h) {
                        ++y;
                        break
                    }
                    if (0 == --h) {
                        "(" == w && (p = !0);
                        break
                    }
                } else if (b >= 3 && b < 6) ++h;
                else if (g.test(w)) p = !0;
                else if (/["'\/`]/.test(w))
                    for (;; --y) {
                        if (0 == y) return;
                        if (e.string.charAt(y - 1) == w && "\\" != e.string.charAt(y - 2)) {
                            y--;
                            break
                        }
                    } else if (p && !h) {
                        ++y;
                        break
                    }
            }
            p && !h && (t.fatArrowAt = y)
        }
    }
    var S = {
        atom: !0,
        number: !0,
        variable: !0,
        string: !0,
        regexp: !0,
        this: !0,
        import: !0,
        "jsonld-keyword": !0
    };

    function JSLexical(e, t, n, o, h, p) {
        this.indented = e, this.column = t, this.type = n, this.prev = h, this.info = p, null != o && (this.align = o)
    }

    function inScope(e, t) {
        for (var n = e.localVars; n; n = n.next)
            if (n.name == t) return !0;
        for (var o = e.context; o; o = o.prev)
            for (n = o.vars; n; n = n.next)
                if (n.name == t) return !0
    }
    var k = {
        state: null,
        marked: null,
        cc: null
    };

    function pass() {
        for (var e = arguments.length - 1; e >= 0; e--) k.cc.push(arguments[e])
    }

    function cont() {
        return pass.apply(null, arguments), !0
    }

    function inList(e, t) {
        for (var n = t; n; n = n.next)
            if (n.name == e) return !0;
        return !1
    }

    function register(t) {
        var n = k.state;
        if (k.marked = "def", n.context)
            if ("var" == n.lexical.info && n.context && n.context.block) {
                var o = registerVarScoped(t, n.context);
                if (null != o) return void(n.context = o)
            } else if (!inList(t, n.localVars)) return void(n.localVars = new Var(t, n.localVars));
        e.globalVars && !inList(t, n.globalVars) && (n.globalVars = new Var(t, n.globalVars))
    }

    function registerVarScoped(e, t) {
        if (t) {
            if (t.block) {
                var n = registerVarScoped(e, t.prev);
                return n ? n == t.prev ? t : new Context(n, t.vars, !0) : null
            }
            return inList(e, t.vars) ? t : new Context(t.prev, new Var(e, t.vars), !1)
        }
        return null
    }

    function isModifier(e) {
        return "public" == e || "private" == e || "protected" == e || "abstract" == e || "readonly" == e
    }

    function Context(e, t, n) {
        this.prev = e, this.vars = t, this.block = n
    }

    function Var(e, t) {
        this.name = e, this.next = t
    }
    var v = new Var("this", new Var("arguments", null));

    function pushcontext() {
        k.state.context = new Context(k.state.context, k.state.localVars, !1), k.state.localVars = v
    }

    function pushblockcontext() {
        k.state.context = new Context(k.state.context, k.state.localVars, !0), k.state.localVars = null
    }

    function popcontext() {
        k.state.localVars = k.state.context.vars, k.state.context = k.state.context.prev
    }

    function pushlex(e, t) {
        var result = function() {
            var n = k.state,
                o = n.indented;
            if ("stat" == n.lexical.type) o = n.lexical.indented;
            else
                for (var h = n.lexical; h && ")" == h.type && h.align; h = h.prev) o = h.indented;
            n.lexical = new JSLexical(o, k.stream.column(), e, null, n.lexical, t)
        };
        return result.lex = !0, result
    }

    function poplex() {
        var e = k.state;
        e.lexical.prev && (")" == e.lexical.type && (e.indented = e.lexical.indented), e.lexical = e.lexical.prev)
    }

    function expect(e) {
        return function exp(t) {
            return t == e ? cont() : ";" == e || "}" == t || ")" == t || "]" == t ? pass() : cont(exp)
        }
    }

    function statement(e, t) {
        return "var" == e ? cont(pushlex("vardef", t), vardef, expect(";"), poplex) : "keyword a" == e ? cont(pushlex("form"), parenExpr, statement, poplex) : "keyword b" == e ? cont(pushlex("form"), statement, poplex) : "keyword d" == e ? k.stream.match(/^\s*$/, !1) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex) : "debugger" == e ? cont(expect(";")) : "{" == e ? cont(pushlex("}"), pushblockcontext, block, poplex, popcontext) : ";" == e ? cont() : "if" == e ? ("else" == k.state.lexical.info && k.state.cc[k.state.cc.length - 1] == poplex && k.state.cc.pop()(), cont(pushlex("form"), parenExpr, statement, poplex, maybeelse)) : "function" == e ? cont(functiondef) : "for" == e ? cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex) : "class" == e || f && "interface" == t ? (k.marked = "keyword", cont(pushlex("form", "class" == e ? e : t), className, poplex)) : "variable" == e ? f && "declare" == t ? (k.marked = "keyword", cont(statement)) : f && ("module" == t || "enum" == t || "type" == t) && k.stream.match(/^\s*\w/, !1) ? (k.marked = "keyword", "enum" == t ? cont(enumdef) : "type" == t ? cont(typename, expect("operator"), typeexpr, expect(";")) : cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)) : f && "namespace" == t ? (k.marked = "keyword", cont(pushlex("form"), expression, statement, poplex)) : f && "abstract" == t ? (k.marked = "keyword", cont(statement)) : cont(pushlex("stat"), maybelabel) : "switch" == e ? cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext) : "case" == e ? cont(expression, expect(":")) : "default" == e ? cont(expect(":")) : "catch" == e ? cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext) : "export" == e ? cont(pushlex("stat"), afterExport, poplex) : "import" == e ? cont(pushlex("stat"), afterImport, poplex) : "async" == e ? cont(statement) : "@" == t ? cont(expression, statement) : pass(pushlex("stat"), expression, expect(";"), poplex)
    }

    function maybeCatchBinding(e) {
        if ("(" == e) return cont(funarg, expect(")"))
    }

    function expression(e, t) {
        return expressionInner(e, t, !1)
    }

    function expressionNoComma(e, t) {
        return expressionInner(e, t, !0)
    }

    function parenExpr(e) {
        return "(" != e ? pass() : cont(pushlex(")"), maybeexpression, expect(")"), poplex)
    }

    function expressionInner(e, t, n) {
        if (k.state.fatArrowAt == k.stream.start) {
            var o = n ? arrowBodyNoComma : arrowBody;
            if ("(" == e) return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), o, popcontext);
            if ("variable" == e) return pass(pushcontext, pattern, expect("=>"), o, popcontext)
        }
        var h = n ? maybeoperatorNoComma : maybeoperatorComma;
        return S.hasOwnProperty(e) ? cont(h) : "function" == e ? cont(functiondef, h) : "class" == e || f && "interface" == t ? (k.marked = "keyword", cont(pushlex("form"), classExpression, poplex)) : "keyword c" == e || "async" == e ? cont(n ? expressionNoComma : expression) : "(" == e ? cont(pushlex(")"), maybeexpression, expect(")"), poplex, h) : "operator" == e || "spread" == e ? cont(n ? expressionNoComma : expression) : "[" == e ? cont(pushlex("]"), arrayLiteral, poplex, h) : "{" == e ? contCommasep(objprop, "}", null, h) : "quasi" == e ? pass(quasi, h) : "new" == e ? cont(function(e) {
            return function(t) {
                return "." == t ? cont(e ? targetNoComma : target) : "variable" == t && f ? cont(maybeTypeArgs, e ? maybeoperatorNoComma : maybeoperatorComma) : pass(e ? expressionNoComma : expression)
            }
        }(n)) : cont()
    }

    function maybeexpression(e) {
        return e.match(/[;\}\)\],]/) ? pass() : pass(expression)
    }

    function maybeoperatorComma(e, t) {
        return "," == e ? cont(maybeexpression) : maybeoperatorNoComma(e, t, !1)
    }

    function maybeoperatorNoComma(e, t, n) {
        var o = 0 == n ? maybeoperatorComma : maybeoperatorNoComma,
            h = 0 == n ? expression : expressionNoComma;
        return "=>" == e ? cont(pushcontext, n ? arrowBodyNoComma : arrowBody, popcontext) : "operator" == e ? /\+\+|--/.test(t) || f && "!" == t ? cont(o) : f && "<" == t && k.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, !1) ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, o) : "?" == t ? cont(expression, expect(":"), h) : cont(h) : "quasi" == e ? pass(quasi, o) : ";" != e ? "(" == e ? contCommasep(expressionNoComma, ")", "call", o) : "." == e ? cont(property, o) : "[" == e ? cont(pushlex("]"), maybeexpression, expect("]"), poplex, o) : f && "as" == t ? (k.marked = "keyword", cont(typeexpr, o)) : "regexp" == e ? (k.state.lastType = k.marked = "operator", k.stream.backUp(k.stream.pos - k.stream.start - 1), cont(h)) : void 0 : void 0
    }

    function quasi(e, t) {
        return "quasi" != e ? pass() : "${" != t.slice(t.length - 2) ? cont(quasi) : cont(maybeexpression, continueQuasi)
    }

    function continueQuasi(e) {
        if ("}" == e) return k.marked = "string.special", k.state.tokenize = tokenQuasi, cont(quasi)
    }

    function arrowBody(e) {
        return findFatArrow(k.stream, k.state), pass("{" == e ? statement : expression)
    }

    function arrowBodyNoComma(e) {
        return findFatArrow(k.stream, k.state), pass("{" == e ? statement : expressionNoComma)
    }

    function target(e, t) {
        if ("target" == t) return k.marked = "keyword", cont(maybeoperatorComma)
    }

    function targetNoComma(e, t) {
        if ("target" == t) return k.marked = "keyword", cont(maybeoperatorNoComma)
    }

    function maybelabel(e) {
        return ":" == e ? cont(poplex, statement) : pass(maybeoperatorComma, expect(";"), poplex)
    }

    function property(e) {
        if ("variable" == e) return k.marked = "property", cont()
    }

    function objprop(e, t) {
        return "async" == e ? (k.marked = "property", cont(objprop)) : "variable" == e || "keyword" == k.style ? (k.marked = "property", "get" == t || "set" == t ? cont(getterSetter) : (f && k.state.fatArrowAt == k.stream.start && (n = k.stream.match(/^\s*:\s*/, !1)) && (k.state.fatArrowAt = k.stream.pos + n[0].length), cont(afterprop))) : "number" == e || "string" == e ? (k.marked = h ? "property" : k.style + " property", cont(afterprop)) : "jsonld-keyword" == e ? cont(afterprop) : f && isModifier(t) ? (k.marked = "keyword", cont(objprop)) : "[" == e ? cont(expression, maybetype, expect("]"), afterprop) : "spread" == e ? cont(expressionNoComma, afterprop) : "*" == t ? (k.marked = "keyword", cont(objprop)) : ":" == e ? pass(afterprop) : void 0;
        var n
    }

    function getterSetter(e) {
        return "variable" != e ? pass(afterprop) : (k.marked = "property", cont(functiondef))
    }

    function afterprop(e) {
        return ":" == e ? cont(expressionNoComma) : "(" == e ? pass(functiondef) : void 0
    }

    function commasep(e, t, n) {
        function proceed(o, h) {
            if (n ? n.indexOf(o) > -1 : "," == o) {
                var p = k.state.lexical;
                return "call" == p.info && (p.pos = (p.pos || 0) + 1), cont((function(n, o) {
                    return n == t || o == t ? pass() : pass(e)
                }), proceed)
            }
            return o == t || h == t ? cont() : n && n.indexOf(";") > -1 ? pass(e) : cont(expect(t))
        }
        return function(n, o) {
            return n == t || o == t ? cont() : pass(e, proceed)
        }
    }

    function contCommasep(e, t, n) {
        for (var o = 3; o < arguments.length; o++) k.cc.push(arguments[o]);
        return cont(pushlex(t, n), commasep(e, t), poplex)
    }

    function block(e) {
        return "}" == e ? cont() : pass(statement, block)
    }

    function maybetype(e, t) {
        if (f) {
            if (":" == e) return cont(typeexpr);
            if ("?" == t) return cont(maybetype)
        }
    }

    function maybetypeOrIn(e, t) {
        if (f && (":" == e || "in" == t)) return cont(typeexpr)
    }

    function mayberettype(e) {
        if (f && ":" == e) return k.stream.match(/^\s*\w+\s+is\b/, !1) ? cont(expression, isKW, typeexpr) : cont(typeexpr)
    }

    function isKW(e, t) {
        if ("is" == t) return k.marked = "keyword", cont()
    }

    function typeexpr(e, t) {
        return "keyof" == t || "typeof" == t || "infer" == t || "readonly" == t ? (k.marked = "keyword", cont("typeof" == t ? expressionNoComma : typeexpr)) : "variable" == e || "void" == t ? (k.marked = "type", cont(afterType)) : "|" == t || "&" == t ? cont(typeexpr) : "string" == e || "number" == e || "atom" == e ? cont(afterType) : "[" == e ? cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType) : "{" == e ? cont(pushlex("}"), typeprops, poplex, afterType) : "(" == e ? cont(commasep(typearg, ")"), maybeReturnType, afterType) : "<" == e ? cont(commasep(typeexpr, ">"), typeexpr) : "quasi" == e ? pass(quasiType, afterType) : void 0
    }

    function maybeReturnType(e) {
        if ("=>" == e) return cont(typeexpr)
    }

    function typeprops(e) {
        return e.match(/[\}\)\]]/) ? cont() : "," == e || ";" == e ? cont(typeprops) : pass(typeprop, typeprops)
    }

    function typeprop(e, t) {
        return "variable" == e || "keyword" == k.style ? (k.marked = "property", cont(typeprop)) : "?" == t || "number" == e || "string" == e ? cont(typeprop) : ":" == e ? cont(typeexpr) : "[" == e ? cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop) : "(" == e ? pass(functiondecl, typeprop) : e.match(/[;\}\)\],]/) ? void 0 : cont()
    }

    function quasiType(e, t) {
        return "quasi" != e ? pass() : "${" != t.slice(t.length - 2) ? cont(quasiType) : cont(typeexpr, continueQuasiType)
    }

    function continueQuasiType(e) {
        if ("}" == e) return k.marked = "string.special", k.state.tokenize = tokenQuasi, cont(quasiType)
    }

    function typearg(e, t) {
        return "variable" == e && k.stream.match(/^\s*[?:]/, !1) || "?" == t ? cont(typearg) : ":" == e ? cont(typeexpr) : "spread" == e ? cont(typearg) : pass(typeexpr)
    }

    function afterType(e, t) {
        return "<" == t ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType) : "|" == t || "." == e || "&" == t ? cont(typeexpr) : "[" == e ? cont(typeexpr, expect("]"), afterType) : "extends" == t || "implements" == t ? (k.marked = "keyword", cont(typeexpr)) : "?" == t ? cont(typeexpr, expect(":"), typeexpr) : void 0
    }

    function maybeTypeArgs(e, t) {
        if ("<" == t) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
    }

    function typeparam() {
        return pass(typeexpr, maybeTypeDefault)
    }

    function maybeTypeDefault(e, t) {
        if ("=" == t) return cont(typeexpr)
    }

    function vardef(e, t) {
        return "enum" == t ? (k.marked = "keyword", cont(enumdef)) : pass(pattern, maybetype, maybeAssign, vardefCont)
    }

    function pattern(e, t) {
        return f && isModifier(t) ? (k.marked = "keyword", cont(pattern)) : "variable" == e ? (register(t), cont()) : "spread" == e ? cont(pattern) : "[" == e ? contCommasep(eltpattern, "]") : "{" == e ? contCommasep(proppattern, "}") : void 0
    }

    function proppattern(e, t) {
        return "variable" != e || k.stream.match(/^\s*:/, !1) ? ("variable" == e && (k.marked = "property"), "spread" == e ? cont(pattern) : "}" == e ? pass() : "[" == e ? cont(expression, expect("]"), expect(":"), proppattern) : cont(expect(":"), pattern, maybeAssign)) : (register(t), cont(maybeAssign))
    }

    function eltpattern() {
        return pass(pattern, maybeAssign)
    }

    function maybeAssign(e, t) {
        if ("=" == t) return cont(expressionNoComma)
    }

    function vardefCont(e) {
        if ("," == e) return cont(vardef)
    }

    function maybeelse(e, t) {
        if ("keyword b" == e && "else" == t) return cont(pushlex("form", "else"), statement, poplex)
    }

    function forspec(e, t) {
        return "await" == t ? cont(forspec) : "(" == e ? cont(pushlex(")"), forspec1, poplex) : void 0
    }

    function forspec1(e) {
        return "var" == e ? cont(vardef, forspec2) : "variable" == e ? cont(forspec2) : pass(forspec2)
    }

    function forspec2(e, t) {
        return ")" == e ? cont() : ";" == e ? cont(forspec2) : "in" == t || "of" == t ? (k.marked = "keyword", cont(expression, forspec2)) : pass(expression, forspec2)
    }

    function functiondef(e, t) {
        return "*" == t ? (k.marked = "keyword", cont(functiondef)) : "variable" == e ? (register(t), cont(functiondef)) : "(" == e ? cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext) : f && "<" == t ? cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef) : void 0
    }

    function functiondecl(e, t) {
        return "*" == t ? (k.marked = "keyword", cont(functiondecl)) : "variable" == e ? (register(t), cont(functiondecl)) : "(" == e ? cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext) : f && "<" == t ? cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl) : void 0
    }

    function typename(e, t) {
        return "keyword" == e || "variable" == e ? (k.marked = "type", cont(typename)) : "<" == t ? cont(pushlex(">"), commasep(typeparam, ">"), poplex) : void 0
    }

    function funarg(e, t) {
        return "@" == t && cont(expression, funarg), "spread" == e ? cont(funarg) : f && isModifier(t) ? (k.marked = "keyword", cont(funarg)) : f && "this" == e ? cont(maybetype, maybeAssign) : pass(pattern, maybetype, maybeAssign)
    }

    function classExpression(e, t) {
        return "variable" == e ? className(e, t) : classNameAfter(e, t)
    }

    function className(e, t) {
        if ("variable" == e) return register(t), cont(classNameAfter)
    }

    function classNameAfter(e, t) {
        return "<" == t ? cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter) : "extends" == t || "implements" == t || f && "," == e ? ("implements" == t && (k.marked = "keyword"), cont(f ? typeexpr : expression, classNameAfter)) : "{" == e ? cont(pushlex("}"), classBody, poplex) : void 0
    }

    function classBody(e, t) {
        return "async" == e || "variable" == e && ("static" == t || "get" == t || "set" == t || f && isModifier(t)) && k.stream.match(/^\s+#?[\w$\xa1-\uffff]/, !1) ? (k.marked = "keyword", cont(classBody)) : "variable" == e || "keyword" == k.style ? (k.marked = "property", cont(classfield, classBody)) : "number" == e || "string" == e ? cont(classfield, classBody) : "[" == e ? cont(expression, maybetype, expect("]"), classfield, classBody) : "*" == t ? (k.marked = "keyword", cont(classBody)) : f && "(" == e ? pass(functiondecl, classBody) : ";" == e || "," == e ? cont(classBody) : "}" == e ? cont() : "@" == t ? cont(expression, classBody) : void 0
    }

    function classfield(e, t) {
        if ("!" == t || "?" == t) return cont(classfield);
        if (":" == e) return cont(typeexpr, maybeAssign);
        if ("=" == t) return cont(expressionNoComma);
        var n = k.state.lexical.prev;
        return pass(n && "interface" == n.info ? functiondecl : functiondef)
    }

    function afterExport(e, t) {
        return "*" == t ? (k.marked = "keyword", cont(maybeFrom, expect(";"))) : "default" == t ? (k.marked = "keyword", cont(expression, expect(";"))) : "{" == e ? cont(commasep(exportField, "}"), maybeFrom, expect(";")) : pass(statement)
    }

    function exportField(e, t) {
        return "as" == t ? (k.marked = "keyword", cont(expect("variable"))) : "variable" == e ? pass(expressionNoComma, exportField) : void 0
    }

    function afterImport(e) {
        return "string" == e ? cont() : "(" == e ? pass(expression) : "." == e ? pass(maybeoperatorComma) : pass(importSpec, maybeMoreImports, maybeFrom)
    }

    function importSpec(e, t) {
        return "{" == e ? contCommasep(importSpec, "}") : ("variable" == e && register(t), "*" == t && (k.marked = "keyword"), cont(maybeAs))
    }

    function maybeMoreImports(e) {
        if ("," == e) return cont(importSpec, maybeMoreImports)
    }

    function maybeAs(e, t) {
        if ("as" == t) return k.marked = "keyword", cont(importSpec)
    }

    function maybeFrom(e, t) {
        if ("from" == t) return k.marked = "keyword", cont(expression)
    }

    function arrayLiteral(e) {
        return "]" == e ? cont() : pass(commasep(expressionNoComma, "]"))
    }

    function enumdef() {
        return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
    }

    function enummember() {
        return pass(pattern, maybeAssign)
    }

    function isContinuedStatement(e, t) {
        return "operator" == e.lastType || "," == e.lastType || w.test(t.charAt(0)) || /[,.]/.test(t.charAt(0))
    }
    return pushcontext.lex = pushblockcontext.lex = !0, popcontext.lex = !0, poplex.lex = !0, {
        name: e.name,
        startState: function(t) {
            var n = {
                tokenize: tokenBase,
                lastType: "sof",
                cc: [],
                lexical: new JSLexical(-t, 0, "block", !1),
                localVars: e.localVars,
                context: new Context(null, null, !1),
                indented: 0
            };
            return e.globalVars && "object" == typeof e.globalVars && (n.globalVars = e.globalVars), n
        },
        token: function(e, o) {
            if (e.sol() && (o.lexical.hasOwnProperty("align") || (o.lexical.align = !1), o.indented = e.indentation(), findFatArrow(e, o)), o.tokenize != tokenComment && e.eatSpace()) return null;
            var h = o.tokenize(e, o);
            return "comment" == t ? h : (o.lastType = "operator" != t || "++" != n && "--" != n ? t : "incdec", function(e, t, n, o, h) {
                var f = e.cc;
                for (k.state = e, k.stream = h, k.marked = null, k.cc = f, k.style = t, e.lexical.hasOwnProperty("align") || (e.lexical.align = !0);;)
                    if ((f.length ? f.pop() : p ? expression : statement)(n, o)) {
                        for (; f.length && f[f.length - 1].lex;) f.pop()();
                        return k.marked ? k.marked : "variable" == n && inScope(e, o) ? "variableName.local" : t
                    }
            }(o, h, t, n, e))
        },
        indent: function(t, n, h) {
            if (window.outputTemplateJavaScriptStreamParserIndentFnOverride) return window.outputTemplateJavaScriptStreamParserIndentFnOverride(t, n, h, {
                tokenComment: tokenComment,
                tokenQuasi: tokenQuasi,
                tokenBase: tokenBase,
                poplex: poplex,
                popcontext: popcontext,
                maybeelse: maybeelse,
                maybeoperatorComma: maybeoperatorComma,
                maybeoperatorNoComma: maybeoperatorNoComma,
                statementIndent: o,
                isContinuedStatement: isContinuedStatement,
                parserConfig: e
            });
            if (t.tokenize == tokenComment || t.tokenize == tokenQuasi) return null;
            if (t.tokenize != tokenBase) return 0;
            var p, f = n && n.charAt(0),
                g = t.lexical;
            if (!/^\s*else\b/.test(n))
                for (var y = t.cc.length - 1; y >= 0; --y) {
                    var w = t.cc[y];
                    if (w == poplex) g = g.prev;
                    else if (w != maybeelse && w != popcontext) break
                }
            for (;
                ("stat" == g.type || "form" == g.type) && ("}" == f || (p = t.cc[t.cc.length - 1]) && (p == maybeoperatorComma || p == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(n));) g = g.prev;
            o && ")" == g.type && "stat" == g.prev.type && (g = g.prev);
            var b = g.type,
                S = f == b;
            if ("vardef" == b) return g.indented + ("operator" == t.lastType || "," == t.lastType ? g.info.length + 1 : 0);
            if ("form" == b && "{" == f) return g.indented;
            if ("form" == b) return g.indented + h.unit;
            if ("stat" == b) return g.indented + (isContinuedStatement(t, n) ? o || h.unit : 0);
            if ("switch" != g.info || S || 0 == e.doubleIndentSwitch) {
                if (g.align) return g.column + (S ? 0 : 1); {
                    let e = g.indented;
                    if ("{" === t.lastType) {
                        e = h.lineAt(h.pos - 1).text.match(/^\s*/)[0].length
                    }
                    return t.indented - h.unit > e && (e = t.indented - h.unit), 0 === g.column ? null : Math.max(0, e) + (S ? 0 : h.unit)
                }
            }
            return g.indented + (/^(?:case|default)\b/.test(n) ? h.unit : 2 * h.unit)
        },
        languageData: {
            indentOnInput: /^\s*(?:case .*?:|default:|\{|\})$/,
            commentTokens: p ? void 0 : {
                line: "//",
                block: {
                    open: "/*",
                    close: "*/"
                }
            },
            closeBrackets: {
                brackets: ["(", "[", "{", "'", '"', "`"]
            },
            wordChars: "$"
        }
    }
}

function mkJavaScriptModelText(e, t) {
    var n = e.statementIndent,
        o = e.jsonld,
        h = e.json || o,
        p = e.typescript,
        f = e.wordCharacters || /[\w$\xa1-\uffff]/,
        g = function() {
            function kw(e) {
                return {
                    type: e,
                    style: "keyword"
                }
            }
            var e = kw("keyword a"),
                t = kw("keyword b"),
                n = kw("keyword c"),
                o = kw("keyword d"),
                h = kw("operator"),
                p = {
                    type: "atom",
                    style: "atom"
                };
            return {
                if: kw("if"),
                while: e,
                with: e,
                else: t,
                do: t,
                try: t,
                finally: t,
                return: o,
                break: o,
                continue: o,
                new: kw("new"),
                delete: n,
                void: n,
                throw: n,
                debugger: kw("debugger"),
                var: kw("var"),
                const: kw("var"),
                let: kw("var"),
                function: kw("function"),
                catch: kw("catch"),
                for: kw("for"),
                switch: kw("switch"),
                case: kw("case"),
                default: kw("default"),
                in: h,
                typeof: h,
                instanceof: h,
                true: p,
                false: p,
                null: p,
                undefined: p,
                NaN: p,
                Infinity: p,
                this: kw("this"),
                class: kw("class"),
                super: kw("atom"),
                yield: n,
                export: kw("export"),
                import: kw("import"),
                extends: n,
                await: n
            }
        }(),
        y = /[+\-*&%=<>!?|~^@]/,
        w = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
    let b; {
        function splitParams(e) {
            for (var t = [], n = "", o = 0, h = 0, p = 0, f = !1, g = "", y = 0; y < e.length; y++) {
                var w = e[y];
                f ? (n += w, w === g && "\\" !== e[y - 1] && (f = !1, g = "")) : '"' === w || "'" === w || "`" === w ? (f = !0, g = w, n += w) : "{" === w ? (o++, n += w) : "}" === w ? (o--, n += w) : "[" === w ? (h++, n += w) : "]" === w ? (h--, n += w) : "(" === w ? (p++, n += w) : ")" === w ? (p--, n += w) : "," === w && 0 === o && 0 === h && 0 === p ? (t.push(n), n = "") : n += w
            }
            return n.length > 0 && t.push(n), t
        }
        b = function(e, t) {
            var n = e.pos;
            if (!e.match(/^(async |)[a-zA-Z_$][\w$]*/)) return e.pos = n, !1;
            if (e.eatSpace(), !e.match("(")) return e.pos = n, !1;
            for (var o = 1, h = ""; !e.eol() && o > 0;) {
                var p = e.next();
                "(" === p ? (o++, h += p) : ")" === p ? --o > 0 && (h += p) : "\\" === p ? (h += p, e.eol() || (h += e.next())) : h += p
            }
            if (0 !== o) return e.pos = n, !1;
            if (e.eatSpace(), !e.match("=>")) return e.pos = n, !1;
            var f = [];
            return splitParams(h).forEach((function(e) {
                if ((e = e.trim()).startsWith("{") || e.startsWith("[")) {
                    var t = e.split("=")[0].trim();
                    splitParams(t.substring(1, t.length - 1)).forEach((function(e) {
                        var t = (e = e.trim()).indexOf("="); - 1 !== t && (e = e.substring(0, t).trim()), e.length > 0 && f.push(e)
                    }))
                } else {
                    var n = e.indexOf("="); - 1 !== n && (e = e.substring(0, n).trim());
                    var o = e.search(/[\{\[]/); - 1 !== o && (e = e.substring(0, o).trim()), e.length > 0 && f.push(e)
                }
            })), f
        }
    }

    function enterJsBlock(e, t, n, o = null) {
        if (t.inFunctionBlock || t.inSquareBlock) throw new Error("state.inFunctionBlock || state.inSquareBlock");
        t.activeJsBlockStartPos = t.currentLineStartDocPos + e.pos, t.activeJsBlockContext = o, "function" === n && (t.inFunctionBlock = !0, t.functionIndentLevel = e.indentation()), "square" === n && (t.inSquareBlock = !0, t.bracketDepth = 1), t.tokenize = tokenBase, pushcontext()
    }

    function exitJsBlock(e, t, n) {
        if (t.inFunctionBlock && t.inSquareBlock) throw new Error("state.inFunctionBlock && state.inSquareBlock");
        if (!t.inFunctionBlock && !t.inSquareBlock) throw new Error("!state.inFunctionBlock && !state.inSquareBlock");
        if (null === t.activeJsBlockStartpos) throw new Error("state.activeJsBlockStartpos === null");
        let o = {
            from: t.activeJsBlockStartPos,
            to: t.currentLineStartDocPos + e.pos,
            type: n,
            extraContext: t.activeJsBlockContext
        };
        "square" === n && "missing_close" === t.activeJsBlockContext && o.to--, t.completedJsBlockRanges.push(o), t.activeJsBlockStartPos = null, t.activeJsBlockContext = null, t.inFunctionBlock = !1, t.inSquareBlock = !1, t.tokenize = tokenOuter, popcontext(), t.outerEscaped = !1
    }

    function tokenOuter(e, t) {
        if (t.restOfLineIsOuterComment) return t.restOfLineIsOuterComment = !1, e.skipToEnd(), "comment";
        if (e.sol() && e.match(/^\/\//)) return e.skipToEnd(), "comment";
        let n, o = null;
        if (n = b(e)) {
            let h = e.string.split("=>")[0] + "=>";
            enterJsBlock(e, t, "function", h);
            for (let e of n) P.state.localVars = new Var(e, P.state.localVars);
            o = "def"
        } else {
            let n = e.next(),
                h = e.peek();
            if ("\\" === n) t.outerEscaped = !t.outerEscaped, o = null;
            else if (t.outerEscaped || "=" !== n)
                if (" " !== e.string[e.pos - 2] && "\t" !== e.string[e.pos - 2] || "/" !== n || "/" !== h)
                    if ("$" === n && "" === e.string.slice(0, e.pos - 1).trim() && e.match(/^output\s*=/, !1)) e.match(/^output\s*/), o = "propertyName";
                    else if ("$" === n && "$meta" === e.string.trimEnd()) e.match(/^meta/), o = "propertyName";
            else if ("$" === n && /^\$preprocess\s*(\(|=)/.test(e.string)) e.match(/^preprocess/), o = "propertyName";
            else if (t.outerEscaped || "[" !== n)
                if (t.outerEscaped || "{" !== n && "}" !== n) {
                    e.match(/^[^\[\{\}\\\$=\/]+/) || "[" === h || "{" === h || e.next(), t.outerEscaped = !1, o = null
                } else "A" !== h && "a" !== h || "}" !== e.string[e.pos + 1] || (e.next(), e.next()), o = "typeOperator";
            else enterJsBlock(e, t, "square"), o = "operator";
            else e.backUp(1), t.restOfLineIsOuterComment = !0, o = null;
            else o = "operator"
        }
        return t.outerEscaped && "\\" !== e.current() && (t.outerEscaped = !1), o
    }
    var S, k;

    function ret(e, t, n) {
        return S = e, k = n, t
    }

    function tokenBase(e, t) {
        if (t.inSquareBlock) {
            var n = e.peek();
            if ("[" == n) t.bracketDepth++;
            else if ("]" == n && (t.bracketDepth--, 0 === t.bracketDepth)) return exitJsBlock(e, t, "square"), e.next(), "operator"
        }
        var h, p = e.next();
        if ('"' == p || "'" == p) return t.tokenize = (h = p, function(e, t) {
            var n, p = !1;
            if (o && "@" == e.peek() && e.match(w)) return t.tokenize = tokenBase, ret("jsonld-keyword", "meta");
            for (; null != (n = e.next()) && (n != h || p);) p = !p && "\\" == n;
            return p || (t.tokenize = tokenBase), ret("string", "string")
        }), t.tokenize(e, t);
        if ("." == p && e.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) return ret("number", "number");
        if ("." == p && e.match("..")) return ret("spread", "meta");
        if (/[\[\]{}\(\),;\:\.]/.test(p)) return ret(p);
        if ("=" == p && e.eat(">")) return ret("=>", "operator");
        if ("0" == p && e.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) return ret("number", "number");
        if (/\d/.test(p)) return e.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), ret("number", "number");
        if ("/" == p) return e.eat("*") ? (t.tokenize = tokenComment, tokenComment(e, t)) : e.eat("/") ? (e.skipToEnd(), ret("comment", "comment")) : function(e, t, n) {
            return t.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(t.lastType) || "quasi" == t.lastType && /\{\s*$/.test(e.string.slice(0, e.pos - n))
        }(e, t, 1) ? (function(e) {
            for (var t, n = !1, o = !1; null != (t = e.next());) {
                if (!n) {
                    if ("/" == t && !o) return;
                    "[" == t ? o = !0 : o && "]" == t && (o = !1)
                }
                n = !n && "\\" == t
            }
        }(e), e.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), ret("regexp", "regexp")) : (e.eat("="), ret("operator", "operator", e.current()));
        if ("`" == p) return t.tokenize = tokenQuasi, tokenQuasi(e, t);
        if ("#" == p && "!" == e.peek()) return e.skipToEnd(), ret("meta", "meta");
        if ("#" == p && e.eatWhile(f)) return ret("variable", "property");
        if ("<" == p && e.match("!--") || "-" == p && e.match("->") && !/\S/.test(e.string.slice(0, e.start))) return e.skipToEnd(), ret("comment", "comment");
        if (y.test(p)) return ">" == p && t.lexical && ">" == t.lexical.type || (e.eat("=") ? "!" != p && "=" != p || e.eat("=") : /[<>*+\-|&?]/.test(p) && (e.eat(p), ">" == p && e.eat(p))), "?" == p && e.eat(".") ? ret(".") : ret("operator", "operator", e.current());
        if (f.test(p)) {
            e.eatWhile(f);
            var b = e.current();
            if ("." != t.lastType) {
                if (g.propertyIsEnumerable(b)) {
                    var S = g[b];
                    return ret(S.type, S.style, b)
                }
                if ("async" == b && e.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, !1)) return ret("async", "keyword", b)
            }
            return ret("variable", "variable", b)
        }
    }

    function tokenComment(e, t) {
        for (var n, o = !1; n = e.next();) {
            if ("/" == n && o) {
                t.tokenize = tokenBase;
                break
            }
            o = "*" == n
        }
        return ret("comment", "comment")
    }

    function tokenQuasi(e, t) {
        for (var n, o = !1; null != (n = e.next());) {
            if (!o && ("`" == n || "$" == n && e.eat("{"))) {
                t.tokenize = tokenBase;
                break
            }
            o = !o && "\\" == n
        }
        return ret("quasi", "string.special", e.current())
    }

    function findFatArrow(e, t) {
        t.fatArrowAt && (t.fatArrowAt = null);
        var n = e.string.indexOf("=>", e.start);
        if (!(n < 0)) {
            if (p) {
                var o = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(e.string.slice(e.start, n));
                o && (n = o.index)
            }
            for (var h = 0, g = !1, y = n - 1; y >= 0; --y) {
                var w = e.string.charAt(y),
                    b = "([{}])".indexOf(w);
                if (b >= 0 && b < 3) {
                    if (!h) {
                        ++y;
                        break
                    }
                    if (0 == --h) {
                        "(" == w && (g = !0);
                        break
                    }
                } else if (b >= 3 && b < 6) ++h;
                else if (f.test(w)) g = !0;
                else if (/["'\/`]/.test(w))
                    for (;; --y) {
                        if (0 == y) return;
                        if (e.string.charAt(y - 1) == w && "\\" != e.string.charAt(y - 2)) {
                            y--;
                            break
                        }
                    } else if (g && !h) {
                        ++y;
                        break
                    }
            }
            g && !h && (t.fatArrowAt = y)
        }
    }
    var v = {
        atom: !0,
        number: !0,
        variable: !0,
        string: !0,
        regexp: !0,
        this: !0,
        import: !0,
        "jsonld-keyword": !0
    };

    function JSLexical(e, t, n, o, h, p) {
        this.indented = e, this.column = t, this.type = n, this.prev = h, this.info = p, null != o && (this.align = o)
    }

    function inScope(e, t) {
        for (var n = e.localVars; n; n = n.next)
            if (n.name == t) return !0;
        for (var o = e.context; o; o = o.prev)
            for (n = o.vars; n; n = n.next)
                if (n.name == t) return !0
    }
    var P = {
        state: null,
        marked: null,
        cc: null
    };

    function pass() {
        for (var e = arguments.length - 1; e >= 0; e--) P.cc.push(arguments[e])
    }

    function cont() {
        return pass.apply(null, arguments), !0
    }

    function inList(e, t) {
        for (var n = t; n; n = n.next)
            if (n.name == e) return !0;
        return !1
    }

    function register(t) {
        var n = P.state;
        if (P.marked = "def", n.context)
            if ("var" == n.lexical.info && n.context && n.context.block) {
                var o = registerVarScoped(t, n.context);
                if (null != o) return void(n.context = o)
            } else if (!inList(t, n.localVars)) return void(n.localVars = new Var(t, n.localVars));
        e.globalVars && !inList(t, n.globalVars) && (n.globalVars = new Var(t, n.globalVars))
    }

    function registerVarScoped(e, t) {
        if (t) {
            if (t.block) {
                var n = registerVarScoped(e, t.prev);
                return n ? n == t.prev ? t : new Context(n, t.vars, !0) : null
            }
            return inList(e, t.vars) ? t : new Context(t.prev, new Var(e, t.vars), !1)
        }
        return null
    }

    function isModifier(e) {
        return "public" == e || "private" == e || "protected" == e || "abstract" == e || "readonly" == e
    }

    function Context(e, t, n) {
        this.prev = e, this.vars = t, this.block = n
    }

    function Var(e, t) {
        this.name = e, this.next = t
    }
    var C = new Var("this", new Var("arguments", null));

    function pushcontext() {
        P.state.context = new Context(P.state.context, P.state.localVars, !1), P.state.localVars = C
    }

    function pushblockcontext() {
        P.state.context = new Context(P.state.context, P.state.localVars, !0), P.state.localVars = null
    }

    function popcontext() {
        P.state.localVars = P.state.context.vars, P.state.context = P.state.context.prev
    }

    function pushlex(e, t) {
        var result = function() {
            var n = P.state,
                o = n.indented;
            if ("stat" == n.lexical.type) o = n.lexical.indented;
            else
                for (var h = n.lexical; h && ")" == h.type && h.align; h = h.prev) o = h.indented;
            n.lexical = new JSLexical(o, P.stream.column(), e, null, n.lexical, t)
        };
        return result.lex = !0, result
    }

    function poplex() {
        var e = P.state;
        e.lexical.prev && (")" == e.lexical.type && (e.indented = e.lexical.indented), e.lexical = e.lexical.prev)
    }

    function expect(e) {
        return function exp(t) {
            return t == e ? cont() : ";" == e || "}" == t || ")" == t || "]" == t ? pass() : cont(exp)
        }
    }

    function statement(e, t) {
        return "var" == e ? cont(pushlex("vardef", t), vardef, expect(";"), poplex) : "keyword a" == e ? cont(pushlex("form"), parenExpr, statement, poplex) : "keyword b" == e ? cont(pushlex("form"), statement, poplex) : "keyword d" == e ? P.stream.match(/^\s*$/, !1) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex) : "debugger" == e ? cont(expect(";")) : "{" == e ? cont(pushlex("}"), pushblockcontext, block, poplex, popcontext) : ";" == e ? cont() : "if" == e ? ("else" == P.state.lexical.info && P.state.cc[P.state.cc.length - 1] == poplex && P.state.cc.pop()(), cont(pushlex("form"), parenExpr, statement, poplex, maybeelse)) : "function" == e ? cont(functiondef) : "for" == e ? cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex) : "class" == e || p && "interface" == t ? (P.marked = "keyword", cont(pushlex("form", "class" == e ? e : t), className, poplex)) : "variable" == e ? p && "declare" == t ? (P.marked = "keyword", cont(statement)) : p && ("module" == t || "enum" == t || "type" == t) && P.stream.match(/^\s*\w/, !1) ? (P.marked = "keyword", "enum" == t ? cont(enumdef) : "type" == t ? cont(typename, expect("operator"), typeexpr, expect(";")) : cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)) : p && "namespace" == t ? (P.marked = "keyword", cont(pushlex("form"), expression, statement, poplex)) : p && "abstract" == t ? (P.marked = "keyword", cont(statement)) : cont(pushlex("stat"), maybelabel) : "switch" == e ? cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext) : "case" == e ? cont(expression, expect(":")) : "default" == e ? cont(expect(":")) : "catch" == e ? cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext) : "export" == e ? cont(pushlex("stat"), afterExport, poplex) : "import" == e ? cont(pushlex("stat"), afterImport, poplex) : "async" == e ? cont(statement) : "@" == t ? cont(expression, statement) : pass(pushlex("stat"), expression, expect(";"), poplex)
    }

    function maybeCatchBinding(e) {
        if ("(" == e) return cont(funarg, expect(")"))
    }

    function expression(e, t) {
        return expressionInner(e, t, !1)
    }

    function expressionNoComma(e, t) {
        return expressionInner(e, t, !0)
    }

    function parenExpr(e) {
        return "(" != e ? pass() : cont(pushlex(")"), maybeexpression, expect(")"), poplex)
    }

    function expressionInner(e, t, n) {
        if (P.state.fatArrowAt == P.stream.start) {
            var o = n ? arrowBodyNoComma : arrowBody;
            if ("(" == e) return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), o, popcontext);
            if ("variable" == e) return pass(pushcontext, pattern, expect("=>"), o, popcontext)
        }
        var h = n ? maybeoperatorNoComma : maybeoperatorComma;
        return v.hasOwnProperty(e) ? cont(h) : "function" == e ? cont(functiondef, h) : "class" == e || p && "interface" == t ? (P.marked = "keyword", cont(pushlex("form"), classExpression, poplex)) : "keyword c" == e || "async" == e ? cont(n ? expressionNoComma : expression) : "(" == e ? cont(pushlex(")"), maybeexpression, expect(")"), poplex, h) : "operator" == e || "spread" == e ? cont(n ? expressionNoComma : expression) : "[" == e ? cont(pushlex("]"), arrayLiteral, poplex, h) : "{" == e ? contCommasep(objprop, "}", null, h) : "quasi" == e ? pass(quasi, h) : "new" == e ? cont(function(e) {
            return function(t) {
                return "." == t ? cont(e ? targetNoComma : target) : "variable" == t && p ? cont(maybeTypeArgs, e ? maybeoperatorNoComma : maybeoperatorComma) : pass(e ? expressionNoComma : expression)
            }
        }(n)) : cont()
    }

    function maybeexpression(e) {
        return e.match(/[;\}\)\],]/) ? pass() : pass(expression)
    }

    function maybeoperatorComma(e, t) {
        return "," == e ? cont(maybeexpression) : maybeoperatorNoComma(e, t, !1)
    }

    function maybeoperatorNoComma(e, t, n) {
        var o = 0 == n ? maybeoperatorComma : maybeoperatorNoComma,
            h = 0 == n ? expression : expressionNoComma;
        return "=>" == e ? cont(pushcontext, n ? arrowBodyNoComma : arrowBody, popcontext) : "operator" == e ? /\+\+|--/.test(t) || p && "!" == t ? cont(o) : p && "<" == t && P.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, !1) ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, o) : "?" == t ? cont(expression, expect(":"), h) : cont(h) : "quasi" == e ? pass(quasi, o) : ";" != e ? "(" == e ? contCommasep(expressionNoComma, ")", "call", o) : "." == e ? cont(property, o) : "[" == e ? cont(pushlex("]"), maybeexpression, expect("]"), poplex, o) : p && "as" == t ? (P.marked = "keyword", cont(typeexpr, o)) : "regexp" == e ? (P.state.lastType = P.marked = "operator", P.stream.backUp(P.stream.pos - P.stream.start - 1), cont(h)) : void 0 : void 0
    }

    function quasi(e, t) {
        return "quasi" != e ? pass() : "${" != t.slice(t.length - 2) ? cont(quasi) : cont(maybeexpression, continueQuasi)
    }

    function continueQuasi(e) {
        if ("}" == e) return P.marked = "string.special", P.state.tokenize = tokenQuasi, cont(quasi)
    }

    function arrowBody(e) {
        return findFatArrow(P.stream, P.state), pass("{" == e ? statement : expression)
    }

    function arrowBodyNoComma(e) {
        return findFatArrow(P.stream, P.state), pass("{" == e ? statement : expressionNoComma)
    }

    function target(e, t) {
        if ("target" == t) return P.marked = "keyword", cont(maybeoperatorComma)
    }

    function targetNoComma(e, t) {
        if ("target" == t) return P.marked = "keyword", cont(maybeoperatorNoComma)
    }

    function maybelabel(e) {
        return ":" == e ? cont(poplex, statement) : pass(maybeoperatorComma, expect(";"), poplex)
    }

    function property(e) {
        if ("variable" == e) return P.marked = "property", cont()
    }

    function objprop(e, t) {
        return "async" == e ? (P.marked = "property", cont(objprop)) : "variable" == e || "keyword" == P.style ? (P.marked = "property", "get" == t || "set" == t ? cont(getterSetter) : (p && P.state.fatArrowAt == P.stream.start && (n = P.stream.match(/^\s*:\s*/, !1)) && (P.state.fatArrowAt = P.stream.pos + n[0].length), cont(afterprop))) : "number" == e || "string" == e ? (P.marked = o ? "property" : P.style + " property", cont(afterprop)) : "jsonld-keyword" == e ? cont(afterprop) : p && isModifier(t) ? (P.marked = "keyword", cont(objprop)) : "[" == e ? cont(expression, maybetype, expect("]"), afterprop) : "spread" == e ? cont(expressionNoComma, afterprop) : "*" == t ? (P.marked = "keyword", cont(objprop)) : ":" == e ? pass(afterprop) : void 0;
        var n
    }

    function getterSetter(e) {
        return "variable" != e ? pass(afterprop) : (P.marked = "property", cont(functiondef))
    }

    function afterprop(e) {
        return ":" == e ? cont(expressionNoComma) : "(" == e ? pass(functiondef) : void 0
    }

    function commasep(e, t, n) {
        function proceed(o, h) {
            if (n ? n.indexOf(o) > -1 : "," == o) {
                var p = P.state.lexical;
                return "call" == p.info && (p.pos = (p.pos || 0) + 1), cont((function(n, o) {
                    return n == t || o == t ? pass() : pass(e)
                }), proceed)
            }
            return o == t || h == t ? cont() : n && n.indexOf(";") > -1 ? pass(e) : cont(expect(t))
        }
        return function(n, o) {
            return n == t || o == t ? cont() : pass(e, proceed)
        }
    }

    function contCommasep(e, t, n) {
        for (var o = 3; o < arguments.length; o++) P.cc.push(arguments[o]);
        return cont(pushlex(t, n), commasep(e, t), poplex)
    }

    function block(e) {
        return "}" == e ? cont() : pass(statement, block)
    }

    function maybetype(e, t) {
        if (p) {
            if (":" == e) return cont(typeexpr);
            if ("?" == t) return cont(maybetype)
        }
    }

    function maybetypeOrIn(e, t) {
        if (p && (":" == e || "in" == t)) return cont(typeexpr)
    }

    function mayberettype(e) {
        if (p && ":" == e) return P.stream.match(/^\s*\w+\s+is\b/, !1) ? cont(expression, isKW, typeexpr) : cont(typeexpr)
    }

    function isKW(e, t) {
        if ("is" == t) return P.marked = "keyword", cont()
    }

    function typeexpr(e, t) {
        return "keyof" == t || "typeof" == t || "infer" == t || "readonly" == t ? (P.marked = "keyword", cont("typeof" == t ? expressionNoComma : typeexpr)) : "variable" == e || "void" == t ? (P.marked = "type", cont(afterType)) : "|" == t || "&" == t ? cont(typeexpr) : "string" == e || "number" == e || "atom" == e ? cont(afterType) : "[" == e ? cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType) : "{" == e ? cont(pushlex("}"), typeprops, poplex, afterType) : "(" == e ? cont(commasep(typearg, ")"), maybeReturnType, afterType) : "<" == e ? cont(commasep(typeexpr, ">"), typeexpr) : "quasi" == e ? pass(quasiType, afterType) : void 0
    }

    function maybeReturnType(e) {
        if ("=>" == e) return cont(typeexpr)
    }

    function typeprops(e) {
        return e.match(/[\}\)\]]/) ? cont() : "," == e || ";" == e ? cont(typeprops) : pass(typeprop, typeprops)
    }

    function typeprop(e, t) {
        return "variable" == e || "keyword" == P.style ? (P.marked = "property", cont(typeprop)) : "?" == t || "number" == e || "string" == e ? cont(typeprop) : ":" == e ? cont(typeexpr) : "[" == e ? cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop) : "(" == e ? pass(functiondecl, typeprop) : e.match(/[;\}\)\],]/) ? void 0 : cont()
    }

    function quasiType(e, t) {
        return "quasi" != e ? pass() : "${" != t.slice(t.length - 2) ? cont(quasiType) : cont(typeexpr, continueQuasiType)
    }

    function continueQuasiType(e) {
        if ("}" == e) return P.marked = "string.special", P.state.tokenize = tokenQuasi, cont(quasiType)
    }

    function typearg(e, t) {
        return "variable" == e && P.stream.match(/^\s*[?:]/, !1) || "?" == t ? cont(typearg) : ":" == e ? cont(typeexpr) : "spread" == e ? cont(typearg) : pass(typeexpr)
    }

    function afterType(e, t) {
        return "<" == t ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType) : "|" == t || "." == e || "&" == t ? cont(typeexpr) : "[" == e ? cont(typeexpr, expect("]"), afterType) : "extends" == t || "implements" == t ? (P.marked = "keyword", cont(typeexpr)) : "?" == t ? cont(typeexpr, expect(":"), typeexpr) : void 0
    }

    function maybeTypeArgs(e, t) {
        if ("<" == t) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
    }

    function typeparam() {
        return pass(typeexpr, maybeTypeDefault)
    }

    function maybeTypeDefault(e, t) {
        if ("=" == t) return cont(typeexpr)
    }

    function vardef(e, t) {
        return "enum" == t ? (P.marked = "keyword", cont(enumdef)) : pass(pattern, maybetype, maybeAssign, vardefCont)
    }

    function pattern(e, t) {
        return p && isModifier(t) ? (P.marked = "keyword", cont(pattern)) : "variable" == e ? (register(t), cont()) : "spread" == e ? cont(pattern) : "[" == e ? contCommasep(eltpattern, "]") : "{" == e ? contCommasep(proppattern, "}") : void 0
    }

    function proppattern(e, t) {
        return "variable" != e || P.stream.match(/^\s*:/, !1) ? ("variable" == e && (P.marked = "property"), "spread" == e ? cont(pattern) : "}" == e ? pass() : "[" == e ? cont(expression, expect("]"), expect(":"), proppattern) : cont(expect(":"), pattern, maybeAssign)) : (register(t), cont(maybeAssign))
    }

    function eltpattern() {
        return pass(pattern, maybeAssign)
    }

    function maybeAssign(e, t) {
        if ("=" == t) return cont(expressionNoComma)
    }

    function vardefCont(e) {
        if ("," == e) return cont(vardef)
    }

    function maybeelse(e, t) {
        if ("keyword b" == e && "else" == t) return cont(pushlex("form", "else"), statement, poplex)
    }

    function forspec(e, t) {
        return "await" == t ? cont(forspec) : "(" == e ? cont(pushlex(")"), forspec1, poplex) : void 0
    }

    function forspec1(e) {
        return "var" == e ? cont(vardef, forspec2) : "variable" == e ? cont(forspec2) : pass(forspec2)
    }

    function forspec2(e, t) {
        return ")" == e ? cont() : ";" == e ? cont(forspec2) : "in" == t || "of" == t ? (P.marked = "keyword", cont(expression, forspec2)) : pass(expression, forspec2)
    }

    function functiondef(e, t) {
        return "*" == t ? (P.marked = "keyword", cont(functiondef)) : "variable" == e ? (register(t), cont(functiondef)) : "(" == e ? cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext) : p && "<" == t ? cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef) : void 0
    }

    function functiondecl(e, t) {
        return "*" == t ? (P.marked = "keyword", cont(functiondecl)) : "variable" == e ? (register(t), cont(functiondecl)) : "(" == e ? cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext) : p && "<" == t ? cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl) : void 0
    }

    function typename(e, t) {
        return "keyword" == e || "variable" == e ? (P.marked = "type", cont(typename)) : "<" == t ? cont(pushlex(">"), commasep(typeparam, ">"), poplex) : void 0
    }

    function funarg(e, t) {
        return "@" == t && cont(expression, funarg), "spread" == e ? cont(funarg) : p && isModifier(t) ? (P.marked = "keyword", cont(funarg)) : p && "this" == e ? cont(maybetype, maybeAssign) : pass(pattern, maybetype, maybeAssign)
    }

    function classExpression(e, t) {
        return "variable" == e ? className(e, t) : classNameAfter(e, t)
    }

    function className(e, t) {
        if ("variable" == e) return register(t), cont(classNameAfter)
    }

    function classNameAfter(e, t) {
        return "<" == t ? cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter) : "extends" == t || "implements" == t || p && "," == e ? ("implements" == t && (P.marked = "keyword"), cont(p ? typeexpr : expression, classNameAfter)) : "{" == e ? cont(pushlex("}"), classBody, poplex) : void 0
    }

    function classBody(e, t) {
        return "async" == e || "variable" == e && ("static" == t || "get" == t || "set" == t || p && isModifier(t)) && P.stream.match(/^\s+#?[\w$\xa1-\uffff]/, !1) ? (P.marked = "keyword", cont(classBody)) : "variable" == e || "keyword" == P.style ? (P.marked = "property", cont(classfield, classBody)) : "number" == e || "string" == e ? cont(classfield, classBody) : "[" == e ? cont(expression, maybetype, expect("]"), classfield, classBody) : "*" == t ? (P.marked = "keyword", cont(classBody)) : p && "(" == e ? pass(functiondecl, classBody) : ";" == e || "," == e ? cont(classBody) : "}" == e ? cont() : "@" == t ? cont(expression, classBody) : void 0
    }

    function classfield(e, t) {
        if ("!" == t || "?" == t) return cont(classfield);
        if (":" == e) return cont(typeexpr, maybeAssign);
        if ("=" == t) return cont(expressionNoComma);
        var n = P.state.lexical.prev;
        return pass(n && "interface" == n.info ? functiondecl : functiondef)
    }

    function afterExport(e, t) {
        return "*" == t ? (P.marked = "keyword", cont(maybeFrom, expect(";"))) : "default" == t ? (P.marked = "keyword", cont(expression, expect(";"))) : "{" == e ? cont(commasep(exportField, "}"), maybeFrom, expect(";")) : pass(statement)
    }

    function exportField(e, t) {
        return "as" == t ? (P.marked = "keyword", cont(expect("variable"))) : "variable" == e ? pass(expressionNoComma, exportField) : void 0
    }

    function afterImport(e) {
        return "string" == e ? cont() : "(" == e ? pass(expression) : "." == e ? pass(maybeoperatorComma) : pass(importSpec, maybeMoreImports, maybeFrom)
    }

    function importSpec(e, t) {
        return "{" == e ? contCommasep(importSpec, "}") : ("variable" == e && register(t), "*" == t && (P.marked = "keyword"), cont(maybeAs))
    }

    function maybeMoreImports(e) {
        if ("," == e) return cont(importSpec, maybeMoreImports)
    }

    function maybeAs(e, t) {
        if ("as" == t) return P.marked = "keyword", cont(importSpec)
    }

    function maybeFrom(e, t) {
        if ("from" == t) return P.marked = "keyword", cont(expression)
    }

    function arrayLiteral(e) {
        return "]" == e ? cont() : pass(commasep(expressionNoComma, "]"))
    }

    function enumdef() {
        return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
    }

    function enummember() {
        return pass(pattern, maybeAssign)
    }
    return pushcontext.lex = pushblockcontext.lex = !0, popcontext.lex = !0, poplex.lex = !0, {
        name: e.name,
        startState: function(t) {
            var n = {
                tokenize: tokenOuter,
                lastType: "sof",
                cc: [],
                lexical: new JSLexical(-t, 0, "block", !1),
                localVars: e.localVars,
                context: e.localVars && new Context(null, null, !1),
                indented: 0,
                bracketDepth: 0,
                inSquareBlock: !1,
                inFunctionBlock: !1,
                functionIndentLevel: 0,
                outerEscaped: !1,
                restOfLineIsOuterComment: !1,
                completedJsBlockRanges: [],
                activeJsBlockStartPos: null,
                activeJsBlockContext: null,
                prevLineEndDocPos: 0,
                currentLineStartDocPos: 0,
                seenFirstLine: !1
            };
            return e.globalVars && "object" == typeof e.globalVars && (n.globalVars = e.globalVars), n
        },
        token: function(e, n) {
            let o;
            P.state = n, P.stream = e, P.cc = n.cc, e.sol() && (n.currentLineStartDocPos = n.prevLineEndDocPos + (n.seenFirstLine ? 1 : 0), n.seenFirstLine || (n.seenFirstLine = !0), n.lexical.hasOwnProperty("align") || (n.lexical.align = !1), n.indented = e.indentation(), findFatArrow(e, n), n.inSquareBlock && (n.activeJsBlockContext = "missing_close", exitJsBlock(e, n, "square")), n.inFunctionBlock && e.indentation() <= n.functionIndentLevel && !/^\s*\/\//.test(e.string) && "" !== e.string.trim() && exitJsBlock(e, n, "function"));
            let p = !1;
            return n.tokenize != tokenComment && e.eatSpace() ? (o = null, p = !0) : o = n.tokenize(e, n), e.eol() && (n.prevLineEndDocPos = n.currentLineStartDocPos + e.string.length), t.jsBlockRanges = n.completedJsBlockRanges, p || "comment" == S ? o : n.inSquareBlock || n.inFunctionBlock ? (n.lastType = "operator" != S || "++" != k && "--" != k ? S : "incdec", function(e, t, n, o, p) {
                var f = e.cc;
                for (P.state = e, P.stream = p, P.marked = null, P.cc = f, P.style = t, e.lexical.hasOwnProperty("align") || (e.lexical.align = !0);;)
                    if ((f.length ? f.pop() : h ? expression : statement)(n, o)) {
                        for (; f.length && f[f.length - 1].lex;) f.pop()();
                        return P.marked ? P.marked : "variable" == n && inScope(e, o) ? "variableName.local" : t
                    }
            }(n, o, S, k, e)) : o
        },
        blankLine: function(e, t) {
            e.currentLineStartDocPos = e.prevLineEndDocPos + (e.seenFirstLine ? 1 : 0), e.seenFirstLine || (e.seenFirstLine = !0), e.prevLineEndDocPos = e.currentLineStartDocPos
        },
        indent: function(t, o, h) {
            if (t.tokenize == tokenComment || t.tokenize == tokenQuasi) return null;
            if (t.tokenize != tokenBase) {
                if (t.tokenize == tokenOuter) {
                    if (h.pos - 1 < 0) return null;
                    let e = h.lineAt(h.pos - 1).text.match(/^\s*/)[0].length,
                        t = h.pos + 1 > h.state.doc.length ? void 0 : h.lineAt(h.pos + 1) ? .text ? .match(/^\s*/)[0].length;
                    return t === e + h.unit ? t : null
                }
                return 0
            }
            var p, f = o && o.charAt(0),
                g = t.lexical;
            if (!/^\s*else\b/.test(o))
                for (var w = t.cc.length - 1; w >= 0; --w) {
                    var b = t.cc[w];
                    if (b == poplex) g = g.prev;
                    else if (b != maybeelse && b != popcontext) break
                }
            for (;
                ("stat" == g.type || "form" == g.type) && ("}" == f || (p = t.cc[t.cc.length - 1]) && (p == maybeoperatorComma || p == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(o));) g = g.prev;
            n && ")" == g.type && "stat" == g.prev.type && (g = g.prev);
            var S = g.type,
                k = f == S;
            if ("vardef" == S) return g.indented + ("operator" == t.lastType || "," == t.lastType ? g.info.length + 1 : 0);
            if ("form" == S && "{" == f) return g.indented;
            if ("form" == S) return g.indented + h.unit;
            if ("stat" == S) return g.indented + (function(e, t) {
                return "operator" == e.lastType || "," == e.lastType || y.test(t.charAt(0)) || /[,.]/.test(t.charAt(0))
            }(t, o) ? n || h.unit : 0);
            if ("switch" != g.info || k || 0 == e.doubleIndentSwitch) {
                if (g.align) return g.column + (k ? 0 : 1); {
                    let e = g.indented + (k ? 0 : h.unit);
                    return 0 === e && t.inFunctionBlock ? e + (t.functionIndentLevel + h.unit) : e
                }
            }
            return g.indented + (/^(?:case|default)\b/.test(o) ? h.unit : 2 * h.unit)
        },
        languageData: {
            indentOnInput: /^\s*(?:case .*?:|default:|\{|\})$/,
            commentTokens: h ? void 0 : {
                line: "//",
                block: {
                    open: "/*",
                    close: "*/"
                }
            },
            closeBrackets: {
                brackets: ["(", "[", "{", "'", '"', "`"]
            },
            wordChars: "$"
        }
    }
}

function getIndentationBasedFoldRangeByLineStart(e, t) {
    const n = e.doc,
        o = n.lineAt(t),
        h = o.text.replace(/\t/g, "  ");
    if ("" === h.trim()) return null;
    const p = h.match(/^\s*/)[0].length;
    if (!(o.number < n.lines)) return null; {
        const e = n.line(o.number + 1);
        if ("" !== e.text.trim() && e.text.replace(/\t/g, "  ").match(/^\s*/)[0].length <= p) return null
    }
    let f = null;
    for (let e = o.number + 1; e <= n.lines; e++) {
        const t = n.line(e),
            o = t.text.replace(/\t/g, "  ");
        if ("" === o.trim()) continue;
        if (o.match(/^\s*/)[0].length <= p) break;
        f = t.to
    }
    return null !== f ? {
        from: o.to,
        to: f
    } : null
}

function solarizedLightTheme() {
    const e = HighlightStyle,
        t = syntaxHighlighting,
        n = ai;
    var o = {
            name: "solarizedLight",
            dark: !1,
            background: "#FDF6E3",
            foreground: "#586E75",
            selection: "#EEE8D5",
            cursor: "#657B83",
            dropdownBackground: "#FDF6E3",
            dropdownBorder: "#D3AF86",
            activeLine: "#d5bd5c22",
            matchingBracket: "#EEE8D5",
            keyword: "#859900",
            storage: "#586E75",
            variable: "#268BD2",
            parameter: "#268BD2",
            function: "#268BD2",
            string: "#2AA198",
            constant: "#CB4B16",
            type: "#CB4B16",
            class: "#CB4B16",
            number: "#D33682",
            comment: "#93A1A1",
            heading: "#268BD2",
            invalid: "#DC322F",
            regexp: "#DC322F"
        },
        h = EditorView.theme({
            "&": {
                color: o.foreground,
                backgroundColor: o.background
            },
            ".cm-content": {
                caretColor: o.cursor
            },
            ".cm-cursor, .cm-dropCursor": {
                borderLeftColor: o.cursor
            },
            "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": {
                backgroundColor: o.selection
            },
            ".cm-panels": {
                backgroundColor: o.dropdownBackground,
                color: o.foreground
            },
            ".cm-panels.cm-panels-top": {
                borderBottom: "2px solid black"
            },
            ".cm-panels.cm-panels-bottom": {
                borderTop: "2px solid black"
            },
            ".cm-searchMatch": {
                backgroundColor: o.dropdownBackground,
                outline: `1px solid ${o.dropdownBorder}`
            },
            ".cm-searchMatch.cm-searchMatch-selected": {
                backgroundColor: o.selection
            },
            ".cm-activeLine": {
                backgroundColor: o.activeLine
            },
            ".cm-selectionMatch": {
                backgroundColor: o.selection
            },
            "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
                backgroundColor: o.matchingBracket,
                outline: "none"
            },
            ".cm-gutters": {
                backgroundColor: o.background,
                color: o.foreground,
                border: "none"
            },
            ".cm-activeLineGutter": {
                backgroundColor: o.background
            },
            ".cm-foldPlaceholder": {
                backgroundColor: "transparent",
                border: "none",
                color: o.foreground
            },
            ".cm-tooltip": {
                border: `1px solid ${o.dropdownBorder}`,
                backgroundColor: o.dropdownBackground,
                color: o.foreground
            },
            ".cm-tooltip .cm-tooltip-arrow:before": {
                borderTopColor: "transparent",
                borderBottomColor: "transparent"
            },
            ".cm-tooltip .cm-tooltip-arrow:after": {
                borderTopColor: o.foreground,
                borderBottomColor: o.foreground
            },
            ".cm-tooltip-autocomplete": {
                "& > ul > li[aria-selected]": {
                    background: o.selection,
                    color: o.foreground
                }
            }
        }, {
            dark: o.dark
        }),
        p = e.define([{
            tag: n.keyword,
            color: o.keyword
        }, {
            tag: [n.name, n.deleted, n.character, n.macroName],
            color: o.variable
        }, {
            tag: [n.propertyName],
            color: o.function
        }, {
            tag: [n.processingInstruction, n.string, n.inserted, n.special(n.string)],
            color: o.string
        }, {
            tag: [n.function(n.variableName), n.labelName],
            color: o.function
        }, {
            tag: [n.color, n.constant(n.name), n.standard(n.name)],
            color: o.constant
        }, {
            tag: [n.definition(n.name), n.separator],
            color: o.variable
        }, {
            tag: [n.className],
            color: o.class
        }, {
            tag: [n.number, n.changed, n.annotation, n.modifier, n.self, n.namespace],
            color: o.number
        }, {
            tag: [n.typeName],
            color: o.type,
            fontStyle: o.type
        }, {
            tag: [n.operator, n.operatorKeyword],
            color: o.keyword
        }, {
            tag: [n.url, n.escape, n.regexp, n.link],
            color: o.regexp
        }, {
            tag: [n.meta, n.comment],
            color: o.comment
        }, {
            tag: n.strong,
            fontWeight: "bold"
        }, {
            tag: n.emphasis,
            fontStyle: "italic"
        }, {
            tag: n.link,
            textDecoration: "underline"
        }, {
            tag: n.heading,
            fontWeight: "bold",
            color: o.heading
        }, {
            tag: [n.atom, n.bool, n.special(n.variableName)],
            color: o.variable
        }, {
            tag: n.invalid,
            color: o.invalid
        }, {
            tag: n.strikethrough,
            textDecoration: "line-through"
        }]);
    return {
        config: o,
        solarizedLight: [h, t(p)],
        solarizedLightHighlightStyle: p,
        solarizedLightTheme: h
    }
}

function createEditorView(e = {}) {
    const t = e.yText ? ? window.yDoc.getText(e.docId);
    let n = new Compartment,
        o = new Compartment;
    const h = StateEffect.define(),
        p = StateEffect.define(),
        f = StateField.define({
            create: () => Decoration.none,
            update(e, t) {
                e = e.map(t.changes);
                for (let n of t.effects) {
                    if (n.is(h)) {
                        let t = Decoration.mark({
                            class: n.value.className || "cm-marked-text",
                            attributes: n.value.attributes || {}
                        }).range(n.value.from, n.value.to);
                        e = e.update({
                            add: [t]
                        })
                    }
                    n.is(p) && (e = Decoration.none)
                }
                return e
            },
            provide: e => EditorView.decorations.from(e)
        });
    let g = function(e = {}) {
            let t = fr.find((e => "Alt-ArrowUp" == e.key)).run,
                n = fr.find((e => "Alt-ArrowDown" == e.key)).run,
                o = fr.find((e => "Shift-Alt-ArrowDown" == e.key)).run;
            document.__alreadyAddedCtrlShiftDPreventDefault || (document.__alreadyAddedCtrlShiftDPreventDefault = !0, document.addEventListener("keydown", (e => {
                (e.ctrlKey || e.metaKey) && e.shiftKey && "D" === e.key && e.stopPropagation()
            })));
            for (let e of Fr) "Ctrl-Space" === e.key && (e.key = "Alt-Shift-Space");
            let h = [...dr],
                p = {};
            window.yjsProvider && (p.undoManager = new window.Yjs.UndoManager(e.yText), window.editorUndoManagers || (window.editorUndoManagers = {}), window.editorUndoManagers[e.docId] = p.undoManager, h = [{
                key: "Mod-z",
                preventDefault: !0,
                run: () => p.undoManager.undo()
            }, {
                key: "Mod-y",
                mac: "Mod-Shift-z",
                preventDefault: !0,
                run: () => p.undoManager.redo()
            }, {
                linux: "Ctrl-Shift-z",
                preventDefault: !0,
                run: () => p.undoManager.redo()
            }]);
            let f = [lineNumbers(), window.yjsProvider ? null : history(), highlightActiveLineGutter(), highlightSpecialChars(), foldGutter({
                openText: "â–¾",
                closedText: "â–¸"
            }), drawSelection(), mi.of("  "), EditorState.tabSize.of(2), codeFolding({
                placeholderText: "â‹¯"
            }), yi.of(getIndentationBasedFoldRangeByLineStart), EditorState.allowMultipleSelections.of(!0), EditorState.transactionFilter.of((e => {
                if (!e.docChanged || !e.isUserEvent("input.type") && !e.isUserEvent("input.complete")) return e;
                let t = e.startState.languageDataAt("indentOnInput", e.startState.selection.main.head);
                if (!t.length) return e;
                let n = e.newDoc,
                    {
                        head: o
                    } = e.newSelection.main,
                    h = n.lineAt(o);
                if (o > h.from + 200) return e;
                let p = n.sliceString(h.from, o);
                if (!t.some((e => e.test(p)))) return e;
                let {
                    state: f
                } = e, g = -1, y = [];
                for (let {
                        head: e
                    } of f.selection.ranges) {
                    let t = f.doc.lineAt(e);
                    if (t.from == g) continue;
                    g = t.from;
                    let n = getIndentation(f, t.from);
                    if (null == n) continue;
                    let o = /^\s*/.exec(t.text)[0],
                        h = indentString(f, n);
                    o != h && y.push({
                        from: t.from,
                        to: t.from + o.length,
                        insert: h
                    })
                }
                return y.length ? [e, {
                    changes: y,
                    sequential: !0
                }] : e
            })), bracketMatching(), [Wr, Nr], dropCursor(), autocompletion(), EditorView.clickAddsSelectionRange.of((e => e.altKey || e.ctrlKey)), crosshairCursor(), highlightActiveLine(), [co, lo], e.lineWrappingCompartment.of([]), createFunctionFinderExtension({
                yText: e.yText,
                docId: e.docId
            }), Kc(e.yText, window.yjsProvider ? window.yjsProvider.awareness : void 0, p), lintGutter(), linter(Hc(e.docId, e.lintContext)), Qt.of([gr, ...Ur, ...fr, ...vo, ...h, ...ki, ...Do, ...Fr, {
                key: "Ctrl-Shift-ArrowUp",
                run: t
            }, {
                key: "Ctrl-Shift-ArrowDown",
                run: n
            }, {
                key: "Ctrl-Shift-d",
                run: o
            }]), syntaxHighlighting(HighlightStyle.define([{
                tag: ai.variableName,
                color: "light-dark(#c50074, #e66556)"
            }, {
                tag: ai.definition(ai.variableName),
                color: "light-dark(#c67600, #e5c07b)"
            }, {
                tag: ai.local(ai.variableName),
                color: "light-dark(#268BD2, #cacaca)"
            }, {
                tag: ai.propertyName,
                color: "light-dark(#435156, #56b6c2)"
            }, {
                tag: ai.typeOperator,
                color: "light-dark(#CB4B16, #fcae1d)"
            }, {
                tag: ai.special(ai.string),
                color: "light-dark(#099bb5, #63b86c)"
            }, {
                tag: ai.regexp,
                color: "light-dark(#8140d0, #25aa65)"
            }])), EditorView.theme({}, {
                dark: e.darkMode
            })].filter((e => e));
            return !1 !== e.darkMode && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? f.push(e.themeCompartment.of(Tl)) : f.push(e.themeCompartment.of(solarizedLightTheme().solarizedLight)), e.extensions && f.push(...e.extensions), EditorState.create({
                doc: e.yText.toString() || "",
                extensions: f
            })
        }({
            yText: t,
            docId: e.docId,
            lineWrappingCompartment: n,
            themeCompartment: o,
            lintContext: e.lintContext,
            extensions: [...e.extraStateExtensions, f]
        }),
        y = new EditorView({
            state: g,
            parent: e.parentElement
        });
    window.editorViewsByDocId || (window.editorViewsByDocId = {}), window.editorViewsByDocId[e.docId] || (window.editorViewsByDocId[e.docId] = []), window.editorViewsByDocId[e.docId].push(y);
    const linePosToDocPos = e => {
        if ("number" == typeof e) return e;
        const t = y.state.doc.line(e.line + 1);
        return t.from + Math.min(e.ch, t.length)
    };
    y._markText = (e, t, n = {}) => {
        requestAnimationFrame((() => {
            let o = linePosToDocPos(e),
                p = linePosToDocPos(t);
            o !== p && y.dispatch({
                effects: h.of({
                    from: o,
                    to: p,
                    ...n
                })
            })
        }))
    }, y._clearMarks = () => {
        requestAnimationFrame((() => {
            y.dispatch({
                effects: p.of(null)
            })
        }))
    };
    const w = '<svg style="height:1.3rem;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 7h14M5 12h11c1 0 3 .5 3 2.5S17.333 17 16.5 17H12m-7 0h4m3 0 2-2m-2 2 2 2"/></svg>',
        b = '<svg style="height:1.3rem;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5h10m-10 7h10m-10 7h10"/><circle cx="5" cy="5" r="2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/><circle cx="5" cy="5" r="2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/><circle cx="5" cy="12" r="2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/><circle cx="5" cy="19" r="2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/></svg>';
    let S, k;
    y._linesAreWrapped = !1, y._toggleLineWrapping = function() {
        y.dispatch({
            effects: n.reconfigure(y._linesAreWrapped ? [] : EditorView.lineWrapping)
        }), y._linesAreWrapped = !y._linesAreWrapped, y._afterToggleLineWrapping && y._afterToggleLineWrapping(), S.innerHTML = y._linesAreWrapped ? `${w} <span><u>un</u>wrap lines</span>` : `${w} wrap lines`
    }, y._linesAreFolded = !1, y._toggleLineFolding = function() {
        y._linesAreFolded ? unfoldAll(y) : foldAll(y), y._linesAreFolded = !y._linesAreFolded, y._afterToggleLineFolding && y._afterToggleLineFolding(), k.innerHTML = y._linesAreFolded ? `${b} <span><u>un</u>fold lines</span>` : `${b} fold lines`
    }, y._openPopoutEditorAtPos = function(t) {
        createPopupEditor({
            position: t,
            docId: e.docId
        })
    }, window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (e => {
        y.dispatch({
            effects: o.reconfigure(e.matches ? Tl : solarizedLightTheme().solarizedLight)
        })
    }));
    let v = function(e) {
        const t = `settings-item-${Math.random().toString(36).substr(2,9)}`,
            n = document.createElement("style");
        n.textContent = `.${t}:hover { background-color: light-dark(#f0f0f0, #383838); }`, document.head.append(n);
        const o = document.createElement("div");
        o.style.cssText = "font-family:inherit;";
        const h = document.createElement("div");
        h.textContent = "âš™ï¸", h.style.cssText = "user-select:none; cursor:pointer; font-size:0.75rem; display:inline-block; width:min-content; height:min-content; background:light-dark(#b7f4ff, #0d585c); padding:1px; border:1px solid light-dark(#66d6e0, #00737e); border-radius:3px; font-family:sans-serif; line-height:normal;";
        const p = document.createElement("div");
        p.hidden = !0, p.style.cssText = "position:absolute; top:calc(100% + 0.125rem); left:0; background:light-dark(white, #1e1e1e); border:1px solid light-dark(#ddd, #333); border-radius:4px; box-shadow:0 2px 10px light-dark(rgba(0,0,0,0.1), rgba(0,0,0,0.3)); min-width:max-content; z-index: 1000; font-size:0.85rem;";
        let f = [];
        for (let n of e.options) {
            const e = document.createElement("div");
            e.innerHTML = n.innerHTML, e.title = n.title || "", e.className = t, e.style.cssText = "padding:0.25rem 0.35rem; cursor:pointer; color:light-dark(inherit, #e0e0e0); display:flex; gap:0.25rem; align-items:center; font-size:90%; font-family:'Cousine', monospace;", e.onclick = t => {
                t.stopPropagation(), p.hidden = !0, n.onclick.bind(e)(t)
            }, e.name = n.name, p.append(e), f.push(e)
        }
        return h.onclick = e => {
            p.hidden = !p.hidden, e.stopPropagation()
        }, document.addEventListener("click", (() => p.hidden = !0)), o.append(h, p), {
            container: o,
            button: h,
            dropdown: p,
            items: f
        }
    }({
        options: [{
            name: "popout",
            title: "Open this editor in a new sub-window.",
            innerHTML: '<svg style="height:1.3rem;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 4H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-4m-8-2 8-8m0 0v5m0-5h-5"/></svg> <span>open popout</span>',
            onclick: function(e) {
                let t = y.state.selection.main.head,
                    {
                        from: n,
                        to: o
                    } = function(e) {
                        const t = e.scrollDOM.getBoundingClientRect(),
                            n = t.top - e.documentTop,
                            o = t.bottom - e.documentTop,
                            h = e.lineBlockAtHeight(n),
                            p = e.lineBlockAtHeight(o);
                        return {
                            from: h.from,
                            to: p.to
                        }
                    }(y),
                    h = t > n && t < o ? t : Math.round((n + o) / 2);
                y._openPopoutEditorAtPos(h)
            }
        }, {
            name: "collabLink",
            title: "Generate a collaboration link to share with others so you can work together in realtime.",
            innerHTML: '<svg style="height:1.3rem;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><circle cx="9" cy="9" r="4" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 19c0-3.314-3.134-6-7-6s-7 2.686-7 6m13-6a4 4 0 1 0-3-6.646"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M22 19c0-3.314-3.134-6-7-6-.807 0-2.103-.293-3-1.235"/></svg> <span id="collabLinkButtonLabelEl">collab link</span>',
            onclick: async function(e) {
                let t;
                if (!(await window.initialLoadIsOwnerPromise || window.userOwnsThisGenerator) && (t = localStorage[`perchance_generatorEditKey_${window.generatorName}`] || prompt("Please enter this generator's edit password to see/change the collaboration sharing link:", inMemoryGeneratorNameToEditKey[window.generatorName] || ""), !t)) return;
                let n, o = function(e, {
                    containerStyle: t
                } = {}) {
                    const n = document.createElement("div");
                    n.style.cssText = "position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:1000";
                    const o = document.createElement("div");
                    return o.style.cssText = `background:light-dark(white, #282c33);padding:0.5rem;border-radius:4px;max-width:700px;max-width:90vw;max-height:90vh;overflow:auto;${t||""}`, o.innerHTML = e, n.appendChild(o), document.body.appendChild(n), n.addEventListener("click", (e => e.target === n && n.remove())), {
                        close: () => n.remove(),
                        setContent: e => o.innerHTML = e,
                        element: n,
                        containerElement: o
                    }
                }('\n            <div id="collabLinkLoaderEl" style="width:100%; height:100%; display:flex; justify-content:center; padding:2rem;">â³ Loading...</div>\n            <div id="collabLinkContentEl" hidden>\n              <div style="display:flex; gap:0.25rem; align-items:center; justify-content:center;">\n                <div>Collab Link:</div>\n                <select id="collabEnableDisableSelectEl" disabled>\n                  <option value="disabled">disabled</option>\n                  <option value="enabled">enabled</option>\n                </select>\n              </div>\n              <div id="editorCollabLinkCtn" hidden>\n                <div style="margin-top:0.5rem; width:100%; display:flex; gap:0.25rem; align-items:stretch; justify-content:center;">\n                  <input id="editorCollabLinkEl" style="max-width:100%; width:100%; box-sizing:border-box;" placeholder="Link will appear here when enabled." value="" readonly onclick="this.select()" onkeydown="if(event.ctrlKey && event.key === \'a\') { event.preventDefault(); this.select(); }">\n                  <button id="copyEditorCollabLinkBtn" style="min-width:max-content;">ðŸ“‹ copy</button>\n                </div>\n                <div style="margin-top:0.5rem; text-align:center;"><button id="regenerateEditorCollabLinkBtn">ðŸ” regenerate link</button></div>\n                <p style="margin:0; margin-top:0.5rem; opacity:0.6;">If you share your collab link with someone, they\'ll be able to <b>edit</b>/<b>save</b> your generator, and you\'ll both able to see each other typing in realtime.</p>\n              </div>\n            </div>\n          ', {
                    containerStyle: `min-width:${window.innerWidth<500?370:480}px; max-width:${window.innerWidth<500?370:480}px; border:1px solid light-dark(#bababa, #444444);`
                });
                for (let e = 0; e < 2; e++) {
                    let e = await fetch(`/api/getCollabEditKey?generatorName=${window.generatorName}&sessionToken=${window.app.store.data.user.sessionToken||""}&email=${window.app.store.data.user.email||""}&editKey=${t||""}`).then((e => e.json())).catch(console.error);
                    if (void 0 !== e) {
                        if ("invalid-credentials" === e.status) return alert("Invalid edit password. If you created this generator with an account, then you don't need the edit password, since being logged in gives you all editing permissions. So in that case just log in. If you created it anonymously, then you'd have recieved the edit password for this page when you first created it. Note that the edit password is different to the collab link/password. The edit password has more permissions, including the permission to create/disable the collab link, for example."), void o.close();
                        if (n = e.key, void 0 !== n) break;
                        await new Promise((e => setTimeout(e, 7e3)))
                    } else await new Promise((e => setTimeout(e, 7e3)))
                }
                if (collabLinkLoaderEl.hidden = !0, collabLinkContentEl.hidden = !1, copyEditorCollabLinkBtn.onclick = async function() {
                        await navigator.clipboard.writeText(editorCollabLinkEl.value), copyEditorCollabLinkBtn.textContent = "âœ… copied!", setTimeout((() => {
                            let e = document.querySelector("#copyEditorCollabLinkBtn");
                            e && (e.textContent = "ðŸ“‹ copy")
                        }), 2e3)
                    }, regenerateEditorCollabLinkBtn.onclick = async function() {
                        if (!n || confirm("This will create a new collab link, which means the previous one won't work anymore. Continue?")) {
                            editorCollabLinkEl.value = "", editorCollabLinkEl.placeholder = "â³ Generating collab link...", regenerateEditorCollabLinkBtn.disabled = !0, collabEnableDisableSelectEl.disabled = !0, copyEditorCollabLinkBtn.disabled = !0;
                            for (let e = 0; e < 2 && (n = await fetch("/api/regenerateCollabEditKey", {
                                    method: "POST",
                                    body: JSON.stringify({
                                        generatorName: window.generatorName,
                                        sessionToken: window.app.store.data.user.sessionToken || "",
                                        email: window.app.store.data.user.email || "",
                                        editKey: t
                                    }),
                                    headers: {
                                        "Content-Type": "application/json"
                                    },
                                    signal: AbortSignal.timeout(7e3)
                                }).then((e => e.json())).then((e => e.key)).catch(console.error), !n); e++) await new Promise((e => setTimeout(e, 7e3)));
                            n ? (editorCollabLinkEl.value = `${window.location.origin}${window.location.pathname}#edit:collab=${n}`, setTimeout((() => {
                                alert("Share the generated link to allow others to edit this generator. Please ð—¿ð—²ð—³ð—¿ð—²ð˜€ð—µ ð˜ð—µð—¶ð˜€ ð—½ð—®ð—´ð—² to begin the multiplayer editing session.")
                            }), 100)) : alert("There was an issue generating the collab link. Please try again."), regenerateEditorCollabLinkBtn.disabled = !1, collabEnableDisableSelectEl.disabled = !1, copyEditorCollabLinkBtn.disabled = !1, editorCollabLinkEl.placeholder = "Link will appear here when enabled..."
                        }
                    }, n) {
                    let e = `${window.location.origin}${window.location.pathname}#edit:collab=${n}`;
                    editorCollabLinkEl.value = e, collabEnableDisableSelectEl.value = "enabled", editorCollabLinkCtn.hidden = !1
                } else collabEnableDisableSelectEl.value = "disabled";
                collabEnableDisableSelectEl.disabled = !1, collabEnableDisableSelectEl.onchange = function() {
                    if ("enabled" === collabEnableDisableSelectEl.value)
                        if (collabLinkLoaderEl.hidden = !0, collabLinkContentEl.hidden = !1, editorCollabLinkCtn.hidden = !1, n) {
                            let e = `${window.location.origin}${window.location.pathname}#edit:collab=${n}`;
                            editorCollabLinkEl.value = e
                        } else regenerateEditorCollabLinkBtn.click();
                    else {
                        if (!confirm("This will invalidate the existing collab link, meaning that anyone with the existing link will no longer be able to edit this generator. If you re-enable it later, a new link will be generated. Continue?")) return void(collabEnableDisableSelectEl.value = "enabled");
                        collabLinkLoaderEl.hidden = !1, collabLinkContentEl.hidden = !0, async function() {
                            const e = editorCollabLinkEl.value;
                            let o;
                            editorCollabLinkEl.value = "";
                            for (let e = 0; e < 2 && (o = await fetch("/api/deleteCollabEditKey", {
                                    method: "POST",
                                    body: JSON.stringify({
                                        generatorName: window.generatorName,
                                        sessionToken: window.app.store.data.user.sessionToken || "",
                                        email: window.app.store.data.user.email || "",
                                        editKey: t
                                    }),
                                    headers: {
                                        "Content-Type": "application/json"
                                    },
                                    signal: AbortSignal.timeout(7e3)
                                }).then((e => e.json())).then((e => "success" === e.status)).catch(console.error), !o); e++) await new Promise((e => setTimeout(e, 7e3)));
                            if (o) {
                                n = null, editorCollabLinkCtn.hidden = !0;
                                try {
                                    window.yjsProvider.disconnect()
                                } catch (e) {
                                    console.error(e)
                                }
                            } else alert("There was an issue disabling the collab link. Please try again."), collabEnableDisableSelectEl.value = "enabled", editorCollabLinkEl.value = e;
                            collabLinkLoaderEl.hidden = !0, collabLinkContentEl.hidden = !1
                        }()
                    }
                }
            }
        }, {
            name: "wrapLines",
            title: "Alt+Z",
            innerHTML: `${w} <span>wrap lines</span>`,
            onclick: function(e) {
                y._toggleLineWrapping()
            }
        }, {
            name: "foldLines",
            innerHTML: `${b} <span>fold lines</span>`,
            onclick: function(e) {
                y._toggleLineFolding()
            }
        }, {
            name: "fontSize",
            innerHTML: '<svg style="height:1.3rem;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6h4m4 0h-4m0 0v12M4 11h3m3 0H7m0 0v7"/></svg> <span>font size</span>',
            onclick: function(e) {
                let t = window.getComputedStyle(y.dom).fontSize.replace("px", ""),
                    n = prompt("Enter new font size:", t);
                if (n && !isNaN(Number(n))) {
                    n = Number(n), localStorage.editorFontSize = n > 50 ? 50 : n < 3 ? 3 : n, [...document.querySelectorAll(".custom-codemirror-editor-font-size")].forEach((e => e.remove()));
                    let e = document.createElement("style");
                    e.className = "custom-codemirror-editor-font-size", e.innerHTML = `.CodeMirror, .cm-editor { font-size: ${n}px !important; line-height: ${1.4*n}px !important; }`, document.head.appendChild(e)
                } else "" === n && (localStorage.editorFontSize = "", [...document.querySelectorAll(".custom-codemirror-editor-font-size")].forEach((e => e.remove())))
            }
        }, {
            name: "toggleCopilot",
            title: "Toggle the AI-powered code completion feature on/off. Use Ctrl+Shift+Space to toggle it. Use Ctrl+Space to trigger one-off completions manually.",
            innerHTML: '<svg style="height:1.3rem;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 20H5v-2m3 2v-4h4m-4 4h4m4 0h3v-2m-3 2v-4h-4m4 4h-4m0-4v4m0-11H9a4 4 0 0 0-4 4v0m7-4h3a4 4 0 0 1 4 4v0m-7-4V5m7 8h1a2 2 0 0 1 2 2v1a2 2 0 0 1-2 2h-1m0-5v5M5 14.5v2M5 13H4a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h1m0-5v5m4-5h.001M15 13h.001"/><circle cx="12" cy="5" r="1" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/></svg> <span class="copilotToggleButtonLabelEl">predict</span>',
            onclick: function(e) {
                y._toggleCopilot()
            }
        }, {
            name: "toggleBugChecker",
            title: "Toggle the AI-powered bug checker.",
            innerHTML: '<svg style="height:1.3rem;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m16 4-2.251 2.251m0 0A5.782 5.782 0 0 0 12 6a5.56 5.56 0 0 0-1.711.289m3.46-.038c1.551.49 2.417 1.623 2.858 2.749M8 4l2.289 2.289m0 0C9.135 6.67 7.914 7.479 7.339 9m9.268 0A5.66 5.66 0 0 1 17 11v2m-.393-4H18c.667 0 2-.4 2-2m-3 6v2a5.66 5.66 0 0 1-.393 2M17 13h3m-3.393 4c-.585 1.494-1.918 3-4.607 3s-4.022-1.506-4.607-3m9.214 0H18c.667 0 2 .4 2 2M7.338 9C7.125 9.564 7 10.226 7 11v2m.338-4H6c-.667 0-2-.4-2-2m3 6v2c0 .546.107 1.272.393 2M7 13H4m3.393 4H6c-.667 0-2 .4-2 2m8-9h.001M10 13h.001M14 13h.001"/></svg> <span class="toggleBugCheckButtonLabelEl">checker</span>',
            onclick: function(e) {
                y._toggleBugChecker()
            }
        }]
    });
    S = v.items.find((e => "wrapLines" === e.name)), k = v.items.find((e => "foldLines" === e.name));
    let P = document.createElement("div");
    return P.style.cssText = "position:absolute; top:0.125rem; left:0.125rem; display:flex; flex-direction:column; gap:0.125rem;", P.append(v.container), e.parentElement.append(P), y._sideButtonsContainer = P, y._docId = e.docId, y._contentType = e.docId, async function() {
        await new Promise((e => setTimeout(e, 2e3))), await async function({
            editorView: e,
            getPrediction: t,
            defaultDelay: n,
            acceptOnClick: o
        }) {
            if (e._alreadyAddedCopilotExtension) return console.warn("Already inited editor copilot.");
            e._alreadyAddedCopilotExtension = !0, void 0 === localStorage.copilotIsEnabled && (localStorage.copilotIsEnabled = "1");
            document.querySelectorAll(".copilotToggleButtonLabelEl").forEach((e => e.textContent = `predict (${localStorage.copilotIsEnabled?"on":"off"})`)), window.editorWorkerByContentType || (window.editorWorkerByContentType = {});
            window.editorWorkerByContentType[e._contentType] || (window.editorWorkerByContentType[e._contentType] = createProxiedWorker("./lib/editorWorker.js", {
                terminateUnresponsiveAfter: 6e4
            }));
            const h = window.editorWorkerByContentType[e._contentType],
                {
                    ViewPlugin: p,
                    Decoration: f,
                    WidgetType: g,
                    keymap: y
                } = CM["@codemirror/view"],
                {
                    StateEffect: w,
                    Facet: b,
                    Prec: S,
                    StateField: k,
                    EditorSelection: v
                } = CM["@codemirror/state"];
            let P = null;
            const C = new Map,
                Q = w.define(),
                $ = k.define({
                    create: () => ({
                        loading: !1,
                        suggestion: null
                    }),
                    update(e, t) {
                        for (let n of t.effects)
                            if (n.is(Q)) return { ...e,
                                ...n.value
                            };
                        return t.docChanged || t.selection ? { ...e,
                            suggestion: null
                        } : e
                    }
                });
            if (!window.alreadyAddedCopilotLoadingWidgetStyles) {
                window.alreadyAddedCopilotLoadingWidgetStyles = !0;
                let e = document.createElement("style");
                e.textContent = "@keyframes cm-copilot-loading-highlight-loop {\n      0% { width: 0; }\n      99.99% { width: 100%; }\n      100% { width: 0; }\n    }", document.head.appendChild(e)
            }
            const A = '<div style="position:relative; display:inline-block;"><span style="position:relative; display:inline-block; opacity:0.3;">â‹¯</span><span style="position:absolute; top:0; left:0; right:0; bottom:0; overflow:hidden; animation:cm-copilot-loading-highlight-loop 1s linear infinite;">â‹¯</span></div>';
            class LoadingWidget extends g {
                toDOM() {
                    let t = "";
                    if (Number(localStorage.numCopilotPredictionsAccepted || 0) < 10 && Number(localStorage.copilotToggleCount || 0) < 3) {
                        let n = e.state.selection.main.head,
                            o = e.state.doc.toString().slice(n, n + 500);
                        o && o.trim() && !/^\s*(\n|$)/.test(o) || (t = " (Ctrl+Shift+Space or âš™ï¸ menu to disable)")
                    }
                    const n = document.createElement("span");
                    return n.className = "cm-completion-loading", n.innerHTML = A + t, Object.assign(n.style, {
                        position: "absolute",
                        opacity: "0.6",
                        pointerEvents: "none",
                        transform: "translateX(-50%)",
                        width: "0px",
                        height: "0px"
                    }), n
                }
            }
            if (!window.alreadyAddedCopilotSuggestionWidgetStyles) {
                window.alreadyAddedCopilotSuggestionWidgetStyles = !0;
                let e = document.createElement("style");
                e.textContent = "\n      .cm-activeLine.cm-line:has(.cm-inline-suggestion-click-hitbox) { position: relative; }\n    ", document.head.appendChild(e)
            }
            class SuggestionWidget extends g {
                constructor(e) {
                    super(), this.text = e
                }
                toDOM(e) {
                    const t = document.createElement("span");
                    if (t.className = "cm-inline-suggestion", t.style.cssText = "cursor:pointer; opacity:0.4; padding-top:0.25em;", t.textContent = this.text, !localStorage.hasTabAcceptedCopilotSuggestion && !window.matchMedia("(pointer: coarse)").matches) {
                        let e = document.createElement("span");
                        e.innerHTML = ' <span style="font-weight:bold; font-style:italic; margin-left:0.25rem;">(Tab to accept)</span>', t.append(e)
                    } {
                        let n = !1;
                        t.onmousedown = t => {
                            if (n) return;
                            n = !0, t.preventDefault(), t.stopPropagation();
                            const o = e.state.field($);
                            o.suggestion && (this.accept(e, o.suggestion), localStorage.numCopilotPredictionsAccepted = Number(localStorage.numCopilotPredictionsAccepted || 0) + 1)
                        }
                    }
                    return t
                }
                accept(e, t) {
                    const {
                        state: n
                    } = e, o = n.changeByRange((e => {
                        const o = e == n.selection.main ? n.selection.main.head : e.from;
                        return {
                            changes: {
                                from: o,
                                to: o,
                                insert: t
                            },
                            range: v.cursor(o + t.length)
                        }
                    }));
                    e.dispatch({ ...o,
                        userEvent: "input.complete"
                    })
                }
            }
            let M = 0,
                R = !1;
            class RequestManager {
                constructor() {
                    this.requestCounter = 0, this.debounceTimer = null
                }
                cancel() {
                    this.requestCounter++, this.debounceTimer && (clearTimeout(this.debounceTimer), this.debounceTimer = null), P && P.abort(), setTimeout((() => {
                        e.destroyed || e.dispatch({
                            effects: Q.of({
                                loading: !1,
                                suggestion: null
                            })
                        })
                    }), 0)
                }
                scheduleFetchSuggestion(e = n) {
                    this.cancel();
                    const t = ++this.requestCounter;
                    return this.debounceTimer = setTimeout((() => {
                        this.debounceTimer = null, t === this.requestCounter && this.fetchSuggestion(t)
                    }), e + 10 * M), t
                }
                async fetchSuggestion(n) {
                    if (!localStorage.copilotIsEnabled) return;
                    const o = e,
                        p = e.state;
                    P && P.abort(), P = new AbortController;
                    let f, g, y = p.doc.toString(),
                        w = p.selection.main.head,
                        b = y.slice(w, w + 500);
                    if (/^[a-zA-Z0-9]/.test(b)) return;
                    try {
                        const t = e._contentType;
                        let n = performance.now();
                        ({
                            prefix: f,
                            suffix: g
                        } = await h.getPrefixAndSuffixForAutocomplete({
                            fullDocStr: y,
                            caretPosition: w,
                            characterLimit: 2e4,
                            docId: t
                        }));
                        let o = performance.now() - n;
                        R && (M = o), R = !0, console.debug("editorWorker.getPrefixAndSuffixForAutocomplete:", {
                            prefixLength: f.length,
                            suffixLength: g.length,
                            timeTaken: o
                        })
                    } catch (e) {
                        return void console.error(e)
                    }
                    const S = `${f}<:|:>${g}`,
                        k = C.get(S);
                    if (k) setTimeout((() => {
                        n !== this.requestCounter || o.destroyed || o.dispatch({
                            effects: Q.of({
                                loading: !1,
                                suggestion: k
                            })
                        })
                    }), 0);
                    else {
                        setTimeout((() => {
                            n !== this.requestCounter || o.destroyed || o.dispatch({
                                effects: Q.of({
                                    loading: !0
                                })
                            })
                        }), 0);
                        try {
                            const e = await t(f, g, P.signal);
                            P.signal.aborted || n !== this.requestCounter || (C.size > 10 && C.clear(), C.set(S, e), setTimeout((() => {
                                o.destroyed || n !== this.requestCounter || (o.dispatch({
                                    effects: Q.of({
                                        loading: !1,
                                        suggestion: e
                                    })
                                }), localStorage.numCopilotPredictionRequests = Number(localStorage.numCopilotPredictionRequests || 0) + 1)
                            }), 0))
                        } catch (e) {
                            if ("AbortError" !== e.name && n === this.requestCounter) throw setTimeout((() => {
                                o.destroyed || o.dispatch({
                                    effects: Q.of({
                                        loading: !1
                                    })
                                })
                            }), 0), e
                        }
                    }
                }
            }
            const D = p.fromClass(class {
                constructor() {
                    this.decorations = f.none, this.requestManager = new RequestManager
                }
                update(e) {
                    if (e.transactions.some((e => e.selection && !e.docChanged || e.isUserEvent("select") || e.isUserEvent("pointer")))) return void this.requestManager.cancel();
                    const t = e.state.field($),
                        n = e.state.selection.main.head;
                    this.decorations = f.set([...t.loading ? [f.widget({
                        widget: new LoadingWidget,
                        side: 1
                    }).range(n)] : [], ...t.suggestion ? [f.widget({
                        widget: new SuggestionWidget(t.suggestion),
                        side: 1
                    }).range(n)] : []]), e.docChanged && !e.transactions.some((e => e.isUserEvent("input.complete"))) && this.requestManager.scheduleFetchSuggestion()
                }
            }, {
                decorations: e => e.decorations
            });

            function notify(e) {
                const t = document.createElement("style");
                t.textContent = "\n      @keyframes copilot-notify-jiggle {\n        0%, 100% { transform: translateX(0); }\n        25% { transform: translateX(-3px); }\n        75% { transform: translateX(3px); }\n      }", document.head.appendChild(t);
                const n = document.createElement("div");
                n.style.cssText = "width:100%; position:fixed; bottom:1rem; left:0; right:0; text-align:center; z-index:10000;", n.innerHTML = `<div style="display:inline-block; max-width:max-content; width:max(100vw, 300px); background:light-dark(#fff, #222); padding:0.25rem; border:1px solid light-dark(#ddd, #444); border-radius:4px; z-index:1000; font-family: sans-serif; font-size:0.9rem; box-shadow:1px 1px 4px 0px light-dark(#ddd, #1b1b1b); animation: copilot-notify-jiggle 0.2s linear 5;">${e}</div>`;
                const o = n.querySelector("div");
                document.body.appendChild(n), o.onclick = () => {
                    n.remove(), localStorage.copilotToggleCount = Number(localStorage.copilotToggleCount || 0) + 5
                }, setTimeout((() => {
                    n.remove(), t.remove()
                }), 3e4)
            }
            const L = S.highest(y.of([{
                    key: "Tab",
                    run: e => {
                        const {
                            suggestion: t
                        } = e.state.field($);
                        return !!t && (localStorage.hasTabAcceptedCopilotSuggestion || (localStorage.hasTabAcceptedCopilotSuggestion = "1"), new SuggestionWidget(t).accept(e, t), !0)
                    }
                }, {
                    key: "Ctrl-Shift-Space",
                    run: e => {
                        localStorage.copilotIsEnabled && Number(localStorage.copilotToggleCount || 0) <= 2 && notify('\n            <div>Use <b style="color:green;">Ctrl<span style="color:initial">+</span>Shift<span style="color:initial">+</span>Space</b> to toggle, or <b style="color:green;">Ctrl<span style="color:initial">+</span>Space</b> to manually trigger predictions.</div>\n            <div style="font-size: 90%;"><b>Tip:</b> Tell the AI what you want with a comment like <b style="color: orange;">// A list of 100 animals:</b></div>\n          '), localStorage.copilotToggleCount = Number(localStorage.copilotToggleCount || 0) + 1, localStorage.copilotIsEnabled = localStorage.copilotIsEnabled ? "" : "1", document.querySelectorAll(".copilotToggleButtonLabelEl").forEach((e => e.textContent = `predict (${localStorage.copilotIsEnabled?"on":"off"})`)), console.debug("Copilot " + (localStorage.copilotIsEnabled ? "enabled" : "disabled"));
                        const t = e.plugin(D);
                        return localStorage.copilotIsEnabled ? t.requestManager.scheduleFetchSuggestion(1) : t.requestManager.cancel(), !0
                    }
                }, {
                    key: "Ctrl-Space",
                    run: e => {
                        e.state.field($).suggestion && (C.clear(), e.plugin(D).requestManager.cancel()), localStorage.copilotIsEnabled || (localStorage.copilotIsEnabled = "1", setTimeout((() => {
                            localStorage.copilotIsEnabled = ""
                        }), 20));
                        return e.plugin(D).requestManager.scheduleFetchSuggestion(1), !0
                    }
                }, {
                    key: "Escape",
                    run: e => (e.plugin(D).requestManager.cancel(), !0)
                }])),
                V = [$, D, L];
            e.dispatch({
                effects: w.appendConfig.of(V)
            }), e._toggleCopilot = () => {
                localStorage.copilotIsEnabled = localStorage.copilotIsEnabled ? "" : "1", document.querySelectorAll(".copilotToggleButtonLabelEl").forEach((e => e.textContent = `predict (${localStorage.copilotIsEnabled?"on":"off"})`)), console.debug("Copilot " + (localStorage.copilotIsEnabled ? "enabled" : "disabled"));
                const t = e.plugin(D);
                return localStorage.copilotIsEnabled ? t.requestManager.scheduleFetchSuggestion(1) : t.requestManager.cancel(), !!localStorage.copilotIsEnabled
            }
        }({
            editorView: y,
            getPrediction: async (e, t, n) => {
                console.debug("getPrediction called...");
                let o = !1;

                function signalAbortHandler() {
                    o = !0, console.debug("getPrediction got abort signal")
                }
                n.addEventListener("abort", signalAbortHandler);
                try {
                    return await fetch("https://editor-copilot.perchance.org/api/autocomplete", {
                        signal: n,
                        headers: {
                            "Content-Type": "application/json"
                        },
                        method: "POST",
                        body: JSON.stringify({
                            prefix: e,
                            suffix: t,
                            contentType: y._contentType,
                            generatorName: window.generatorName
                        })
                    }).then((e => e.text()))
                } finally {
                    console.debug("getPrediction finished." + (o ? " (aborted)" : "")), n.removeEventListener("abort", signalAbortHandler)
                }
            },
            defaultDelay: 1e3,
            acceptOnClick: !0
        })
    }(), async function() {
        async function sha256Text(e) {
            const t = (new TextEncoder).encode(e),
                n = await crypto.subtle.digest("SHA-256", t);
            return Array.from(new Uint8Array(n)).map((e => e.toString(16).padStart(2, "0"))).join("")
        }
        for (await new Promise((e => setTimeout(e, 4e3))), function(e) {
                if (e._alreadyAddedBugIndicatorSystem) return;
                e._alreadyAddedBugIndicatorSystem = !0;
                const {
                    EditorView: t,
                    Decoration: n
                } = CM["@codemirror/view"], {
                    StateField: o,
                    StateEffect: h
                } = CM["@codemirror/state"], p = document.createElement("div");
                p.style.cssText = "position:fixed; background:light-dark(white, #333); color:light-dark(black, white); padding: 8px; border-radius: 4px; font-size: 14px; z-index: 5000; max-width: 380px; border:1px solid light-dark(#c7c7c7, #3f3f3f); box-shadow:0px 1px 6px light-dark(#0000001f, #0000002e);", p.hidden = !0;
                const f = document.createElement("div"),
                    g = document.createElement("div");
                g.style.cssText = "font-size:80%; opacity:0.5; margin-top:0.25rem; margin-bottom:0.25rem;", g.innerHTML = ("outputTemplate" === e._contentType ? "The âœ¨ button in the lower-right can be used to fix things. " : "") + "This is AI-generated and <b>may be incorrect</b>. You can add a comment above a particular bit of incorrectly-flagged code to tell the AI why it isn't actually an issue.";
                const y = document.createElement("button");
                y.style.cssText = "width:100%;", y.textContent = "dismiss", p.appendChild(f), p.appendChild(g), p.appendChild(y), document.body.appendChild(p);
                const toolTipHiderClickHandler = e => {
                    !p.contains(e.target) && Date.now() - b > 300 && (p.hidden = !0)
                };

                function destroy() {
                    p.remove(), document.removeEventListener("click", toolTipHiderClickHandler)
                }
                let w = setInterval((() => {
                        e.destroyed && (destroy(), clearInterval(w))
                    }), 3e4),
                    b = 0;

                function positionTooltip(e, t, n = document.body) {
                    e.hidden && console.warn("Tooltip must be visible to get bounding rect"), e.style.left = "0", e.style.top = "0", e.hidden = !1;
                    const o = t.getBoundingClientRect(),
                        h = n.getBoundingClientRect(),
                        p = e.getBoundingClientRect();
                    let f = o.left + o.width / 2 - p.width / 2,
                        g = o.bottom + 8;
                    const y = h.left,
                        w = h.right - p.width,
                        b = h.top,
                        S = h.bottom - p.height;
                    if (f = Math.max(y, Math.min(w, f)), g > S) {
                        const e = o.top - p.height - 8;
                        e >= b && (g = e)
                    }
                    if (g < b || g > S) {
                        const e = o.top - h.top;
                        g = h.bottom - o.bottom > e ? Math.min(S, o.bottom + 8) : Math.max(b, h.top + 8)
                    }
                    f = Math.max(0, Math.min(window.innerWidth - p.width, f)), g = Math.max(0, Math.min(window.innerHeight - p.height, g)), e.style.left = `${f}px`, e.style.top = `${g}px`
                }
                document.addEventListener("click", toolTipHiderClickHandler);
                let S = document.createElement("div");
                S.innerHTML = '<div style="user-select: none; cursor: pointer; font-size: 0.75rem; display: inline-block; width: min-content; height: min-content; background: light-dark(rgb(183, 244, 255), rgb(13, 88, 92)); padding: 1px; border: 1px solid light-dark(rgb(102, 214, 224), rgb(0, 115, 126)); border-radius: 3px; font-family: sans-serif; line-height: normal;">âš ï¸</div>', S = S.firstElementChild, e._sideButtonsContainer.append(S), S.onclick = () => e._scrollToNextBugIndicator(), S.hidden = !0;
                const k = h.define(),
                    v = h.define(),
                    P = o.define({
                        create: () => ({
                            decorations: n.none,
                            indicators: []
                        }),
                        update(e, t) {
                            let {
                                decorations: o,
                                indicators: h
                            } = e;
                            o = o.map(t.changes);
                            let p = !1;
                            for (let e of t.effects)
                                if (e.is(k) && (p = !0, h.push(e.value)), e.is(v)) {
                                    p = !0;
                                    const {
                                        from: t,
                                        to: n
                                    } = e.value;
                                    h = h.filter((e => !(e.from === t && e.to === n)))
                                }
                            if (t.docChanged) {
                                p = !0, h = h.map((e => ({ ...e,
                                    from: t.changes.mapPos(e.from),
                                    to: t.changes.mapPos(e.to),
                                    parentFrom: t.changes.mapPos(e.parentFrom),
                                    parentTo: t.changes.mapPos(e.parentTo)
                                })));
                                const e = [];
                                t.changes.iterChanges(((t, n, o, h) => {
                                    e.push({
                                        from: o,
                                        to: h
                                    })
                                })), h = h.filter((t => !e.some((e => e.from >= t.parentFrom && e.to <= t.parentTo))))
                            }
                            return p && (o = n.set(h.flatMap((e => [n.mark({
                                class: "cm-bug-highlight-parent",
                                attributes: {
                                    "data-parent-from": e.parentFrom.toString(),
                                    "data-parent-to": e.parentTo.toString()
                                }
                            }).range(e.parentFrom, e.parentTo), n.mark({
                                class: "cm-bug-highlight",
                                attributes: {
                                    "data-explanation": e.explanation,
                                    "data-parent-hash": e.parentHash,
                                    "data-snippet": e.snippet,
                                    "data-from": e.from.toString(),
                                    "data-to": e.to.toString(),
                                    "data-parent-from": e.parentFrom.toString(),
                                    "data-parent-to": e.parentTo.toString()
                                }
                            }).range(e.from, e.to)])).sort(((e, t) => {
                                const n = e.from - t.from;
                                return 0 !== n ? n : e.startSide - t.startSide
                            })))), S.hidden = 0 === h.length, {
                                decorations: o,
                                indicators: h
                            }
                        },
                        provide: e => t.decorations.from(e, (e => e.decorations))
                    });
                if (!document.querySelector(".cm-bug-highlight-styles")) {
                    const e = document.createElement("style");
                    e.className = "cm-bug-highlight-styles", e.innerHTML = "\n      .cm-bug-highlight { background-color: light-dark(#ff00496b, #b71c007a); cursor: pointer; }\n    ", document.head.append(e)
                }
                e.dom.addEventListener("click", (async t => {
                    const n = t.target.closest(".cm-bug-highlight");
                    if (n) {
                        const t = parseInt(n.dataset.from),
                            o = parseInt(n.dataset.to),
                            h = n.dataset.parentHash,
                            g = n.dataset.snippet,
                            w = `${window.generatorName}:${h}:${g}`;
                        f.textContent = n.dataset.explanation, f.dataset.indicatorId = w, p.hidden = !1, positionTooltip(p, n, document.body), b = Date.now(), y.onclick = async () => {
                            e.dispatch({
                                effects: [v.of({
                                    from: t,
                                    to: o
                                })]
                            }), p.hidden = !0, await kv.dismissedEditorBugIndicators.set(w, {
                                time: Date.now()
                            })
                        }
                    }
                })), e.dispatch({
                    effects: h.appendConfig.of([P])
                }), e._addBugIndicator = function({
                    from: t,
                    to: n,
                    snippet: o,
                    explanation: h,
                    parentHash: p,
                    parentFrom: f,
                    parentTo: g
                }) {
                    void 0 !== f && void 0 !== g ? (S.hidden = !1, e.dispatch({
                        effects: [k.of({
                            from: t,
                            to: n,
                            snippet: o,
                            explanation: h,
                            parentHash: p,
                            parentFrom: f,
                            parentTo: g
                        })]
                    })) : console.warn("Bug indicator requires parentFrom and parentTo parameters")
                }, e._getBugIndicators = function() {
                    return e.state.field(P).indicators.map((t => ({ ...t,
                        delete: async () => {
                            e.dispatch({
                                effects: [v.of({
                                    from: t.from,
                                    to: t.to
                                })]
                            });
                            const n = `${window.generatorName}:${t.parentHash}:${t.snippet}`;
                            p.hidden || f.dataset.indicatorId !== n || (p.hidden = !0), await kv.dismissedEditorBugIndicators.set(n, {
                                time: Date.now()
                            })
                        }
                    }))).sort(((e, t) => e.from - t.from))
                }, e._clearAllBugIndicators = function() {
                    e._getBugIndicators().forEach((e => e.delete()))
                }, e._scrollToNextBugIndicator = function() {
                    const n = e._getBugIndicators();
                    if (0 === n.length) return;
                    const o = e.state.selection.main.head;
                    let h = n.find((e => e.from > o));
                    h || (h = n[0]), e.dispatch({
                        effects: t.scrollIntoView(h.from, {
                            y: "center",
                            x: "center"
                        })
                    }), e.dispatch({
                        selection: {
                            anchor: h.from,
                            head: h.from
                        }
                    })
                }
            }(y), void 0 === localStorage[y._contentType + ":BugCheckEnabled"] && (localStorage[y._contentType + ":BugCheckEnabled"] = "1"), y._toggleBugChecker = function() {
                localStorage[y._contentType + ":BugCheckEnabled"] = localStorage[y._contentType + ":BugCheckEnabled"] ? "" : "1", localStorage[y._contentType + ":BugCheckEnabled"] || y._clearAllBugIndicators(), y._sideButtonsContainer.querySelector(".toggleBugCheckButtonLabelEl").textContent = `bug check (${localStorage[y._contentType+":BugCheckEnabled"]?"on":"off"})`
            }, y._sideButtonsContainer.querySelector(".toggleBugCheckButtonLabelEl").textContent = `bug check (${localStorage[y._contentType+":BugCheckEnabled"]?"on":"off"})`; !localStorage[y._contentType + ":BugCheckEnabled"];) await new Promise((e => setTimeout(e, 2e3)));
        window.lastEditTimeByDocId || (window.lastEditTimeByDocId = {}), window.lastEditTimeByDocId[y._docId] = Date.now(), y.dom.addEventListener("keyup", (() => {
            window.lastEditTimeByDocId[y._docId] = Date.now()
        })), window.editorWorkerByContentType || (window.editorWorkerByContentType = {}), window.editorWorkerByContentType[y._contentType] || (window.editorWorkerByContentType[y._contentType] = createProxiedWorker("./lib/editorWorker.js", {
            terminateUnresponsiveAfter: 6e4
        }));
        let t = window.editorWorkerByContentType[y._contentType];
        if (window.alreadyStartedBugFinderForDocId || (window.alreadyStartedBugFinderForDocId = {}), window.alreadyStartedBugFinderForDocId[y._docId]) return;
        window.alreadyStartedBugFinderForDocId[y._docId] = !0;
        let n = 0;
        const o = new Set;
        let h = null,
            p = 0,
            f = 0;
        for (;;) {
            for (; !localStorage[y._contentType + ":BugCheckEnabled"];) t && (t.terminate(), window.editorWorkerByContentType[y._contentType] = null, t = null), await new Promise((e => setTimeout(e, 2e3)));
            if (t || (await new Promise((e => setTimeout(e, 1e3))), window.editorWorkerByContentType[y._contentType] = createProxiedWorker("./lib/editorWorker.js", {
                    terminateUnresponsiveAfter: 6e4
                }), t = window.editorWorkerByContentType[y._contentType], await new Promise((e => setTimeout(e, 1e3)))), t.terminated) return;
            let g = 500;
            h && (g = h, h = null), await new Promise((e => setTimeout(e, g)));
            try {
                if (Date.now() - window.lastEditTimeByDocId[y._docId] < 2e3) {
                    await new Promise((e => setTimeout(e, 500)));
                    continue
                }
                if (n > window.lastEditTimeByDocId[y._docId]) {
                    await new Promise((e => setTimeout(e, 5e3)));
                    continue
                }
                await new Promise((e => setTimeout(e, 10 * p)));
                let g, w, b = performance.now(),
                    S = 0;
                if ("outputTemplate" === y._contentType) {
                    const e = y._contentType,
                        h = y.state.doc.toString();
                    if (console.debug("Getting next output template node for bug finding..."), w = await t.getNextOutputTemplateNodeForBugFinding({
                            htmlString: h,
                            alreadyConsumedNodeHashes: o,
                            maxChars: 2e4,
                            minChars: 50,
                            docId: e
                        }), !w) {
                        n = Date.now();
                        continue
                    }
                    const p = (w.comments || []).map((e => "CommentLine" === e.type ? "// " + e.value : `/* ${e.value} */`)).join("\n") + "\n";
                    g = p + w.code, S = p.length
                } else {
                    if ("modelText" !== y._contentType) throw new Error("Unknown contentType"); {
                        const e = y.state.doc.toString();
                        if (console.debug("Getting next model text node for bug finding..."), w = await t.getNextModelTextNodeForBugFinding({
                                docText: e,
                                alreadyConsumedNodeHashes: o,
                                maxChars: 2e4
                            }), !w) {
                            n = Date.now();
                            continue
                        }
                        g = w.code
                    }
                }
                let k, v = performance.now() - b;
                console.debug(`Bug Finding (${y._contentType}):`, {
                    node: w,
                    timeTaken: v
                }), p = v;
                let P = window.generatorName + ":" + w.hash,
                    C = await kv.editorBugsCache.get(P),
                    Q = !1;
                if (C) Q = !0, k = C.bugs, h = 50;
                else {
                    let e;
                    for (let t = 0; t < 3 && (e = await fetch("https://editor-copilot.perchance.org/api/findBugsInCode", {
                            headers: {
                                "Content-Type": "application/json"
                            },
                            method: "POST",
                            body: JSON.stringify({
                                code: g,
                                contentType: y._contentType,
                                generatorName: window.generatorName
                            })
                        }).then((e => e.ok ? e.json() : null)).catch(console.error), !e || !Array.isArray(e)); t++) await new Promise((e => setTimeout(e, 1e3 * (t + 1))));
                    e && Array.isArray(e) ? (k = e, await kv.editorBugsCache.set(P, {
                        time: Date.now(),
                        bugs: k
                    })) : k = []
                }
                if (!localStorage[y._contentType + ":BugCheckEnabled"]) {
                    console.debug("Bug check disabled while fetch was in process. Skipping adding bugs.");
                    continue
                }
                if (y.state.doc.sliceString(w.absoluteStart, w.absoluteEnd) === w.code) {
                    for (let {
                            start: t,
                            end: n,
                            snippet: o,
                            explanation: h
                        } of k) {
                        let p = t - S,
                            f = n - S,
                            g = await sha256Text(w.code.slice(p - 100, f + 100));
                        if (!await kv.dismissedEditorBugIndicators.get(`${window.generatorName}:${g}:${o}`))
                            for (let t of window.editorViewsByDocId[e.docId]) t._addBugIndicator({
                                from: w.absoluteStart + p,
                                to: w.absoluteStart + f,
                                snippet: o,
                                explanation: h,
                                parentHash: g,
                                parentFrom: w.absoluteStart,
                                parentTo: w.absoluteEnd
                            })
                    }
                    console.debug(`Added ${k.length} bugs for node (from ${Q?"cache":"server"}):`, {
                        node: w,
                        bugs: k
                    })
                } else console.debug("Node changed since bug finding request was made.");
                o.add(w.hash), f = 0
            } catch (e) {
                console.debug("Error in bug finder loop:", e), f++;
                let t = 3;
                f > 3 && (t = 10), f > 10 && (t = 30), await new Promise((e => setTimeout(e, 1e3 * t)))
            }
        }
    }(), y
}

function createModelTextEditorView(e = {}) {
    let t = {
            jsBlockRanges: []
        },
        n = createEditorView({
            lintContext: t,
            extraStateExtensions: [StreamLanguage.define(mkJavaScriptModelText({
                name: "javascript"
            }, t)), ...e.extraStateExtensions || []],
            parentElement: e.parentElement,
            yText: e.yText,
            docId: "modelText"
        });
    return n._isModelText = !0, n
}
const Jc = StreamLanguage.define({
    startState: () => null,
    token: e => (e.skipToEnd(), null)
});

function getAttrValueCaseInsensitive(e, t) {
    if (!e) return;
    const n = t.toLowerCase();
    for (let t of Object.keys(e))
        if (t.toLowerCase() === n) return e[t]
}

function normalizeScriptType(e) {
    return "string" != typeof e ? "" : e.split(";")[0].trim().toLowerCase()
}

function isJavaScriptScriptType(e) {
    return "" === e || "text/javascript" === e || "application/javascript" === e || "text/ecmascript" === e || "application/ecmascript" === e || "module" === e || "server" === e
}

function isMarkdownScriptType(e) {
    return "text/markdown" === e || "text/x-markdown" === e
}

function createOutputTemplateEditorView(e = {}) {
    let t = StreamLanguage.define(mkJavaScript({
            name: "javascript"
        })),
        n = new LanguageSupport(t),
        o = new LanguageSupport(xa),
        h = markdown({
            codeLanguages: [LanguageDescription.of({
                name: "javascript",
                alias: ["js"],
                support: n
            }), LanguageDescription.of({
                name: "html",
                support: o
            })]
        }).language.parser,
        p = [...new Set([...Object.getOwnPropertyNames(document), ...Object.getOwnPropertyNames(Object.getPrototypeOf(Object.getPrototypeOf(document))), ...Object.getOwnPropertyNames(Object.getPrototypeOf(window))].filter((e => e.startsWith("on") && (null == document[e] || "function" == typeof document[e]))))],
        f = html({
            nestedLanguages: [{
                tag: "script",
                attrs: e => isMarkdownScriptType(normalizeScriptType(getAttrValueCaseInsensitive(e, "type"))),
                parser: h
            }, {
                tag: "script",
                attrs: e => {
                    const t = normalizeScriptType(getAttrValueCaseInsensitive(e, "type"));
                    return t && !isJavaScriptScriptType(t) && !isMarkdownScriptType(t)
                },
                parser: Jc.parser
            }, {
                tag: "script",
                attrs: e => isJavaScriptScriptType(normalizeScriptType(getAttrValueCaseInsensitive(e, "type"))),
                parser: t.parser
            }],
            nestedAttributes: p.map((e => ({
                name: e,
                parser: t.parser
            })))
        });
    console.debug("htmlLanguageExtension:", f);
    let g = createEditorView({
        lintContext: {
            type: "html"
        },
        extraStateExtensions: [f, ...e.extraStateExtensions || []],
        parentElement: e.parentElement,
        yText: e.yText,
        docId: "outputTemplate"
    });
    return g._isOutputTemplate = !0, g
}

function createProxiedWorker(e, t = {}) {
    const n = new Map,
        o = new Worker(e, {
            type: "module"
        });
    let h;
    o.onmessage = e => {
        const {
            id: t,
            returnValue: o,
            error: h
        } = e.data, p = n.get(t);
        p && (h ? p.reject(h) : p.resolve(o), n.delete(t))
    };
    let p = !1,
        f = new Proxy({
            _worker: o
        }, {
            get: (e, t) => "terminated" === t ? p : "terminate" === t ? () => {
                p = !0, o.terminate();
                for (let {
                        reject: e
                    } of n.values()) e("Worker was terminated.");
                n.clear(), clearInterval(h)
            } : async (...e) => {
                if (p) throw new Error("Worker was terminated.");
                const h = Math.random().toString(36).slice(2),
                    f = new Promise(((e, t) => {
                        n.set(h, {
                            resolve: e,
                            reject: t
                        })
                    }));
                return o.postMessage({
                    id: h,
                    functionName: t,
                    args: e
                }), f
            }
        });
    if (t.terminateUnresponsiveAfter) {
        let e = Date.now();
        h = setInterval((async () => {
            document.hidden ? e = Date.now() : Date.now() - e > t.terminateUnresponsiveAfter ? (console.error("Editor worker is unresponsive. Terminating."), f.terminate()) : "cGluZw==" === await f.btoa("ping") && (e = Date.now())
        }), t.terminateUnresponsiveAfter < 5 ? 1e3 : 1e4)
    }
    return f
}

function addLoader(e) {
    const t = document.createElement("div");
    return t.style.cssText = "position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.2);display:flex;align-items:center;justify-content:center", t.textContent = "âŒ›", e.style.position = "relative", e.appendChild(t), {
        delete: () => t.remove()
    }
}
async function init({
    modelTextInitialContent: e,
    outputTemplateInitialContent: t,
    mainModelTextEditorCtn: n,
    mainOutputTemplateEditorCtn: o
}) {
    let h = [];
    window.yDoc = new Doc;
    let p, f, g, y = !1;

    function addInitialContentIfNeeded() {
        y || (y = !0, window.yDoc.transact((n => {
            window.yDoc.getMap("___metadata___").get("gotInitialData") || (window.yDoc.getMap("___metadata___").set("gotInitialData", !0), window.yDoc.getText("modelText").insert(0, e), window.yDoc.getText("outputTemplate").insert(0, t))
        })), h.forEach((e => e.delete())))
    }
    if (/^#edit($|:)/.test(window.location.hash) && (p = window.location.hash.replace("#edit:", "").split(";").filter((e => e.startsWith("collab="))).map((e => e.split("=")[1]))[0]), !p && window.app.store.data.user.sessionToken && window.app.store.data.user.email && window.app.store.data.user.loggedIn) {
        let e = await window.initialLoadIsOwnerPromise || window.userOwnsThisGenerator;
        if (window.generatorData.collabEditModeIsEnabled || e) try {
            for (let e = 0; e < 2 && (p = await fetch(`/api/getCollabEditKey?generatorName=${window.generatorName}&sessionToken=${window.app.store.data.user.sessionToken||""}&email=${window.app.store.data.user.email||""}`).then((e => e.json())).then((e => e.key)).catch(console.error), void 0 === p); e++) {
                if (!(await window.initialLoadIsOwnerPromise || window.userOwnsThisGenerator)) break;
                await new Promise((e => setTimeout(e, 7e3)))
            }
        } catch (e) {
            console.error(e)
        }
    }
    if (p) {
        window.yjsProvider = null;
        let e = "wss://editor-collab.perchance.org",
            t = `${window.generatorName}:${p}`;
        window.yjsProvider = new WebsocketProvider(e, t, window.yDoc, {
            awareness: new Awareness(window.yDoc),
            maxBackoffTime: 1e4
        });
        let n = [{
                color: "#30bced",
                light: "#30bced33"
            }, {
                color: "#6eeb83",
                light: "#6eeb8333"
            }, {
                color: "#ffbc42",
                light: "#ffbc4233"
            }, {
                color: "#ecd444",
                light: "#ecd44433"
            }, {
                color: "#ee6352",
                light: "#ee635233"
            }, {
                color: "#9ac2c9",
                light: "#9ac2c933"
            }, {
                color: "#8acb88",
                light: "#8acb8833"
            }, {
                color: "#1be7ff",
                light: "#1be7ff33"
            }],
            o = n[Math.floor(Math.random() * n.length)];
        window.yjsProvider.awareness.setLocalStateField("user", {
            name: "Anonymous " + Math.floor(100 * Math.random()),
            color: o.color,
            colorLight: o.light
        }), window.yjsProvider.on("status", (e => {
            console.debug("WebsocketProvider:", e.status)
        })), window.yjsProvider.on("sync", (e => {
            console.debug("WebsocketProvider: isSynced:", e), e && ((window.docIdToView.modelText.getValue() || window.docIdToView.outputTemplate.getValue()) && h.forEach((e => e.delete())), async function() {
                await new Promise((e => setTimeout(e, 1e3))), addInitialContentIfNeeded()
            }())
        })), async function() {
            let e;
            for (let t = 0; t < 2 && (e = await fetch(`/api/validateCollabEditKey?generatorName=${window.generatorName}&key=${p}`, {
                    signal: AbortSignal.timeout(1e4)
                }).then((e => e.json())).then((e => "valid" === e.status)).catch(console.error), void 0 === e); t++) await new Promise((e => setTimeout(e, 7e3)));
            if (!e) p = null, alert("The collab password embedded in the URL is incorrect, or there was some other issue."), addInitialContentIfNeeded()
        }()
    } else addInitialContentIfNeeded();
    const w = ViewPlugin.fromClass(class {
        update(e) {
            e.docChanged && f._onChange && f._onChange(e)
        }
    });
    f = createModelTextEditorView({
        parentElement: n,
        extraStateExtensions: [w]
    });
    const b = ViewPlugin.fromClass(class {
        update(e) {
            e.docChanged && g._onChange && g._onChange(e)
        }
    });
    return g = createOutputTemplateEditorView({
        parentElement: o,
        extraStateExtensions: [b]
    }), window.docIdToView = {}, window.docIdToView.outputTemplate = g, window.docIdToView.modelText = f, y || (h.push(addLoader(n)), h.push(addLoader(o))), {
        mainModelTextEditorView: f,
        mainOutputTemplateEditorView: g
    }
}
setInterval((async () => {
    let e = await kv.dismissedEditorBugIndicators.entries(),
        t = 0;
    for (let [n, o] of e)(e.length - t > 1e4 || Date.now() - o.time > 31536e6) && (await kv.dismissedEditorBugIndicators.delete(n), t++)
}), 18e5), setInterval((async () => {
    let e = await kv.editorBugsCache.entries(),
        t = 0;
    for (let [n, o] of e)(e.length - t > 1e4 || Date.now() - o.time > 2592e6) && (await kv.editorBugsCache.delete(n), t++)
}), 18e5);
export {
    init
};
//# sourceMappingURL=editors.bundle.min.js.map